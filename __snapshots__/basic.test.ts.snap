// Vitest Snapshot v1

exports[`polyfillContent 1`] = `
"// node_modules/.pnpm/@jspm+core@2.0.0-beta.24/node_modules/@jspm/core/nodelibs/browser/chunk-4bd36a8f.js
var e;
var t;
var n = typeof Reflect == \\"object\\" ? Reflect : null;
var r = n && typeof n.apply == \\"function\\" ? n.apply : function(e9, t8, n8) {
  return Function.prototype.apply.call(e9, t8, n8);
};
t = n && typeof n.ownKeys == \\"function\\" ? n.ownKeys : Object.getOwnPropertySymbols ? function(e9) {
  return Object.getOwnPropertyNames(e9).concat(Object.getOwnPropertySymbols(e9));
} : function(e9) {
  return Object.getOwnPropertyNames(e9);
};
var i = Number.isNaN || function(e9) {
  return e9 != e9;
};
function o() {
  o.init.call(this);
}
e = o, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
var s = 10;
function u(e9) {
  if (typeof e9 != \\"function\\")
    throw new TypeError('The \\"listener\\" argument must be of type Function. Received type ' + typeof e9);
}
function f(e9) {
  return e9._maxListeners === void 0 ? o.defaultMaxListeners : e9._maxListeners;
}
function v(e9, t8, n8, r9) {
  var i7, o8, s6, v6;
  if (u(n8), (o8 = e9._events) === void 0 ? (o8 = e9._events = /* @__PURE__ */ Object.create(null), e9._eventsCount = 0) : (o8.newListener !== void 0 && (e9.emit(\\"newListener\\", t8, n8.listener ? n8.listener : n8), o8 = e9._events), s6 = o8[t8]), s6 === void 0)
    s6 = o8[t8] = n8, ++e9._eventsCount;
  else if (typeof s6 == \\"function\\" ? s6 = o8[t8] = r9 ? [n8, s6] : [s6, n8] : r9 ? s6.unshift(n8) : s6.push(n8), (i7 = f(e9)) > 0 && s6.length > i7 && !s6.warned) {
    s6.warned = true;
    var a7 = new Error(\\"Possible EventEmitter memory leak detected. \\" + s6.length + \\" \\" + String(t8) + \\" listeners added. Use emitter.setMaxListeners() to increase limit\\");
    a7.name = \\"MaxListenersExceededWarning\\", a7.emitter = e9, a7.type = t8, a7.count = s6.length, v6 = a7, console && console.warn && console.warn(v6);
  }
  return e9;
}
function a() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function l(e9, t8, n8) {
  var r9 = { fired: false, wrapFn: void 0, target: e9, type: t8, listener: n8 }, i7 = a.bind(r9);
  return i7.listener = n8, r9.wrapFn = i7, i7;
}
function h(e9, t8, n8) {
  var r9 = e9._events;
  if (r9 === void 0)
    return [];
  var i7 = r9[t8];
  return i7 === void 0 ? [] : typeof i7 == \\"function\\" ? n8 ? [i7.listener || i7] : [i7] : n8 ? function(e10) {
    for (var t9 = new Array(e10.length), n9 = 0; n9 < t9.length; ++n9)
      t9[n9] = e10[n9].listener || e10[n9];
    return t9;
  }(i7) : c(i7, i7.length);
}
function p(e9) {
  var t8 = this._events;
  if (t8 !== void 0) {
    var n8 = t8[e9];
    if (typeof n8 == \\"function\\")
      return 1;
    if (n8 !== void 0)
      return n8.length;
  }
  return 0;
}
function c(e9, t8) {
  for (var n8 = new Array(t8), r9 = 0; r9 < t8; ++r9)
    n8[r9] = e9[r9];
  return n8;
}
Object.defineProperty(o, \\"defaultMaxListeners\\", { enumerable: true, get: function() {
  return s;
}, set: function(e9) {
  if (typeof e9 != \\"number\\" || e9 < 0 || i(e9))
    throw new RangeError('The value of \\"defaultMaxListeners\\" is out of range. It must be a non-negative number. Received ' + e9 + \\".\\");
  s = e9;
} }), o.init = function() {
  this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, o.prototype.setMaxListeners = function(e9) {
  if (typeof e9 != \\"number\\" || e9 < 0 || i(e9))
    throw new RangeError('The value of \\"n\\" is out of range. It must be a non-negative number. Received ' + e9 + \\".\\");
  return this._maxListeners = e9, this;
}, o.prototype.getMaxListeners = function() {
  return f(this);
}, o.prototype.emit = function(e9) {
  for (var t8 = [], n8 = 1; n8 < arguments.length; n8++)
    t8.push(arguments[n8]);
  var i7 = e9 === \\"error\\", o8 = this._events;
  if (o8 !== void 0)
    i7 = i7 && o8.error === void 0;
  else if (!i7)
    return false;
  if (i7) {
    var s6;
    if (t8.length > 0 && (s6 = t8[0]), s6 instanceof Error)
      throw s6;
    var u7 = new Error(\\"Unhandled error.\\" + (s6 ? \\" (\\" + s6.message + \\")\\" : \\"\\"));
    throw u7.context = s6, u7;
  }
  var f7 = o8[e9];
  if (f7 === void 0)
    return false;
  if (typeof f7 == \\"function\\")
    r(f7, this, t8);
  else {
    var v6 = f7.length, a7 = c(f7, v6);
    for (n8 = 0; n8 < v6; ++n8)
      r(a7[n8], this, t8);
  }
  return true;
}, o.prototype.addListener = function(e9, t8) {
  return v(this, e9, t8, false);
}, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(e9, t8) {
  return v(this, e9, t8, true);
}, o.prototype.once = function(e9, t8) {
  return u(t8), this.on(e9, l(this, e9, t8)), this;
}, o.prototype.prependOnceListener = function(e9, t8) {
  return u(t8), this.prependListener(e9, l(this, e9, t8)), this;
}, o.prototype.removeListener = function(e9, t8) {
  var n8, r9, i7, o8, s6;
  if (u(t8), (r9 = this._events) === void 0)
    return this;
  if ((n8 = r9[e9]) === void 0)
    return this;
  if (n8 === t8 || n8.listener === t8)
    --this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete r9[e9], r9.removeListener && this.emit(\\"removeListener\\", e9, n8.listener || t8));
  else if (typeof n8 != \\"function\\") {
    for (i7 = -1, o8 = n8.length - 1; o8 >= 0; o8--)
      if (n8[o8] === t8 || n8[o8].listener === t8) {
        s6 = n8[o8].listener, i7 = o8;
        break;
      }
    if (i7 < 0)
      return this;
    i7 === 0 ? n8.shift() : !function(e10, t9) {
      for (; t9 + 1 < e10.length; t9++)
        e10[t9] = e10[t9 + 1];
      e10.pop();
    }(n8, i7), n8.length === 1 && (r9[e9] = n8[0]), r9.removeListener !== void 0 && this.emit(\\"removeListener\\", e9, s6 || t8);
  }
  return this;
}, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(e9) {
  var t8, n8, r9;
  if ((n8 = this._events) === void 0)
    return this;
  if (n8.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n8[e9] !== void 0 && (--this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n8[e9]), this;
  if (arguments.length === 0) {
    var i7, o8 = Object.keys(n8);
    for (r9 = 0; r9 < o8.length; ++r9)
      (i7 = o8[r9]) !== \\"removeListener\\" && this.removeAllListeners(i7);
    return this.removeAllListeners(\\"removeListener\\"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (typeof (t8 = n8[e9]) == \\"function\\")
    this.removeListener(e9, t8);
  else if (t8 !== void 0)
    for (r9 = t8.length - 1; r9 >= 0; r9--)
      this.removeListener(e9, t8[r9]);
  return this;
}, o.prototype.listeners = function(e9) {
  return h(this, e9, true);
}, o.prototype.rawListeners = function(e9) {
  return h(this, e9, false);
}, o.listenerCount = function(e9, t8) {
  return typeof e9.listenerCount == \\"function\\" ? e9.listenerCount(t8) : p.call(e9, t8);
}, o.prototype.listenerCount = p, o.prototype.eventNames = function() {
  return this._eventsCount > 0 ? t(this._events) : [];
};
var y = e;
y.EventEmitter;
y.defaultMaxListeners;
y.init;
y.listenerCount;
y.EventEmitter;
y.defaultMaxListeners;
y.init;
y.listenerCount;

// node_modules/.pnpm/@jspm+core@2.0.0-beta.24/node_modules/@jspm/core/nodelibs/browser/chunk-5decc758.js
var e2;
var t2;
var n2;
var r2 = typeof globalThis != \\"undefined\\" ? globalThis : typeof self != \\"undefined\\" ? self : global;
var o2 = e2 = {};
function i2() {
  throw new Error(\\"setTimeout has not been defined\\");
}
function u2() {
  throw new Error(\\"clearTimeout has not been defined\\");
}
function c2(e9) {
  if (t2 === setTimeout)
    return setTimeout(e9, 0);
  if ((t2 === i2 || !t2) && setTimeout)
    return t2 = setTimeout, setTimeout(e9, 0);
  try {
    return t2(e9, 0);
  } catch (n8) {
    try {
      return t2.call(null, e9, 0);
    } catch (n9) {
      return t2.call(this || r2, e9, 0);
    }
  }
}
!function() {
  try {
    t2 = typeof setTimeout == \\"function\\" ? setTimeout : i2;
  } catch (e9) {
    t2 = i2;
  }
  try {
    n2 = typeof clearTimeout == \\"function\\" ? clearTimeout : u2;
  } catch (e9) {
    n2 = u2;
  }
}();
var l2;
var s2 = [];
var f2 = false;
var a2 = -1;
function h2() {
  f2 && l2 && (f2 = false, l2.length ? s2 = l2.concat(s2) : a2 = -1, s2.length && d());
}
function d() {
  if (!f2) {
    var e9 = c2(h2);
    f2 = true;
    for (var t8 = s2.length; t8; ) {
      for (l2 = s2, s2 = []; ++a2 < t8; )
        l2 && l2[a2].run();
      a2 = -1, t8 = s2.length;
    }
    l2 = null, f2 = false, function(e10) {
      if (n2 === clearTimeout)
        return clearTimeout(e10);
      if ((n2 === u2 || !n2) && clearTimeout)
        return n2 = clearTimeout, clearTimeout(e10);
      try {
        n2(e10);
      } catch (t9) {
        try {
          return n2.call(null, e10);
        } catch (t10) {
          return n2.call(this || r2, e10);
        }
      }
    }(e9);
  }
}
function m(e9, t8) {
  (this || r2).fun = e9, (this || r2).array = t8;
}
function p2() {
}
o2.nextTick = function(e9) {
  var t8 = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var n8 = 1; n8 < arguments.length; n8++)
      t8[n8 - 1] = arguments[n8];
  s2.push(new m(e9, t8)), s2.length !== 1 || f2 || c2(d);
}, m.prototype.run = function() {
  (this || r2).fun.apply(null, (this || r2).array);
}, o2.title = \\"browser\\", o2.browser = true, o2.env = {}, o2.argv = [], o2.version = \\"\\", o2.versions = {}, o2.on = p2, o2.addListener = p2, o2.once = p2, o2.off = p2, o2.removeListener = p2, o2.removeAllListeners = p2, o2.emit = p2, o2.prependListener = p2, o2.prependOnceListener = p2, o2.listeners = function(e9) {
  return [];
}, o2.binding = function(e9) {
  throw new Error(\\"process.binding is not supported\\");
}, o2.cwd = function() {
  return \\"/\\";
}, o2.chdir = function(e9) {
  throw new Error(\\"process.chdir is not supported\\");
}, o2.umask = function() {
  return 0;
};
var T = e2;
T.addListener;
T.argv;
T.binding;
T.browser;
T.chdir;
T.cwd;
T.emit;
T.env;
T.listeners;
T.nextTick;
T.off;
T.on;
T.once;
T.prependListener;
T.prependOnceListener;
T.removeAllListeners;
T.removeListener;
T.title;
T.umask;
T.version;
T.versions;

// node_modules/.pnpm/@jspm+core@2.0.0-beta.24/node_modules/@jspm/core/nodelibs/browser/chunk-b4205b57.js
var t3 = typeof Symbol == \\"function\\" && typeof Symbol.toStringTag == \\"symbol\\";
var e3 = Object.prototype.toString;
var o3 = function(o8) {
  return !(t3 && o8 && typeof o8 == \\"object\\" && Symbol.toStringTag in o8) && e3.call(o8) === \\"[object Arguments]\\";
};
var n3 = function(t8) {
  return !!o3(t8) || t8 !== null && typeof t8 == \\"object\\" && typeof t8.length == \\"number\\" && t8.length >= 0 && e3.call(t8) !== \\"[object Array]\\" && e3.call(t8.callee) === \\"[object Function]\\";
};
var r3 = function() {
  return o3(arguments);
}();
o3.isLegacyArguments = n3;
var l3 = r3 ? o3 : n3;
var t$1 = Object.prototype.toString;
var o$1 = Function.prototype.toString;
var n$1 = /^\\\\s*(?:function)?\\\\*/;
var e$1 = typeof Symbol == \\"function\\" && typeof Symbol.toStringTag == \\"symbol\\";
var r$1 = Object.getPrototypeOf;
var c3 = function() {
  if (!e$1)
    return false;
  try {
    return Function(\\"return function*() {}\\")();
  } catch (t8) {
  }
}();
var u3 = c3 ? r$1(c3) : {};
var i3 = function(c7) {
  return typeof c7 == \\"function\\" && (!!n$1.test(o$1.call(c7)) || (e$1 ? r$1(c7) === u3 : t$1.call(c7) === \\"[object GeneratorFunction]\\"));
};
var t$2 = typeof Object.create == \\"function\\" ? function(t8, e9) {
  e9 && (t8.super_ = e9, t8.prototype = Object.create(e9.prototype, { constructor: { value: t8, enumerable: false, writable: true, configurable: true } }));
} : function(t8, e9) {
  if (e9) {
    t8.super_ = e9;
    var o8 = function() {
    };
    o8.prototype = e9.prototype, t8.prototype = new o8(), t8.prototype.constructor = t8;
  }
};
var i$1 = function(e9) {
  return e9 && typeof e9 == \\"object\\" && typeof e9.copy == \\"function\\" && typeof e9.fill == \\"function\\" && typeof e9.readUInt8 == \\"function\\";
};
var o$2 = {};
var u$1 = i$1;
var f3 = l3;
var a3 = i3;
function c$1(e9) {
  return e9.call.bind(e9);
}
var s3 = typeof BigInt != \\"undefined\\";
var p3 = typeof Symbol != \\"undefined\\";
var y2 = p3 && Symbol.toStringTag !== void 0;
var l$1 = typeof Uint8Array != \\"undefined\\";
var d2 = typeof ArrayBuffer != \\"undefined\\";
if (l$1 && y2)
  var g = Object.getPrototypeOf(Uint8Array.prototype), b = c$1(Object.getOwnPropertyDescriptor(g, Symbol.toStringTag).get);
var m2 = c$1(Object.prototype.toString);
var h3 = c$1(Number.prototype.valueOf);
var j = c$1(String.prototype.valueOf);
var A = c$1(Boolean.prototype.valueOf);
if (s3)
  var w = c$1(BigInt.prototype.valueOf);
if (p3)
  var v2 = c$1(Symbol.prototype.valueOf);
function O(e9, t8) {
  if (typeof e9 != \\"object\\")
    return false;
  try {
    return t8(e9), true;
  } catch (e10) {
    return false;
  }
}
function S(e9) {
  return l$1 && y2 ? b(e9) !== void 0 : B(e9) || k(e9) || E(e9) || D(e9) || U(e9) || P(e9) || x(e9) || I(e9) || M(e9) || z(e9) || F(e9);
}
function B(e9) {
  return l$1 && y2 ? b(e9) === \\"Uint8Array\\" : m2(e9) === \\"[object Uint8Array]\\" || u$1(e9) && e9.buffer !== void 0;
}
function k(e9) {
  return l$1 && y2 ? b(e9) === \\"Uint8ClampedArray\\" : m2(e9) === \\"[object Uint8ClampedArray]\\";
}
function E(e9) {
  return l$1 && y2 ? b(e9) === \\"Uint16Array\\" : m2(e9) === \\"[object Uint16Array]\\";
}
function D(e9) {
  return l$1 && y2 ? b(e9) === \\"Uint32Array\\" : m2(e9) === \\"[object Uint32Array]\\";
}
function U(e9) {
  return l$1 && y2 ? b(e9) === \\"Int8Array\\" : m2(e9) === \\"[object Int8Array]\\";
}
function P(e9) {
  return l$1 && y2 ? b(e9) === \\"Int16Array\\" : m2(e9) === \\"[object Int16Array]\\";
}
function x(e9) {
  return l$1 && y2 ? b(e9) === \\"Int32Array\\" : m2(e9) === \\"[object Int32Array]\\";
}
function I(e9) {
  return l$1 && y2 ? b(e9) === \\"Float32Array\\" : m2(e9) === \\"[object Float32Array]\\";
}
function M(e9) {
  return l$1 && y2 ? b(e9) === \\"Float64Array\\" : m2(e9) === \\"[object Float64Array]\\";
}
function z(e9) {
  return l$1 && y2 ? b(e9) === \\"BigInt64Array\\" : m2(e9) === \\"[object BigInt64Array]\\";
}
function F(e9) {
  return l$1 && y2 ? b(e9) === \\"BigUint64Array\\" : m2(e9) === \\"[object BigUint64Array]\\";
}
function T2(e9) {
  return m2(e9) === \\"[object Map]\\";
}
function N(e9) {
  return m2(e9) === \\"[object Set]\\";
}
function W(e9) {
  return m2(e9) === \\"[object WeakMap]\\";
}
function $(e9) {
  return m2(e9) === \\"[object WeakSet]\\";
}
function C(e9) {
  return m2(e9) === \\"[object ArrayBuffer]\\";
}
function V(e9) {
  return typeof ArrayBuffer != \\"undefined\\" && (C.working ? C(e9) : e9 instanceof ArrayBuffer);
}
function G(e9) {
  return m2(e9) === \\"[object DataView]\\";
}
function R(e9) {
  return typeof DataView != \\"undefined\\" && (G.working ? G(e9) : e9 instanceof DataView);
}
function J(e9) {
  return m2(e9) === \\"[object SharedArrayBuffer]\\";
}
function _(e9) {
  return typeof SharedArrayBuffer != \\"undefined\\" && (J.working ? J(e9) : e9 instanceof SharedArrayBuffer);
}
function H(e9) {
  return O(e9, h3);
}
function Z(e9) {
  return O(e9, j);
}
function q(e9) {
  return O(e9, A);
}
function K(e9) {
  return s3 && O(e9, w);
}
function L(e9) {
  return p3 && O(e9, v2);
}
o$2.isArgumentsObject = f3, o$2.isGeneratorFunction = a3, o$2.isPromise = function(e9) {
  return typeof Promise != \\"undefined\\" && e9 instanceof Promise || e9 !== null && typeof e9 == \\"object\\" && typeof e9.then == \\"function\\" && typeof e9.catch == \\"function\\";
}, o$2.isArrayBufferView = function(e9) {
  return d2 && ArrayBuffer.isView ? ArrayBuffer.isView(e9) : S(e9) || R(e9);
}, o$2.isTypedArray = S, o$2.isUint8Array = B, o$2.isUint8ClampedArray = k, o$2.isUint16Array = E, o$2.isUint32Array = D, o$2.isInt8Array = U, o$2.isInt16Array = P, o$2.isInt32Array = x, o$2.isFloat32Array = I, o$2.isFloat64Array = M, o$2.isBigInt64Array = z, o$2.isBigUint64Array = F, T2.working = typeof Map != \\"undefined\\" && T2(/* @__PURE__ */ new Map()), o$2.isMap = function(e9) {
  return typeof Map != \\"undefined\\" && (T2.working ? T2(e9) : e9 instanceof Map);
}, N.working = typeof Set != \\"undefined\\" && N(/* @__PURE__ */ new Set()), o$2.isSet = function(e9) {
  return typeof Set != \\"undefined\\" && (N.working ? N(e9) : e9 instanceof Set);
}, W.working = typeof WeakMap != \\"undefined\\" && W(/* @__PURE__ */ new WeakMap()), o$2.isWeakMap = function(e9) {
  return typeof WeakMap != \\"undefined\\" && (W.working ? W(e9) : e9 instanceof WeakMap);
}, $.working = typeof WeakSet != \\"undefined\\" && $(/* @__PURE__ */ new WeakSet()), o$2.isWeakSet = function(e9) {
  return $(e9);
}, C.working = typeof ArrayBuffer != \\"undefined\\" && C(new ArrayBuffer()), o$2.isArrayBuffer = V, G.working = typeof ArrayBuffer != \\"undefined\\" && typeof DataView != \\"undefined\\" && G(new DataView(new ArrayBuffer(1), 0, 1)), o$2.isDataView = R, J.working = typeof SharedArrayBuffer != \\"undefined\\" && J(new SharedArrayBuffer()), o$2.isSharedArrayBuffer = _, o$2.isAsyncFunction = function(e9) {
  return m2(e9) === \\"[object AsyncFunction]\\";
}, o$2.isMapIterator = function(e9) {
  return m2(e9) === \\"[object Map Iterator]\\";
}, o$2.isSetIterator = function(e9) {
  return m2(e9) === \\"[object Set Iterator]\\";
}, o$2.isGeneratorObject = function(e9) {
  return m2(e9) === \\"[object Generator]\\";
}, o$2.isWebAssemblyCompiledModule = function(e9) {
  return m2(e9) === \\"[object WebAssembly.Module]\\";
}, o$2.isNumberObject = H, o$2.isStringObject = Z, o$2.isBooleanObject = q, o$2.isBigIntObject = K, o$2.isSymbolObject = L, o$2.isBoxedPrimitive = function(e9) {
  return H(e9) || Z(e9) || q(e9) || K(e9) || L(e9);
}, o$2.isAnyArrayBuffer = function(e9) {
  return l$1 && (V(e9) || _(e9));
}, [\\"isProxy\\", \\"isExternal\\", \\"isModuleNamespaceObject\\"].forEach(function(e9) {
  Object.defineProperty(o$2, e9, { enumerable: false, value: function() {
    throw new Error(e9 + \\" is not supported in userland\\");
  } });
});
var Q = typeof globalThis != \\"undefined\\" ? globalThis : typeof self != \\"undefined\\" ? self : global;
var X = {};
var Y = T;
var ee = Object.getOwnPropertyDescriptors || function(e9) {
  for (var t8 = Object.keys(e9), r9 = {}, n8 = 0; n8 < t8.length; n8++)
    r9[t8[n8]] = Object.getOwnPropertyDescriptor(e9, t8[n8]);
  return r9;
};
var te = /%[sdj%]/g;
X.format = function(e9) {
  if (!ge(e9)) {
    for (var t8 = [], r9 = 0; r9 < arguments.length; r9++)
      t8.push(oe(arguments[r9]));
    return t8.join(\\" \\");
  }
  r9 = 1;
  for (var n8 = arguments, i7 = n8.length, o8 = String(e9).replace(te, function(e10) {
    if (e10 === \\"%%\\")
      return \\"%\\";
    if (r9 >= i7)
      return e10;
    switch (e10) {
      case \\"%s\\":
        return String(n8[r9++]);
      case \\"%d\\":
        return Number(n8[r9++]);
      case \\"%j\\":
        try {
          return JSON.stringify(n8[r9++]);
        } catch (e11) {
          return \\"[Circular]\\";
        }
      default:
        return e10;
    }
  }), u7 = n8[r9]; r9 < i7; u7 = n8[++r9])
    le(u7) || !he(u7) ? o8 += \\" \\" + u7 : o8 += \\" \\" + oe(u7);
  return o8;
}, X.deprecate = function(e9, t8) {
  if (Y !== void 0 && Y.noDeprecation === true)
    return e9;
  if (Y === void 0)
    return function() {
      return X.deprecate(e9, t8).apply(this || Q, arguments);
    };
  var r9 = false;
  return function() {
    if (!r9) {
      if (Y.throwDeprecation)
        throw new Error(t8);
      Y.traceDeprecation ? console.trace(t8) : console.error(t8), r9 = true;
    }
    return e9.apply(this || Q, arguments);
  };
};
var re = {};
var ne = /^$/;
if (Y.env.NODE_DEBUG) {
  ie = Y.env.NODE_DEBUG;
  ie = ie.replace(/[|\\\\\\\\{}()[\\\\]^$+?.]/g, \\"\\\\\\\\$&\\").replace(/\\\\*/g, \\".*\\").replace(/,/g, \\"$|^\\").toUpperCase(), ne = new RegExp(\\"^\\" + ie + \\"$\\", \\"i\\");
}
var ie;
function oe(e9, t8) {
  var r9 = { seen: [], stylize: fe };
  return arguments.length >= 3 && (r9.depth = arguments[2]), arguments.length >= 4 && (r9.colors = arguments[3]), ye(t8) ? r9.showHidden = t8 : t8 && X._extend(r9, t8), be(r9.showHidden) && (r9.showHidden = false), be(r9.depth) && (r9.depth = 2), be(r9.colors) && (r9.colors = false), be(r9.customInspect) && (r9.customInspect = true), r9.colors && (r9.stylize = ue), ae(r9, e9, r9.depth);
}
function ue(e9, t8) {
  var r9 = oe.styles[t8];
  return r9 ? \\"\\\\x1B[\\" + oe.colors[r9][0] + \\"m\\" + e9 + \\"\\\\x1B[\\" + oe.colors[r9][1] + \\"m\\" : e9;
}
function fe(e9, t8) {
  return e9;
}
function ae(e9, t8, r9) {
  if (e9.customInspect && t8 && we(t8.inspect) && t8.inspect !== X.inspect && (!t8.constructor || t8.constructor.prototype !== t8)) {
    var n8 = t8.inspect(r9, e9);
    return ge(n8) || (n8 = ae(e9, n8, r9)), n8;
  }
  var i7 = function(e10, t9) {
    if (be(t9))
      return e10.stylize(\\"undefined\\", \\"undefined\\");
    if (ge(t9)) {
      var r10 = \\"'\\" + JSON.stringify(t9).replace(/^\\"|\\"$/g, \\"\\").replace(/'/g, \\"\\\\\\\\'\\").replace(/\\\\\\\\\\"/g, '\\"') + \\"'\\";
      return e10.stylize(r10, \\"string\\");
    }
    if (de(t9))
      return e10.stylize(\\"\\" + t9, \\"number\\");
    if (ye(t9))
      return e10.stylize(\\"\\" + t9, \\"boolean\\");
    if (le(t9))
      return e10.stylize(\\"null\\", \\"null\\");
  }(e9, t8);
  if (i7)
    return i7;
  var o8 = Object.keys(t8), u7 = function(e10) {
    var t9 = {};
    return e10.forEach(function(e11, r10) {
      t9[e11] = true;
    }), t9;
  }(o8);
  if (e9.showHidden && (o8 = Object.getOwnPropertyNames(t8)), Ae(t8) && (o8.indexOf(\\"message\\") >= 0 || o8.indexOf(\\"description\\") >= 0))
    return ce(t8);
  if (o8.length === 0) {
    if (we(t8)) {
      var f7 = t8.name ? \\": \\" + t8.name : \\"\\";
      return e9.stylize(\\"[Function\\" + f7 + \\"]\\", \\"special\\");
    }
    if (me(t8))
      return e9.stylize(RegExp.prototype.toString.call(t8), \\"regexp\\");
    if (je(t8))
      return e9.stylize(Date.prototype.toString.call(t8), \\"date\\");
    if (Ae(t8))
      return ce(t8);
  }
  var a7, c7 = \\"\\", s6 = false, p7 = [\\"{\\", \\"}\\"];
  (pe(t8) && (s6 = true, p7 = [\\"[\\", \\"]\\"]), we(t8)) && (c7 = \\" [Function\\" + (t8.name ? \\": \\" + t8.name : \\"\\") + \\"]\\");
  return me(t8) && (c7 = \\" \\" + RegExp.prototype.toString.call(t8)), je(t8) && (c7 = \\" \\" + Date.prototype.toUTCString.call(t8)), Ae(t8) && (c7 = \\" \\" + ce(t8)), o8.length !== 0 || s6 && t8.length != 0 ? r9 < 0 ? me(t8) ? e9.stylize(RegExp.prototype.toString.call(t8), \\"regexp\\") : e9.stylize(\\"[Object]\\", \\"special\\") : (e9.seen.push(t8), a7 = s6 ? function(e10, t9, r10, n9, i8) {
    for (var o9 = [], u8 = 0, f8 = t9.length; u8 < f8; ++u8)
      ke(t9, String(u8)) ? o9.push(se(e10, t9, r10, n9, String(u8), true)) : o9.push(\\"\\");
    return i8.forEach(function(i9) {
      i9.match(/^\\\\d+$/) || o9.push(se(e10, t9, r10, n9, i9, true));
    }), o9;
  }(e9, t8, r9, u7, o8) : o8.map(function(n9) {
    return se(e9, t8, r9, u7, n9, s6);
  }), e9.seen.pop(), function(e10, t9, r10) {
    var n9 = 0;
    if (e10.reduce(function(e11, t10) {
      return n9++, t10.indexOf(\\"\\\\n\\") >= 0 && n9++, e11 + t10.replace(/\\\\u001b\\\\[\\\\d\\\\d?m/g, \\"\\").length + 1;
    }, 0) > 60)
      return r10[0] + (t9 === \\"\\" ? \\"\\" : t9 + \\"\\\\n \\") + \\" \\" + e10.join(\\",\\\\n  \\") + \\" \\" + r10[1];
    return r10[0] + t9 + \\" \\" + e10.join(\\", \\") + \\" \\" + r10[1];
  }(a7, c7, p7)) : p7[0] + c7 + p7[1];
}
function ce(e9) {
  return \\"[\\" + Error.prototype.toString.call(e9) + \\"]\\";
}
function se(e9, t8, r9, n8, i7, o8) {
  var u7, f7, a7;
  if ((a7 = Object.getOwnPropertyDescriptor(t8, i7) || { value: t8[i7] }).get ? f7 = a7.set ? e9.stylize(\\"[Getter/Setter]\\", \\"special\\") : e9.stylize(\\"[Getter]\\", \\"special\\") : a7.set && (f7 = e9.stylize(\\"[Setter]\\", \\"special\\")), ke(n8, i7) || (u7 = \\"[\\" + i7 + \\"]\\"), f7 || (e9.seen.indexOf(a7.value) < 0 ? (f7 = le(r9) ? ae(e9, a7.value, null) : ae(e9, a7.value, r9 - 1)).indexOf(\\"\\\\n\\") > -1 && (f7 = o8 ? f7.split(\\"\\\\n\\").map(function(e10) {
    return \\"  \\" + e10;
  }).join(\\"\\\\n\\").substr(2) : \\"\\\\n\\" + f7.split(\\"\\\\n\\").map(function(e10) {
    return \\"   \\" + e10;
  }).join(\\"\\\\n\\")) : f7 = e9.stylize(\\"[Circular]\\", \\"special\\")), be(u7)) {
    if (o8 && i7.match(/^\\\\d+$/))
      return f7;
    (u7 = JSON.stringify(\\"\\" + i7)).match(/^\\"([a-zA-Z_][a-zA-Z_0-9]*)\\"$/) ? (u7 = u7.substr(1, u7.length - 2), u7 = e9.stylize(u7, \\"name\\")) : (u7 = u7.replace(/'/g, \\"\\\\\\\\'\\").replace(/\\\\\\\\\\"/g, '\\"').replace(/(^\\"|\\"$)/g, \\"'\\"), u7 = e9.stylize(u7, \\"string\\"));
  }
  return u7 + \\": \\" + f7;
}
function pe(e9) {
  return Array.isArray(e9);
}
function ye(e9) {
  return typeof e9 == \\"boolean\\";
}
function le(e9) {
  return e9 === null;
}
function de(e9) {
  return typeof e9 == \\"number\\";
}
function ge(e9) {
  return typeof e9 == \\"string\\";
}
function be(e9) {
  return e9 === void 0;
}
function me(e9) {
  return he(e9) && ve(e9) === \\"[object RegExp]\\";
}
function he(e9) {
  return typeof e9 == \\"object\\" && e9 !== null;
}
function je(e9) {
  return he(e9) && ve(e9) === \\"[object Date]\\";
}
function Ae(e9) {
  return he(e9) && (ve(e9) === \\"[object Error]\\" || e9 instanceof Error);
}
function we(e9) {
  return typeof e9 == \\"function\\";
}
function ve(e9) {
  return Object.prototype.toString.call(e9);
}
function Oe(e9) {
  return e9 < 10 ? \\"0\\" + e9.toString(10) : e9.toString(10);
}
X.debuglog = function(e9) {
  if (e9 = e9.toUpperCase(), !re[e9])
    if (ne.test(e9)) {
      var t8 = Y.pid;
      re[e9] = function() {
        var r9 = X.format.apply(X, arguments);
        console.error(\\"%s %d: %s\\", e9, t8, r9);
      };
    } else
      re[e9] = function() {
      };
  return re[e9];
}, X.inspect = oe, oe.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, oe.styles = { special: \\"cyan\\", number: \\"yellow\\", boolean: \\"yellow\\", undefined: \\"grey\\", null: \\"bold\\", string: \\"green\\", date: \\"magenta\\", regexp: \\"red\\" }, X.types = o$2, X.isArray = pe, X.isBoolean = ye, X.isNull = le, X.isNullOrUndefined = function(e9) {
  return e9 == null;
}, X.isNumber = de, X.isString = ge, X.isSymbol = function(e9) {
  return typeof e9 == \\"symbol\\";
}, X.isUndefined = be, X.isRegExp = me, X.types.isRegExp = me, X.isObject = he, X.isDate = je, X.types.isDate = je, X.isError = Ae, X.types.isNativeError = Ae, X.isFunction = we, X.isPrimitive = function(e9) {
  return e9 === null || typeof e9 == \\"boolean\\" || typeof e9 == \\"number\\" || typeof e9 == \\"string\\" || typeof e9 == \\"symbol\\" || e9 === void 0;
}, X.isBuffer = i$1;
var Se = [\\"Jan\\", \\"Feb\\", \\"Mar\\", \\"Apr\\", \\"May\\", \\"Jun\\", \\"Jul\\", \\"Aug\\", \\"Sep\\", \\"Oct\\", \\"Nov\\", \\"Dec\\"];
function Be() {
  var e9 = new Date(), t8 = [Oe(e9.getHours()), Oe(e9.getMinutes()), Oe(e9.getSeconds())].join(\\":\\");
  return [e9.getDate(), Se[e9.getMonth()], t8].join(\\" \\");
}
function ke(e9, t8) {
  return Object.prototype.hasOwnProperty.call(e9, t8);
}
X.log = function() {
  console.log(\\"%s - %s\\", Be(), X.format.apply(X, arguments));
}, X.inherits = t$2, X._extend = function(e9, t8) {
  if (!t8 || !he(t8))
    return e9;
  for (var r9 = Object.keys(t8), n8 = r9.length; n8--; )
    e9[r9[n8]] = t8[r9[n8]];
  return e9;
};
var Ee = typeof Symbol != \\"undefined\\" ? Symbol(\\"util.promisify.custom\\") : void 0;
function De(e9, t8) {
  if (!e9) {
    var r9 = new Error(\\"Promise was rejected with a falsy value\\");
    r9.reason = e9, e9 = r9;
  }
  return t8(e9);
}
X.promisify = function(e9) {
  if (typeof e9 != \\"function\\")
    throw new TypeError('The \\"original\\" argument must be of type Function');
  if (Ee && e9[Ee]) {
    var t8;
    if (typeof (t8 = e9[Ee]) != \\"function\\")
      throw new TypeError('The \\"util.promisify.custom\\" argument must be of type Function');
    return Object.defineProperty(t8, Ee, { value: t8, enumerable: false, writable: false, configurable: true }), t8;
  }
  function t8() {
    for (var t9, r9, n8 = new Promise(function(e10, n9) {
      t9 = e10, r9 = n9;
    }), i7 = [], o8 = 0; o8 < arguments.length; o8++)
      i7.push(arguments[o8]);
    i7.push(function(e10, n9) {
      e10 ? r9(e10) : t9(n9);
    });
    try {
      e9.apply(this || Q, i7);
    } catch (e10) {
      r9(e10);
    }
    return n8;
  }
  return Object.setPrototypeOf(t8, Object.getPrototypeOf(e9)), Ee && Object.defineProperty(t8, Ee, { value: t8, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t8, ee(e9));
}, X.promisify.custom = Ee, X.callbackify = function(e9) {
  if (typeof e9 != \\"function\\")
    throw new TypeError('The \\"original\\" argument must be of type Function');
  function t8() {
    for (var t9 = [], r9 = 0; r9 < arguments.length; r9++)
      t9.push(arguments[r9]);
    var n8 = t9.pop();
    if (typeof n8 != \\"function\\")
      throw new TypeError(\\"The last argument must be of type Function\\");
    var i7 = this || Q, o8 = function() {
      return n8.apply(i7, arguments);
    };
    e9.apply(this || Q, t9).then(function(e10) {
      Y.nextTick(o8.bind(null, null, e10));
    }, function(e10) {
      Y.nextTick(De.bind(null, e10, o8));
    });
  }
  return Object.setPrototypeOf(t8, Object.getPrototypeOf(e9)), Object.defineProperties(t8, ee(e9)), t8;
};

// node_modules/.pnpm/@jspm+core@2.0.0-beta.24/node_modules/@jspm/core/nodelibs/browser/chunk-ce0fbc82.js
X._extend;
X.callbackify;
X.debuglog;
X.deprecate;
X.format;
X.inherits;
X.inspect;
X.isArray;
X.isBoolean;
X.isBuffer;
X.isDate;
X.isError;
X.isFunction;
X.isNull;
X.isNullOrUndefined;
X.isNumber;
X.isObject;
X.isPrimitive;
X.isRegExp;
X.isString;
X.isSymbol;
X.isUndefined;
X.log;
X.promisify;
var _extend = X._extend;
var callbackify = X.callbackify;
var debuglog = X.debuglog;
var deprecate = X.deprecate;
var format = X.format;
var inherits = X.inherits;
var inspect = X.inspect;
var isArray = X.isArray;
var isBoolean = X.isBoolean;
var isBuffer = X.isBuffer;
var isDate = X.isDate;
var isError = X.isError;
var isFunction = X.isFunction;
var isNull = X.isNull;
var isNullOrUndefined = X.isNullOrUndefined;
var isNumber = X.isNumber;
var isObject = X.isObject;
var isPrimitive = X.isPrimitive;
var isRegExp = X.isRegExp;
var isString = X.isString;
var isSymbol = X.isSymbol;
var isUndefined = X.isUndefined;
var log = X.log;
var promisify = X.promisify;
var types = X.types;
var TextEncoder = self.TextEncoder;
var TextDecoder2 = self.TextDecoder;

// node_modules/.pnpm/@jspm+core@2.0.0-beta.24/node_modules/@jspm/core/nodelibs/browser/chunk-2eac56ff.js
var exports = {};
var _dewExec = false;
var _global = typeof globalThis !== \\"undefined\\" ? globalThis : typeof self !== \\"undefined\\" ? self : global;
function dew() {
  if (_dewExec)
    return exports;
  _dewExec = true;
  var process2 = exports = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  function defaultSetTimout() {
    throw new Error(\\"setTimeout has not been defined\\");
  }
  function defaultClearTimeout() {
    throw new Error(\\"clearTimeout has not been defined\\");
  }
  (function() {
    try {
      if (typeof setTimeout === \\"function\\") {
        cachedSetTimeout = setTimeout;
      } else {
        cachedSetTimeout = defaultSetTimout;
      }
    } catch (e9) {
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      if (typeof clearTimeout === \\"function\\") {
        cachedClearTimeout = clearTimeout;
      } else {
        cachedClearTimeout = defaultClearTimeout;
      }
    } catch (e9) {
      cachedClearTimeout = defaultClearTimeout;
    }
  })();
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e9) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e10) {
        return cachedSetTimeout.call(this || _global, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e9) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e10) {
        return cachedClearTimeout.call(this || _global, marker);
      }
    }
  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  process2.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i7 = 1; i7 < arguments.length; i7++) {
        args[i7 - 1] = arguments[i7];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  };
  function Item(fun, array) {
    (this || _global).fun = fun;
    (this || _global).array = array;
  }
  Item.prototype.run = function() {
    (this || _global).fun.apply(null, (this || _global).array);
  };
  process2.title = \\"browser\\";
  process2.browser = true;
  process2.env = {};
  process2.argv = [];
  process2.version = \\"\\";
  process2.versions = {};
  function noop() {
  }
  process2.on = noop;
  process2.addListener = noop;
  process2.once = noop;
  process2.off = noop;
  process2.removeListener = noop;
  process2.removeAllListeners = noop;
  process2.emit = noop;
  process2.prependListener = noop;
  process2.prependOnceListener = noop;
  process2.listeners = function(name2) {
    return [];
  };
  process2.binding = function(name2) {
    throw new Error(\\"process.binding is not supported\\");
  };
  process2.cwd = function() {
    return \\"/\\";
  };
  process2.chdir = function(dir) {
    throw new Error(\\"process.chdir is not supported\\");
  };
  process2.umask = function() {
    return 0;
  };
  return exports;
}
var process = dew();
process.platform = \\"browser\\";
process.addListener;
process.argv;
process.binding;
process.browser;
process.chdir;
process.cwd;
process.emit;
process.env;
process.listeners;
process.nextTick;
process.off;
process.on;
process.once;
process.prependListener;
process.prependOnceListener;
process.removeAllListeners;
process.removeListener;
process.title;
process.umask;
process.version;
process.versions;

// node_modules/.pnpm/@jspm+core@2.0.0-beta.24/node_modules/@jspm/core/nodelibs/browser/chunk-4ccc3a29.js
for (r$13 = { byteLength: function(r9) {
  var t8 = u$2(r9), e9 = t8[0], n8 = t8[1];
  return 3 * (e9 + n8) / 4 - n8;
}, toByteArray: function(r9) {
  var t8, o8, a7 = u$2(r9), h8 = a7[0], c7 = a7[1], d6 = new n$22(function(r10, t9, e9) {
    return 3 * (t9 + e9) / 4 - e9;
  }(0, h8, c7)), f7 = 0, A4 = c7 > 0 ? h8 - 4 : h8;
  for (o8 = 0; o8 < A4; o8 += 4)
    t8 = e$22[r9.charCodeAt(o8)] << 18 | e$22[r9.charCodeAt(o8 + 1)] << 12 | e$22[r9.charCodeAt(o8 + 2)] << 6 | e$22[r9.charCodeAt(o8 + 3)], d6[f7++] = t8 >> 16 & 255, d6[f7++] = t8 >> 8 & 255, d6[f7++] = 255 & t8;
  c7 === 2 && (t8 = e$22[r9.charCodeAt(o8)] << 2 | e$22[r9.charCodeAt(o8 + 1)] >> 4, d6[f7++] = 255 & t8);
  c7 === 1 && (t8 = e$22[r9.charCodeAt(o8)] << 10 | e$22[r9.charCodeAt(o8 + 1)] << 4 | e$22[r9.charCodeAt(o8 + 2)] >> 2, d6[f7++] = t8 >> 8 & 255, d6[f7++] = 255 & t8);
  return d6;
}, fromByteArray: function(r9) {
  for (var e9, n8 = r9.length, o8 = n8 % 3, a7 = [], h8 = 0, u7 = n8 - o8; h8 < u7; h8 += 16383)
    a7.push(c$12(r9, h8, h8 + 16383 > u7 ? u7 : h8 + 16383));
  o8 === 1 ? (e9 = r9[n8 - 1], a7.push(t$13[e9 >> 2] + t$13[e9 << 4 & 63] + \\"==\\")) : o8 === 2 && (e9 = (r9[n8 - 2] << 8) + r9[n8 - 1], a7.push(t$13[e9 >> 10] + t$13[e9 >> 4 & 63] + t$13[e9 << 2 & 63] + \\"=\\"));
  return a7.join(\\"\\");
} }, t$13 = [], e$22 = [], n$22 = typeof Uint8Array != \\"undefined\\" ? Uint8Array : Array, o$23 = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\", a$12 = 0, h$12 = o$23.length; a$12 < h$12; ++a$12)
  t$13[a$12] = o$23[a$12], e$22[o$23.charCodeAt(a$12)] = a$12;
var r$13;
var t$13;
var e$22;
var n$22;
var o$23;
var a$12;
var h$12;
function u$2(r9) {
  var t8 = r9.length;
  if (t8 % 4 > 0)
    throw new Error(\\"Invalid string. Length must be a multiple of 4\\");
  var e9 = r9.indexOf(\\"=\\");
  return e9 === -1 && (e9 = t8), [e9, e9 === t8 ? 0 : 4 - e9 % 4];
}
function c$12(r9, e9, n8) {
  for (var o8, a7, h8 = [], u7 = e9; u7 < n8; u7 += 3)
    o8 = (r9[u7] << 16 & 16711680) + (r9[u7 + 1] << 8 & 65280) + (255 & r9[u7 + 2]), h8.push(t$13[(a7 = o8) >> 18 & 63] + t$13[a7 >> 12 & 63] + t$13[a7 >> 6 & 63] + t$13[63 & a7]);
  return h8.join(\\"\\");
}
e$22[\\"-\\".charCodeAt(0)] = 62, e$22[\\"_\\".charCodeAt(0)] = 63;
var a$1$1 = { read: function(a7, t8, o8, r9, h8) {
  var M4, f7, p7 = 8 * h8 - r9 - 1, w4 = (1 << p7) - 1, e9 = w4 >> 1, i7 = -7, N4 = o8 ? h8 - 1 : 0, n8 = o8 ? -1 : 1, u7 = a7[t8 + N4];
  for (N4 += n8, M4 = u7 & (1 << -i7) - 1, u7 >>= -i7, i7 += p7; i7 > 0; M4 = 256 * M4 + a7[t8 + N4], N4 += n8, i7 -= 8)
    ;
  for (f7 = M4 & (1 << -i7) - 1, M4 >>= -i7, i7 += r9; i7 > 0; f7 = 256 * f7 + a7[t8 + N4], N4 += n8, i7 -= 8)
    ;
  if (M4 === 0)
    M4 = 1 - e9;
  else {
    if (M4 === w4)
      return f7 ? NaN : 1 / 0 * (u7 ? -1 : 1);
    f7 += Math.pow(2, r9), M4 -= e9;
  }
  return (u7 ? -1 : 1) * f7 * Math.pow(2, M4 - r9);
}, write: function(a7, t8, o8, r9, h8, M4) {
  var f7, p7, w4, e9 = 8 * M4 - h8 - 1, i7 = (1 << e9) - 1, N4 = i7 >> 1, n8 = h8 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, u7 = r9 ? 0 : M4 - 1, l7 = r9 ? 1 : -1, s6 = t8 < 0 || t8 === 0 && 1 / t8 < 0 ? 1 : 0;
  for (t8 = Math.abs(t8), isNaN(t8) || t8 === 1 / 0 ? (p7 = isNaN(t8) ? 1 : 0, f7 = i7) : (f7 = Math.floor(Math.log(t8) / Math.LN2), t8 * (w4 = Math.pow(2, -f7)) < 1 && (f7--, w4 *= 2), (t8 += f7 + N4 >= 1 ? n8 / w4 : n8 * Math.pow(2, 1 - N4)) * w4 >= 2 && (f7++, w4 /= 2), f7 + N4 >= i7 ? (p7 = 0, f7 = i7) : f7 + N4 >= 1 ? (p7 = (t8 * w4 - 1) * Math.pow(2, h8), f7 += N4) : (p7 = t8 * Math.pow(2, N4 - 1) * Math.pow(2, h8), f7 = 0)); h8 >= 8; a7[o8 + u7] = 255 & p7, u7 += l7, p7 /= 256, h8 -= 8)
    ;
  for (f7 = f7 << h8 | p7, e9 += h8; e9 > 0; a7[o8 + u7] = 255 & f7, u7 += l7, f7 /= 256, e9 -= 8)
    ;
  a7[o8 + u7 - l7] |= 128 * s6;
} };
var e$1$1 = {};
var n$1$1 = r$13;
var i$12 = a$1$1;
var o$1$1 = typeof Symbol == \\"function\\" && typeof Symbol.for == \\"function\\" ? Symbol.for(\\"nodejs.util.inspect.custom\\") : null;
e$1$1.Buffer = u$1$1, e$1$1.SlowBuffer = function(t8) {
  +t8 != t8 && (t8 = 0);
  return u$1$1.alloc(+t8);
}, e$1$1.INSPECT_MAX_BYTES = 50;
function f$2(t8) {
  if (t8 > 2147483647)
    throw new RangeError('The value \\"' + t8 + '\\" is invalid for option \\"size\\"');
  var r9 = new Uint8Array(t8);
  return Object.setPrototypeOf(r9, u$1$1.prototype), r9;
}
function u$1$1(t8, r9, e9) {
  if (typeof t8 == \\"number\\") {
    if (typeof r9 == \\"string\\")
      throw new TypeError('The \\"string\\" argument must be of type string. Received type number');
    return a$2(t8);
  }
  return s$1(t8, r9, e9);
}
function s$1(t8, r9, e9) {
  if (typeof t8 == \\"string\\")
    return function(t9, r10) {
      typeof r10 == \\"string\\" && r10 !== \\"\\" || (r10 = \\"utf8\\");
      if (!u$1$1.isEncoding(r10))
        throw new TypeError(\\"Unknown encoding: \\" + r10);
      var e10 = 0 | y3(t9, r10), n9 = f$2(e10), i8 = n9.write(t9, r10);
      i8 !== e10 && (n9 = n9.slice(0, i8));
      return n9;
    }(t8, r9);
  if (ArrayBuffer.isView(t8))
    return p4(t8);
  if (t8 == null)
    throw new TypeError(\\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \\" + typeof t8);
  if (F2(t8, ArrayBuffer) || t8 && F2(t8.buffer, ArrayBuffer))
    return c$1$1(t8, r9, e9);
  if (typeof SharedArrayBuffer != \\"undefined\\" && (F2(t8, SharedArrayBuffer) || t8 && F2(t8.buffer, SharedArrayBuffer)))
    return c$1$1(t8, r9, e9);
  if (typeof t8 == \\"number\\")
    throw new TypeError('The \\"value\\" argument must not be of type number. Received type number');
  var n8 = t8.valueOf && t8.valueOf();
  if (n8 != null && n8 !== t8)
    return u$1$1.from(n8, r9, e9);
  var i7 = function(t9) {
    if (u$1$1.isBuffer(t9)) {
      var r10 = 0 | l$12(t9.length), e10 = f$2(r10);
      return e10.length === 0 || t9.copy(e10, 0, 0, r10), e10;
    }
    if (t9.length !== void 0)
      return typeof t9.length != \\"number\\" || N2(t9.length) ? f$2(0) : p4(t9);
    if (t9.type === \\"Buffer\\" && Array.isArray(t9.data))
      return p4(t9.data);
  }(t8);
  if (i7)
    return i7;
  if (typeof Symbol != \\"undefined\\" && Symbol.toPrimitive != null && typeof t8[Symbol.toPrimitive] == \\"function\\")
    return u$1$1.from(t8[Symbol.toPrimitive](\\"string\\"), r9, e9);
  throw new TypeError(\\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \\" + typeof t8);
}
function h$1$1(t8) {
  if (typeof t8 != \\"number\\")
    throw new TypeError('\\"size\\" argument must be of type number');
  if (t8 < 0)
    throw new RangeError('The value \\"' + t8 + '\\" is invalid for option \\"size\\"');
}
function a$2(t8) {
  return h$1$1(t8), f$2(t8 < 0 ? 0 : 0 | l$12(t8));
}
function p4(t8) {
  for (var r9 = t8.length < 0 ? 0 : 0 | l$12(t8.length), e9 = f$2(r9), n8 = 0; n8 < r9; n8 += 1)
    e9[n8] = 255 & t8[n8];
  return e9;
}
function c$1$1(t8, r9, e9) {
  if (r9 < 0 || t8.byteLength < r9)
    throw new RangeError('\\"offset\\" is outside of buffer bounds');
  if (t8.byteLength < r9 + (e9 || 0))
    throw new RangeError('\\"length\\" is outside of buffer bounds');
  var n8;
  return n8 = r9 === void 0 && e9 === void 0 ? new Uint8Array(t8) : e9 === void 0 ? new Uint8Array(t8, r9) : new Uint8Array(t8, r9, e9), Object.setPrototypeOf(n8, u$1$1.prototype), n8;
}
function l$12(t8) {
  if (t8 >= 2147483647)
    throw new RangeError(\\"Attempt to allocate Buffer larger than maximum size: 0x\\" + 2147483647 .toString(16) + \\" bytes\\");
  return 0 | t8;
}
function y3(t8, r9) {
  if (u$1$1.isBuffer(t8))
    return t8.length;
  if (ArrayBuffer.isView(t8) || F2(t8, ArrayBuffer))
    return t8.byteLength;
  if (typeof t8 != \\"string\\")
    throw new TypeError('The \\"string\\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t8);
  var e9 = t8.length, n8 = arguments.length > 2 && arguments[2] === true;
  if (!n8 && e9 === 0)
    return 0;
  for (var i7 = false; ; )
    switch (r9) {
      case \\"ascii\\":
      case \\"latin1\\":
      case \\"binary\\":
        return e9;
      case \\"utf8\\":
      case \\"utf-8\\":
        return _2(t8).length;
      case \\"ucs2\\":
      case \\"ucs-2\\":
      case \\"utf16le\\":
      case \\"utf-16le\\":
        return 2 * e9;
      case \\"hex\\":
        return e9 >>> 1;
      case \\"base64\\":
        return z2(t8).length;
      default:
        if (i7)
          return n8 ? -1 : _2(t8).length;
        r9 = (\\"\\" + r9).toLowerCase(), i7 = true;
    }
}
function g2(t8, r9, e9) {
  var n8 = false;
  if ((r9 === void 0 || r9 < 0) && (r9 = 0), r9 > this.length)
    return \\"\\";
  if ((e9 === void 0 || e9 > this.length) && (e9 = this.length), e9 <= 0)
    return \\"\\";
  if ((e9 >>>= 0) <= (r9 >>>= 0))
    return \\"\\";
  for (t8 || (t8 = \\"utf8\\"); ; )
    switch (t8) {
      case \\"hex\\":
        return O2(this, r9, e9);
      case \\"utf8\\":
      case \\"utf-8\\":
        return I2(this, r9, e9);
      case \\"ascii\\":
        return S2(this, r9, e9);
      case \\"latin1\\":
      case \\"binary\\":
        return R2(this, r9, e9);
      case \\"base64\\":
        return T3(this, r9, e9);
      case \\"ucs2\\":
      case \\"ucs-2\\":
      case \\"utf16le\\":
      case \\"utf-16le\\":
        return L2(this, r9, e9);
      default:
        if (n8)
          throw new TypeError(\\"Unknown encoding: \\" + t8);
        t8 = (t8 + \\"\\").toLowerCase(), n8 = true;
    }
}
function w2(t8, r9, e9) {
  var n8 = t8[r9];
  t8[r9] = t8[e9], t8[e9] = n8;
}
function d3(t8, r9, e9, n8, i7) {
  if (t8.length === 0)
    return -1;
  if (typeof e9 == \\"string\\" ? (n8 = e9, e9 = 0) : e9 > 2147483647 ? e9 = 2147483647 : e9 < -2147483648 && (e9 = -2147483648), N2(e9 = +e9) && (e9 = i7 ? 0 : t8.length - 1), e9 < 0 && (e9 = t8.length + e9), e9 >= t8.length) {
    if (i7)
      return -1;
    e9 = t8.length - 1;
  } else if (e9 < 0) {
    if (!i7)
      return -1;
    e9 = 0;
  }
  if (typeof r9 == \\"string\\" && (r9 = u$1$1.from(r9, n8)), u$1$1.isBuffer(r9))
    return r9.length === 0 ? -1 : v3(t8, r9, e9, n8, i7);
  if (typeof r9 == \\"number\\")
    return r9 &= 255, typeof Uint8Array.prototype.indexOf == \\"function\\" ? i7 ? Uint8Array.prototype.indexOf.call(t8, r9, e9) : Uint8Array.prototype.lastIndexOf.call(t8, r9, e9) : v3(t8, [r9], e9, n8, i7);
  throw new TypeError(\\"val must be string, number or Buffer\\");
}
function v3(t8, r9, e9, n8, i7) {
  var o8, f7 = 1, u7 = t8.length, s6 = r9.length;
  if (n8 !== void 0 && ((n8 = String(n8).toLowerCase()) === \\"ucs2\\" || n8 === \\"ucs-2\\" || n8 === \\"utf16le\\" || n8 === \\"utf-16le\\")) {
    if (t8.length < 2 || r9.length < 2)
      return -1;
    f7 = 2, u7 /= 2, s6 /= 2, e9 /= 2;
  }
  function h8(t9, r10) {
    return f7 === 1 ? t9[r10] : t9.readUInt16BE(r10 * f7);
  }
  if (i7) {
    var a7 = -1;
    for (o8 = e9; o8 < u7; o8++)
      if (h8(t8, o8) === h8(r9, a7 === -1 ? 0 : o8 - a7)) {
        if (a7 === -1 && (a7 = o8), o8 - a7 + 1 === s6)
          return a7 * f7;
      } else
        a7 !== -1 && (o8 -= o8 - a7), a7 = -1;
  } else
    for (e9 + s6 > u7 && (e9 = u7 - s6), o8 = e9; o8 >= 0; o8--) {
      for (var p7 = true, c7 = 0; c7 < s6; c7++)
        if (h8(t8, o8 + c7) !== h8(r9, c7)) {
          p7 = false;
          break;
        }
      if (p7)
        return o8;
    }
  return -1;
}
function b2(t8, r9, e9, n8) {
  e9 = Number(e9) || 0;
  var i7 = t8.length - e9;
  n8 ? (n8 = Number(n8)) > i7 && (n8 = i7) : n8 = i7;
  var o8 = r9.length;
  n8 > o8 / 2 && (n8 = o8 / 2);
  for (var f7 = 0; f7 < n8; ++f7) {
    var u7 = parseInt(r9.substr(2 * f7, 2), 16);
    if (N2(u7))
      return f7;
    t8[e9 + f7] = u7;
  }
  return f7;
}
function m3(t8, r9, e9, n8) {
  return D2(_2(r9, t8.length - e9), t8, e9, n8);
}
function E2(t8, r9, e9, n8) {
  return D2(function(t9) {
    for (var r10 = [], e10 = 0; e10 < t9.length; ++e10)
      r10.push(255 & t9.charCodeAt(e10));
    return r10;
  }(r9), t8, e9, n8);
}
function B2(t8, r9, e9, n8) {
  return E2(t8, r9, e9, n8);
}
function A2(t8, r9, e9, n8) {
  return D2(z2(r9), t8, e9, n8);
}
function U2(t8, r9, e9, n8) {
  return D2(function(t9, r10) {
    for (var e10, n9, i7, o8 = [], f7 = 0; f7 < t9.length && !((r10 -= 2) < 0); ++f7)
      e10 = t9.charCodeAt(f7), n9 = e10 >> 8, i7 = e10 % 256, o8.push(i7), o8.push(n9);
    return o8;
  }(r9, t8.length - e9), t8, e9, n8);
}
function T3(t8, r9, e9) {
  return r9 === 0 && e9 === t8.length ? n$1$1.fromByteArray(t8) : n$1$1.fromByteArray(t8.slice(r9, e9));
}
function I2(t8, r9, e9) {
  e9 = Math.min(t8.length, e9);
  for (var n8 = [], i7 = r9; i7 < e9; ) {
    var o8, f7, u7, s6, h8 = t8[i7], a7 = null, p7 = h8 > 239 ? 4 : h8 > 223 ? 3 : h8 > 191 ? 2 : 1;
    if (i7 + p7 <= e9)
      switch (p7) {
        case 1:
          h8 < 128 && (a7 = h8);
          break;
        case 2:
          (192 & (o8 = t8[i7 + 1])) == 128 && (s6 = (31 & h8) << 6 | 63 & o8) > 127 && (a7 = s6);
          break;
        case 3:
          o8 = t8[i7 + 1], f7 = t8[i7 + 2], (192 & o8) == 128 && (192 & f7) == 128 && (s6 = (15 & h8) << 12 | (63 & o8) << 6 | 63 & f7) > 2047 && (s6 < 55296 || s6 > 57343) && (a7 = s6);
          break;
        case 4:
          o8 = t8[i7 + 1], f7 = t8[i7 + 2], u7 = t8[i7 + 3], (192 & o8) == 128 && (192 & f7) == 128 && (192 & u7) == 128 && (s6 = (15 & h8) << 18 | (63 & o8) << 12 | (63 & f7) << 6 | 63 & u7) > 65535 && s6 < 1114112 && (a7 = s6);
      }
    a7 === null ? (a7 = 65533, p7 = 1) : a7 > 65535 && (a7 -= 65536, n8.push(a7 >>> 10 & 1023 | 55296), a7 = 56320 | 1023 & a7), n8.push(a7), i7 += p7;
  }
  return function(t9) {
    var r10 = t9.length;
    if (r10 <= 4096)
      return String.fromCharCode.apply(String, t9);
    var e10 = \\"\\", n9 = 0;
    for (; n9 < r10; )
      e10 += String.fromCharCode.apply(String, t9.slice(n9, n9 += 4096));
    return e10;
  }(n8);
}
e$1$1.kMaxLength = 2147483647, u$1$1.TYPED_ARRAY_SUPPORT = function() {
  try {
    var t8 = new Uint8Array(1), r9 = { foo: function() {
      return 42;
    } };
    return Object.setPrototypeOf(r9, Uint8Array.prototype), Object.setPrototypeOf(t8, r9), t8.foo() === 42;
  } catch (t9) {
    return false;
  }
}(), u$1$1.TYPED_ARRAY_SUPPORT || typeof console == \\"undefined\\" || typeof console.error != \\"function\\" || console.error(\\"This browser lacks typed array (Uint8Array) support which is required by \`buffer\` v5.x. Use \`buffer\` v4.x if you require old browser support.\\"), Object.defineProperty(u$1$1.prototype, \\"parent\\", { enumerable: true, get: function() {
  if (u$1$1.isBuffer(this))
    return this.buffer;
} }), Object.defineProperty(u$1$1.prototype, \\"offset\\", { enumerable: true, get: function() {
  if (u$1$1.isBuffer(this))
    return this.byteOffset;
} }), u$1$1.poolSize = 8192, u$1$1.from = function(t8, r9, e9) {
  return s$1(t8, r9, e9);
}, Object.setPrototypeOf(u$1$1.prototype, Uint8Array.prototype), Object.setPrototypeOf(u$1$1, Uint8Array), u$1$1.alloc = function(t8, r9, e9) {
  return function(t9, r10, e10) {
    return h$1$1(t9), t9 <= 0 ? f$2(t9) : r10 !== void 0 ? typeof e10 == \\"string\\" ? f$2(t9).fill(r10, e10) : f$2(t9).fill(r10) : f$2(t9);
  }(t8, r9, e9);
}, u$1$1.allocUnsafe = function(t8) {
  return a$2(t8);
}, u$1$1.allocUnsafeSlow = function(t8) {
  return a$2(t8);
}, u$1$1.isBuffer = function(t8) {
  return t8 != null && t8._isBuffer === true && t8 !== u$1$1.prototype;
}, u$1$1.compare = function(t8, r9) {
  if (F2(t8, Uint8Array) && (t8 = u$1$1.from(t8, t8.offset, t8.byteLength)), F2(r9, Uint8Array) && (r9 = u$1$1.from(r9, r9.offset, r9.byteLength)), !u$1$1.isBuffer(t8) || !u$1$1.isBuffer(r9))
    throw new TypeError('The \\"buf1\\", \\"buf2\\" arguments must be one of type Buffer or Uint8Array');
  if (t8 === r9)
    return 0;
  for (var e9 = t8.length, n8 = r9.length, i7 = 0, o8 = Math.min(e9, n8); i7 < o8; ++i7)
    if (t8[i7] !== r9[i7]) {
      e9 = t8[i7], n8 = r9[i7];
      break;
    }
  return e9 < n8 ? -1 : n8 < e9 ? 1 : 0;
}, u$1$1.isEncoding = function(t8) {
  switch (String(t8).toLowerCase()) {
    case \\"hex\\":
    case \\"utf8\\":
    case \\"utf-8\\":
    case \\"ascii\\":
    case \\"latin1\\":
    case \\"binary\\":
    case \\"base64\\":
    case \\"ucs2\\":
    case \\"ucs-2\\":
    case \\"utf16le\\":
    case \\"utf-16le\\":
      return true;
    default:
      return false;
  }
}, u$1$1.concat = function(t8, r9) {
  if (!Array.isArray(t8))
    throw new TypeError('\\"list\\" argument must be an Array of Buffers');
  if (t8.length === 0)
    return u$1$1.alloc(0);
  var e9;
  if (r9 === void 0)
    for (r9 = 0, e9 = 0; e9 < t8.length; ++e9)
      r9 += t8[e9].length;
  var n8 = u$1$1.allocUnsafe(r9), i7 = 0;
  for (e9 = 0; e9 < t8.length; ++e9) {
    var o8 = t8[e9];
    if (F2(o8, Uint8Array) && (o8 = u$1$1.from(o8)), !u$1$1.isBuffer(o8))
      throw new TypeError('\\"list\\" argument must be an Array of Buffers');
    o8.copy(n8, i7), i7 += o8.length;
  }
  return n8;
}, u$1$1.byteLength = y3, u$1$1.prototype._isBuffer = true, u$1$1.prototype.swap16 = function() {
  var t8 = this.length;
  if (t8 % 2 != 0)
    throw new RangeError(\\"Buffer size must be a multiple of 16-bits\\");
  for (var r9 = 0; r9 < t8; r9 += 2)
    w2(this, r9, r9 + 1);
  return this;
}, u$1$1.prototype.swap32 = function() {
  var t8 = this.length;
  if (t8 % 4 != 0)
    throw new RangeError(\\"Buffer size must be a multiple of 32-bits\\");
  for (var r9 = 0; r9 < t8; r9 += 4)
    w2(this, r9, r9 + 3), w2(this, r9 + 1, r9 + 2);
  return this;
}, u$1$1.prototype.swap64 = function() {
  var t8 = this.length;
  if (t8 % 8 != 0)
    throw new RangeError(\\"Buffer size must be a multiple of 64-bits\\");
  for (var r9 = 0; r9 < t8; r9 += 8)
    w2(this, r9, r9 + 7), w2(this, r9 + 1, r9 + 6), w2(this, r9 + 2, r9 + 5), w2(this, r9 + 3, r9 + 4);
  return this;
}, u$1$1.prototype.toString = function() {
  var t8 = this.length;
  return t8 === 0 ? \\"\\" : arguments.length === 0 ? I2(this, 0, t8) : g2.apply(this, arguments);
}, u$1$1.prototype.toLocaleString = u$1$1.prototype.toString, u$1$1.prototype.equals = function(t8) {
  if (!u$1$1.isBuffer(t8))
    throw new TypeError(\\"Argument must be a Buffer\\");
  return this === t8 || u$1$1.compare(this, t8) === 0;
}, u$1$1.prototype.inspect = function() {
  var t8 = \\"\\", r9 = e$1$1.INSPECT_MAX_BYTES;
  return t8 = this.toString(\\"hex\\", 0, r9).replace(/(.{2})/g, \\"$1 \\").trim(), this.length > r9 && (t8 += \\" ... \\"), \\"<Buffer \\" + t8 + \\">\\";
}, o$1$1 && (u$1$1.prototype[o$1$1] = u$1$1.prototype.inspect), u$1$1.prototype.compare = function(t8, r9, e9, n8, i7) {
  if (F2(t8, Uint8Array) && (t8 = u$1$1.from(t8, t8.offset, t8.byteLength)), !u$1$1.isBuffer(t8))
    throw new TypeError('The \\"target\\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t8);
  if (r9 === void 0 && (r9 = 0), e9 === void 0 && (e9 = t8 ? t8.length : 0), n8 === void 0 && (n8 = 0), i7 === void 0 && (i7 = this.length), r9 < 0 || e9 > t8.length || n8 < 0 || i7 > this.length)
    throw new RangeError(\\"out of range index\\");
  if (n8 >= i7 && r9 >= e9)
    return 0;
  if (n8 >= i7)
    return -1;
  if (r9 >= e9)
    return 1;
  if (this === t8)
    return 0;
  for (var o8 = (i7 >>>= 0) - (n8 >>>= 0), f7 = (e9 >>>= 0) - (r9 >>>= 0), s6 = Math.min(o8, f7), h8 = this.slice(n8, i7), a7 = t8.slice(r9, e9), p7 = 0; p7 < s6; ++p7)
    if (h8[p7] !== a7[p7]) {
      o8 = h8[p7], f7 = a7[p7];
      break;
    }
  return o8 < f7 ? -1 : f7 < o8 ? 1 : 0;
}, u$1$1.prototype.includes = function(t8, r9, e9) {
  return this.indexOf(t8, r9, e9) !== -1;
}, u$1$1.prototype.indexOf = function(t8, r9, e9) {
  return d3(this, t8, r9, e9, true);
}, u$1$1.prototype.lastIndexOf = function(t8, r9, e9) {
  return d3(this, t8, r9, e9, false);
}, u$1$1.prototype.write = function(t8, r9, e9, n8) {
  if (r9 === void 0)
    n8 = \\"utf8\\", e9 = this.length, r9 = 0;
  else if (e9 === void 0 && typeof r9 == \\"string\\")
    n8 = r9, e9 = this.length, r9 = 0;
  else {
    if (!isFinite(r9))
      throw new Error(\\"Buffer.write(string, encoding, offset[, length]) is no longer supported\\");
    r9 >>>= 0, isFinite(e9) ? (e9 >>>= 0, n8 === void 0 && (n8 = \\"utf8\\")) : (n8 = e9, e9 = void 0);
  }
  var i7 = this.length - r9;
  if ((e9 === void 0 || e9 > i7) && (e9 = i7), t8.length > 0 && (e9 < 0 || r9 < 0) || r9 > this.length)
    throw new RangeError(\\"Attempt to write outside buffer bounds\\");
  n8 || (n8 = \\"utf8\\");
  for (var o8 = false; ; )
    switch (n8) {
      case \\"hex\\":
        return b2(this, t8, r9, e9);
      case \\"utf8\\":
      case \\"utf-8\\":
        return m3(this, t8, r9, e9);
      case \\"ascii\\":
        return E2(this, t8, r9, e9);
      case \\"latin1\\":
      case \\"binary\\":
        return B2(this, t8, r9, e9);
      case \\"base64\\":
        return A2(this, t8, r9, e9);
      case \\"ucs2\\":
      case \\"ucs-2\\":
      case \\"utf16le\\":
      case \\"utf-16le\\":
        return U2(this, t8, r9, e9);
      default:
        if (o8)
          throw new TypeError(\\"Unknown encoding: \\" + n8);
        n8 = (\\"\\" + n8).toLowerCase(), o8 = true;
    }
}, u$1$1.prototype.toJSON = function() {
  return { type: \\"Buffer\\", data: Array.prototype.slice.call(this._arr || this, 0) };
};
function S2(t8, r9, e9) {
  var n8 = \\"\\";
  e9 = Math.min(t8.length, e9);
  for (var i7 = r9; i7 < e9; ++i7)
    n8 += String.fromCharCode(127 & t8[i7]);
  return n8;
}
function R2(t8, r9, e9) {
  var n8 = \\"\\";
  e9 = Math.min(t8.length, e9);
  for (var i7 = r9; i7 < e9; ++i7)
    n8 += String.fromCharCode(t8[i7]);
  return n8;
}
function O2(t8, r9, e9) {
  var n8 = t8.length;
  (!r9 || r9 < 0) && (r9 = 0), (!e9 || e9 < 0 || e9 > n8) && (e9 = n8);
  for (var i7 = \\"\\", o8 = r9; o8 < e9; ++o8)
    i7 += Y2[t8[o8]];
  return i7;
}
function L2(t8, r9, e9) {
  for (var n8 = t8.slice(r9, e9), i7 = \\"\\", o8 = 0; o8 < n8.length; o8 += 2)
    i7 += String.fromCharCode(n8[o8] + 256 * n8[o8 + 1]);
  return i7;
}
function x2(t8, r9, e9) {
  if (t8 % 1 != 0 || t8 < 0)
    throw new RangeError(\\"offset is not uint\\");
  if (t8 + r9 > e9)
    throw new RangeError(\\"Trying to access beyond buffer length\\");
}
function C2(t8, r9, e9, n8, i7, o8) {
  if (!u$1$1.isBuffer(t8))
    throw new TypeError('\\"buffer\\" argument must be a Buffer instance');
  if (r9 > i7 || r9 < o8)
    throw new RangeError('\\"value\\" argument is out of bounds');
  if (e9 + n8 > t8.length)
    throw new RangeError(\\"Index out of range\\");
}
function P2(t8, r9, e9, n8, i7, o8) {
  if (e9 + n8 > t8.length)
    throw new RangeError(\\"Index out of range\\");
  if (e9 < 0)
    throw new RangeError(\\"Index out of range\\");
}
function k2(t8, r9, e9, n8, o8) {
  return r9 = +r9, e9 >>>= 0, o8 || P2(t8, 0, e9, 4), i$12.write(t8, r9, e9, n8, 23, 4), e9 + 4;
}
function M2(t8, r9, e9, n8, o8) {
  return r9 = +r9, e9 >>>= 0, o8 || P2(t8, 0, e9, 8), i$12.write(t8, r9, e9, n8, 52, 8), e9 + 8;
}
u$1$1.prototype.slice = function(t8, r9) {
  var e9 = this.length;
  (t8 = ~~t8) < 0 ? (t8 += e9) < 0 && (t8 = 0) : t8 > e9 && (t8 = e9), (r9 = r9 === void 0 ? e9 : ~~r9) < 0 ? (r9 += e9) < 0 && (r9 = 0) : r9 > e9 && (r9 = e9), r9 < t8 && (r9 = t8);
  var n8 = this.subarray(t8, r9);
  return Object.setPrototypeOf(n8, u$1$1.prototype), n8;
}, u$1$1.prototype.readUIntLE = function(t8, r9, e9) {
  t8 >>>= 0, r9 >>>= 0, e9 || x2(t8, r9, this.length);
  for (var n8 = this[t8], i7 = 1, o8 = 0; ++o8 < r9 && (i7 *= 256); )
    n8 += this[t8 + o8] * i7;
  return n8;
}, u$1$1.prototype.readUIntBE = function(t8, r9, e9) {
  t8 >>>= 0, r9 >>>= 0, e9 || x2(t8, r9, this.length);
  for (var n8 = this[t8 + --r9], i7 = 1; r9 > 0 && (i7 *= 256); )
    n8 += this[t8 + --r9] * i7;
  return n8;
}, u$1$1.prototype.readUInt8 = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 1, this.length), this[t8];
}, u$1$1.prototype.readUInt16LE = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 2, this.length), this[t8] | this[t8 + 1] << 8;
}, u$1$1.prototype.readUInt16BE = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 2, this.length), this[t8] << 8 | this[t8 + 1];
}, u$1$1.prototype.readUInt32LE = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 4, this.length), (this[t8] | this[t8 + 1] << 8 | this[t8 + 2] << 16) + 16777216 * this[t8 + 3];
}, u$1$1.prototype.readUInt32BE = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 4, this.length), 16777216 * this[t8] + (this[t8 + 1] << 16 | this[t8 + 2] << 8 | this[t8 + 3]);
}, u$1$1.prototype.readIntLE = function(t8, r9, e9) {
  t8 >>>= 0, r9 >>>= 0, e9 || x2(t8, r9, this.length);
  for (var n8 = this[t8], i7 = 1, o8 = 0; ++o8 < r9 && (i7 *= 256); )
    n8 += this[t8 + o8] * i7;
  return n8 >= (i7 *= 128) && (n8 -= Math.pow(2, 8 * r9)), n8;
}, u$1$1.prototype.readIntBE = function(t8, r9, e9) {
  t8 >>>= 0, r9 >>>= 0, e9 || x2(t8, r9, this.length);
  for (var n8 = r9, i7 = 1, o8 = this[t8 + --n8]; n8 > 0 && (i7 *= 256); )
    o8 += this[t8 + --n8] * i7;
  return o8 >= (i7 *= 128) && (o8 -= Math.pow(2, 8 * r9)), o8;
}, u$1$1.prototype.readInt8 = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 1, this.length), 128 & this[t8] ? -1 * (255 - this[t8] + 1) : this[t8];
}, u$1$1.prototype.readInt16LE = function(t8, r9) {
  t8 >>>= 0, r9 || x2(t8, 2, this.length);
  var e9 = this[t8] | this[t8 + 1] << 8;
  return 32768 & e9 ? 4294901760 | e9 : e9;
}, u$1$1.prototype.readInt16BE = function(t8, r9) {
  t8 >>>= 0, r9 || x2(t8, 2, this.length);
  var e9 = this[t8 + 1] | this[t8] << 8;
  return 32768 & e9 ? 4294901760 | e9 : e9;
}, u$1$1.prototype.readInt32LE = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 4, this.length), this[t8] | this[t8 + 1] << 8 | this[t8 + 2] << 16 | this[t8 + 3] << 24;
}, u$1$1.prototype.readInt32BE = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 4, this.length), this[t8] << 24 | this[t8 + 1] << 16 | this[t8 + 2] << 8 | this[t8 + 3];
}, u$1$1.prototype.readFloatLE = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 4, this.length), i$12.read(this, t8, true, 23, 4);
}, u$1$1.prototype.readFloatBE = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 4, this.length), i$12.read(this, t8, false, 23, 4);
}, u$1$1.prototype.readDoubleLE = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 8, this.length), i$12.read(this, t8, true, 52, 8);
}, u$1$1.prototype.readDoubleBE = function(t8, r9) {
  return t8 >>>= 0, r9 || x2(t8, 8, this.length), i$12.read(this, t8, false, 52, 8);
}, u$1$1.prototype.writeUIntLE = function(t8, r9, e9, n8) {
  (t8 = +t8, r9 >>>= 0, e9 >>>= 0, n8) || C2(this, t8, r9, e9, Math.pow(2, 8 * e9) - 1, 0);
  var i7 = 1, o8 = 0;
  for (this[r9] = 255 & t8; ++o8 < e9 && (i7 *= 256); )
    this[r9 + o8] = t8 / i7 & 255;
  return r9 + e9;
}, u$1$1.prototype.writeUIntBE = function(t8, r9, e9, n8) {
  (t8 = +t8, r9 >>>= 0, e9 >>>= 0, n8) || C2(this, t8, r9, e9, Math.pow(2, 8 * e9) - 1, 0);
  var i7 = e9 - 1, o8 = 1;
  for (this[r9 + i7] = 255 & t8; --i7 >= 0 && (o8 *= 256); )
    this[r9 + i7] = t8 / o8 & 255;
  return r9 + e9;
}, u$1$1.prototype.writeUInt8 = function(t8, r9, e9) {
  return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 1, 255, 0), this[r9] = 255 & t8, r9 + 1;
}, u$1$1.prototype.writeUInt16LE = function(t8, r9, e9) {
  return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 2, 65535, 0), this[r9] = 255 & t8, this[r9 + 1] = t8 >>> 8, r9 + 2;
}, u$1$1.prototype.writeUInt16BE = function(t8, r9, e9) {
  return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 2, 65535, 0), this[r9] = t8 >>> 8, this[r9 + 1] = 255 & t8, r9 + 2;
}, u$1$1.prototype.writeUInt32LE = function(t8, r9, e9) {
  return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 4, 4294967295, 0), this[r9 + 3] = t8 >>> 24, this[r9 + 2] = t8 >>> 16, this[r9 + 1] = t8 >>> 8, this[r9] = 255 & t8, r9 + 4;
}, u$1$1.prototype.writeUInt32BE = function(t8, r9, e9) {
  return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 4, 4294967295, 0), this[r9] = t8 >>> 24, this[r9 + 1] = t8 >>> 16, this[r9 + 2] = t8 >>> 8, this[r9 + 3] = 255 & t8, r9 + 4;
}, u$1$1.prototype.writeIntLE = function(t8, r9, e9, n8) {
  if (t8 = +t8, r9 >>>= 0, !n8) {
    var i7 = Math.pow(2, 8 * e9 - 1);
    C2(this, t8, r9, e9, i7 - 1, -i7);
  }
  var o8 = 0, f7 = 1, u7 = 0;
  for (this[r9] = 255 & t8; ++o8 < e9 && (f7 *= 256); )
    t8 < 0 && u7 === 0 && this[r9 + o8 - 1] !== 0 && (u7 = 1), this[r9 + o8] = (t8 / f7 >> 0) - u7 & 255;
  return r9 + e9;
}, u$1$1.prototype.writeIntBE = function(t8, r9, e9, n8) {
  if (t8 = +t8, r9 >>>= 0, !n8) {
    var i7 = Math.pow(2, 8 * e9 - 1);
    C2(this, t8, r9, e9, i7 - 1, -i7);
  }
  var o8 = e9 - 1, f7 = 1, u7 = 0;
  for (this[r9 + o8] = 255 & t8; --o8 >= 0 && (f7 *= 256); )
    t8 < 0 && u7 === 0 && this[r9 + o8 + 1] !== 0 && (u7 = 1), this[r9 + o8] = (t8 / f7 >> 0) - u7 & 255;
  return r9 + e9;
}, u$1$1.prototype.writeInt8 = function(t8, r9, e9) {
  return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 1, 127, -128), t8 < 0 && (t8 = 255 + t8 + 1), this[r9] = 255 & t8, r9 + 1;
}, u$1$1.prototype.writeInt16LE = function(t8, r9, e9) {
  return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 2, 32767, -32768), this[r9] = 255 & t8, this[r9 + 1] = t8 >>> 8, r9 + 2;
}, u$1$1.prototype.writeInt16BE = function(t8, r9, e9) {
  return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 2, 32767, -32768), this[r9] = t8 >>> 8, this[r9 + 1] = 255 & t8, r9 + 2;
}, u$1$1.prototype.writeInt32LE = function(t8, r9, e9) {
  return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 4, 2147483647, -2147483648), this[r9] = 255 & t8, this[r9 + 1] = t8 >>> 8, this[r9 + 2] = t8 >>> 16, this[r9 + 3] = t8 >>> 24, r9 + 4;
}, u$1$1.prototype.writeInt32BE = function(t8, r9, e9) {
  return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 4, 2147483647, -2147483648), t8 < 0 && (t8 = 4294967295 + t8 + 1), this[r9] = t8 >>> 24, this[r9 + 1] = t8 >>> 16, this[r9 + 2] = t8 >>> 8, this[r9 + 3] = 255 & t8, r9 + 4;
}, u$1$1.prototype.writeFloatLE = function(t8, r9, e9) {
  return k2(this, t8, r9, true, e9);
}, u$1$1.prototype.writeFloatBE = function(t8, r9, e9) {
  return k2(this, t8, r9, false, e9);
}, u$1$1.prototype.writeDoubleLE = function(t8, r9, e9) {
  return M2(this, t8, r9, true, e9);
}, u$1$1.prototype.writeDoubleBE = function(t8, r9, e9) {
  return M2(this, t8, r9, false, e9);
}, u$1$1.prototype.copy = function(t8, r9, e9, n8) {
  if (!u$1$1.isBuffer(t8))
    throw new TypeError(\\"argument should be a Buffer\\");
  if (e9 || (e9 = 0), n8 || n8 === 0 || (n8 = this.length), r9 >= t8.length && (r9 = t8.length), r9 || (r9 = 0), n8 > 0 && n8 < e9 && (n8 = e9), n8 === e9)
    return 0;
  if (t8.length === 0 || this.length === 0)
    return 0;
  if (r9 < 0)
    throw new RangeError(\\"targetStart out of bounds\\");
  if (e9 < 0 || e9 >= this.length)
    throw new RangeError(\\"Index out of range\\");
  if (n8 < 0)
    throw new RangeError(\\"sourceEnd out of bounds\\");
  n8 > this.length && (n8 = this.length), t8.length - r9 < n8 - e9 && (n8 = t8.length - r9 + e9);
  var i7 = n8 - e9;
  if (this === t8 && typeof Uint8Array.prototype.copyWithin == \\"function\\")
    this.copyWithin(r9, e9, n8);
  else if (this === t8 && e9 < r9 && r9 < n8)
    for (var o8 = i7 - 1; o8 >= 0; --o8)
      t8[o8 + r9] = this[o8 + e9];
  else
    Uint8Array.prototype.set.call(t8, this.subarray(e9, n8), r9);
  return i7;
}, u$1$1.prototype.fill = function(t8, r9, e9, n8) {
  if (typeof t8 == \\"string\\") {
    if (typeof r9 == \\"string\\" ? (n8 = r9, r9 = 0, e9 = this.length) : typeof e9 == \\"string\\" && (n8 = e9, e9 = this.length), n8 !== void 0 && typeof n8 != \\"string\\")
      throw new TypeError(\\"encoding must be a string\\");
    if (typeof n8 == \\"string\\" && !u$1$1.isEncoding(n8))
      throw new TypeError(\\"Unknown encoding: \\" + n8);
    if (t8.length === 1) {
      var i7 = t8.charCodeAt(0);
      (n8 === \\"utf8\\" && i7 < 128 || n8 === \\"latin1\\") && (t8 = i7);
    }
  } else
    typeof t8 == \\"number\\" ? t8 &= 255 : typeof t8 == \\"boolean\\" && (t8 = Number(t8));
  if (r9 < 0 || this.length < r9 || this.length < e9)
    throw new RangeError(\\"Out of range index\\");
  if (e9 <= r9)
    return this;
  var o8;
  if (r9 >>>= 0, e9 = e9 === void 0 ? this.length : e9 >>> 0, t8 || (t8 = 0), typeof t8 == \\"number\\")
    for (o8 = r9; o8 < e9; ++o8)
      this[o8] = t8;
  else {
    var f7 = u$1$1.isBuffer(t8) ? t8 : u$1$1.from(t8, n8), s6 = f7.length;
    if (s6 === 0)
      throw new TypeError('The value \\"' + t8 + '\\" is invalid for argument \\"value\\"');
    for (o8 = 0; o8 < e9 - r9; ++o8)
      this[o8 + r9] = f7[o8 % s6];
  }
  return this;
};
var j2 = /[^+/0-9A-Za-z-_]/g;
function _2(t8, r9) {
  var e9;
  r9 = r9 || 1 / 0;
  for (var n8 = t8.length, i7 = null, o8 = [], f7 = 0; f7 < n8; ++f7) {
    if ((e9 = t8.charCodeAt(f7)) > 55295 && e9 < 57344) {
      if (!i7) {
        if (e9 > 56319) {
          (r9 -= 3) > -1 && o8.push(239, 191, 189);
          continue;
        }
        if (f7 + 1 === n8) {
          (r9 -= 3) > -1 && o8.push(239, 191, 189);
          continue;
        }
        i7 = e9;
        continue;
      }
      if (e9 < 56320) {
        (r9 -= 3) > -1 && o8.push(239, 191, 189), i7 = e9;
        continue;
      }
      e9 = 65536 + (i7 - 55296 << 10 | e9 - 56320);
    } else
      i7 && (r9 -= 3) > -1 && o8.push(239, 191, 189);
    if (i7 = null, e9 < 128) {
      if ((r9 -= 1) < 0)
        break;
      o8.push(e9);
    } else if (e9 < 2048) {
      if ((r9 -= 2) < 0)
        break;
      o8.push(e9 >> 6 | 192, 63 & e9 | 128);
    } else if (e9 < 65536) {
      if ((r9 -= 3) < 0)
        break;
      o8.push(e9 >> 12 | 224, e9 >> 6 & 63 | 128, 63 & e9 | 128);
    } else {
      if (!(e9 < 1114112))
        throw new Error(\\"Invalid code point\\");
      if ((r9 -= 4) < 0)
        break;
      o8.push(e9 >> 18 | 240, e9 >> 12 & 63 | 128, e9 >> 6 & 63 | 128, 63 & e9 | 128);
    }
  }
  return o8;
}
function z2(t8) {
  return n$1$1.toByteArray(function(t9) {
    if ((t9 = (t9 = t9.split(\\"=\\")[0]).trim().replace(j2, \\"\\")).length < 2)
      return \\"\\";
    for (; t9.length % 4 != 0; )
      t9 += \\"=\\";
    return t9;
  }(t8));
}
function D2(t8, r9, e9, n8) {
  for (var i7 = 0; i7 < n8 && !(i7 + e9 >= r9.length || i7 >= t8.length); ++i7)
    r9[i7 + e9] = t8[i7];
  return i7;
}
function F2(t8, r9) {
  return t8 instanceof r9 || t8 != null && t8.constructor != null && t8.constructor.name != null && t8.constructor.name === r9.name;
}
function N2(t8) {
  return t8 != t8;
}
var Y2 = function() {
  for (var t8 = new Array(256), r9 = 0; r9 < 16; ++r9)
    for (var e9 = 16 * r9, n8 = 0; n8 < 16; ++n8)
      t8[e9 + n8] = \\"0123456789abcdef\\"[r9] + \\"0123456789abcdef\\"[n8];
  return t8;
}();
e$1$1.Buffer;
e$1$1.INSPECT_MAX_BYTES;
e$1$1.kMaxLength;
var e4 = {};
var n4 = e$1$1;
var o4 = n4.Buffer;
function t4(r9, e9) {
  for (var n8 in r9)
    e9[n8] = r9[n8];
}
function f4(r9, e9, n8) {
  return o4(r9, e9, n8);
}
o4.from && o4.alloc && o4.allocUnsafe && o4.allocUnsafeSlow ? e4 = n4 : (t4(n4, e4), e4.Buffer = f4), f4.prototype = Object.create(o4.prototype), t4(o4, f4), f4.from = function(r9, e9, n8) {
  if (typeof r9 == \\"number\\")
    throw new TypeError(\\"Argument must not be a number\\");
  return o4(r9, e9, n8);
}, f4.alloc = function(r9, e9, n8) {
  if (typeof r9 != \\"number\\")
    throw new TypeError(\\"Argument must be a number\\");
  var t8 = o4(r9);
  return e9 !== void 0 ? typeof n8 == \\"string\\" ? t8.fill(e9, n8) : t8.fill(e9) : t8.fill(0), t8;
}, f4.allocUnsafe = function(r9) {
  if (typeof r9 != \\"number\\")
    throw new TypeError(\\"Argument must be a number\\");
  return o4(r9);
}, f4.allocUnsafeSlow = function(r9) {
  if (typeof r9 != \\"number\\")
    throw new TypeError(\\"Argument must be a number\\");
  return n4.SlowBuffer(r9);
};
var u4 = e4;
var e$12 = {};
var s4 = u4.Buffer;
var i4 = s4.isEncoding || function(t8) {
  switch ((t8 = \\"\\" + t8) && t8.toLowerCase()) {
    case \\"hex\\":
    case \\"utf8\\":
    case \\"utf-8\\":
    case \\"ascii\\":
    case \\"binary\\":
    case \\"base64\\":
    case \\"ucs2\\":
    case \\"ucs-2\\":
    case \\"utf16le\\":
    case \\"utf-16le\\":
    case \\"raw\\":
      return true;
    default:
      return false;
  }
};
function a4(t8) {
  var e9;
  switch (this.encoding = function(t9) {
    var e10 = function(t10) {
      if (!t10)
        return \\"utf8\\";
      for (var e11; ; )
        switch (t10) {
          case \\"utf8\\":
          case \\"utf-8\\":
            return \\"utf8\\";
          case \\"ucs2\\":
          case \\"ucs-2\\":
          case \\"utf16le\\":
          case \\"utf-16le\\":
            return \\"utf16le\\";
          case \\"latin1\\":
          case \\"binary\\":
            return \\"latin1\\";
          case \\"base64\\":
          case \\"ascii\\":
          case \\"hex\\":
            return t10;
          default:
            if (e11)
              return;
            t10 = (\\"\\" + t10).toLowerCase(), e11 = true;
        }
    }(t9);
    if (typeof e10 != \\"string\\" && (s4.isEncoding === i4 || !i4(t9)))
      throw new Error(\\"Unknown encoding: \\" + t9);
    return e10 || t9;
  }(t8), this.encoding) {
    case \\"utf16le\\":
      this.text = h4, this.end = l4, e9 = 4;
      break;
    case \\"utf8\\":
      this.fillLast = n$12, e9 = 4;
      break;
    case \\"base64\\":
      this.text = u$12, this.end = o$12, e9 = 3;
      break;
    default:
      return this.write = f$1, this.end = c4, void 0;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = s4.allocUnsafe(e9);
}
function r4(t8) {
  return t8 <= 127 ? 0 : t8 >> 5 == 6 ? 2 : t8 >> 4 == 14 ? 3 : t8 >> 3 == 30 ? 4 : t8 >> 6 == 2 ? -1 : -2;
}
function n$12(t8) {
  var e9 = this.lastTotal - this.lastNeed, s6 = function(t9, e10, s7) {
    if ((192 & e10[0]) != 128)
      return t9.lastNeed = 0, \\"\\\\uFFFD\\";
    if (t9.lastNeed > 1 && e10.length > 1) {
      if ((192 & e10[1]) != 128)
        return t9.lastNeed = 1, \\"\\\\uFFFD\\";
      if (t9.lastNeed > 2 && e10.length > 2 && (192 & e10[2]) != 128)
        return t9.lastNeed = 2, \\"\\\\uFFFD\\";
    }
  }(this, t8);
  return s6 !== void 0 ? s6 : this.lastNeed <= t8.length ? (t8.copy(this.lastChar, e9, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t8.copy(this.lastChar, e9, 0, t8.length), this.lastNeed -= t8.length, void 0);
}
function h4(t8, e9) {
  if ((t8.length - e9) % 2 == 0) {
    var s6 = t8.toString(\\"utf16le\\", e9);
    if (s6) {
      var i7 = s6.charCodeAt(s6.length - 1);
      if (i7 >= 55296 && i7 <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t8[t8.length - 2], this.lastChar[1] = t8[t8.length - 1], s6.slice(0, -1);
    }
    return s6;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t8[t8.length - 1], t8.toString(\\"utf16le\\", e9, t8.length - 1);
}
function l4(t8) {
  var e9 = t8 && t8.length ? this.write(t8) : \\"\\";
  if (this.lastNeed) {
    var s6 = this.lastTotal - this.lastNeed;
    return e9 + this.lastChar.toString(\\"utf16le\\", 0, s6);
  }
  return e9;
}
function u$12(t8, e9) {
  var s6 = (t8.length - e9) % 3;
  return s6 === 0 ? t8.toString(\\"base64\\", e9) : (this.lastNeed = 3 - s6, this.lastTotal = 3, s6 === 1 ? this.lastChar[0] = t8[t8.length - 1] : (this.lastChar[0] = t8[t8.length - 2], this.lastChar[1] = t8[t8.length - 1]), t8.toString(\\"base64\\", e9, t8.length - s6));
}
function o$12(t8) {
  var e9 = t8 && t8.length ? this.write(t8) : \\"\\";
  return this.lastNeed ? e9 + this.lastChar.toString(\\"base64\\", 0, 3 - this.lastNeed) : e9;
}
function f$1(t8) {
  return t8.toString(this.encoding);
}
function c4(t8) {
  return t8 && t8.length ? this.write(t8) : \\"\\";
}
e$12.StringDecoder = a4, a4.prototype.write = function(t8) {
  if (t8.length === 0)
    return \\"\\";
  var e9, s6;
  if (this.lastNeed) {
    if ((e9 = this.fillLast(t8)) === void 0)
      return \\"\\";
    s6 = this.lastNeed, this.lastNeed = 0;
  } else
    s6 = 0;
  return s6 < t8.length ? e9 ? e9 + this.text(t8, s6) : this.text(t8, s6) : e9 || \\"\\";
}, a4.prototype.end = function(t8) {
  var e9 = t8 && t8.length ? this.write(t8) : \\"\\";
  return this.lastNeed ? e9 + \\"\\\\uFFFD\\" : e9;
}, a4.prototype.text = function(t8, e9) {
  var s6 = function(t9, e10, s7) {
    var i8 = e10.length - 1;
    if (i8 < s7)
      return 0;
    var a7 = r4(e10[i8]);
    if (a7 >= 0)
      return a7 > 0 && (t9.lastNeed = a7 - 1), a7;
    if (--i8 < s7 || a7 === -2)
      return 0;
    if ((a7 = r4(e10[i8])) >= 0)
      return a7 > 0 && (t9.lastNeed = a7 - 2), a7;
    if (--i8 < s7 || a7 === -2)
      return 0;
    if ((a7 = r4(e10[i8])) >= 0)
      return a7 > 0 && (a7 === 2 ? a7 = 0 : t9.lastNeed = a7 - 3), a7;
    return 0;
  }(this, t8, e9);
  if (!this.lastNeed)
    return t8.toString(\\"utf8\\", e9);
  this.lastTotal = s6;
  var i7 = t8.length - (s6 - this.lastNeed);
  return t8.copy(this.lastChar, 0, i7), t8.toString(\\"utf8\\", e9, i7);
}, a4.prototype.fillLast = function(t8) {
  if (this.lastNeed <= t8.length)
    return t8.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  t8.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t8.length), this.lastNeed -= t8.length;
};
e$12.StringDecoder;
e$12.StringDecoder;

// node_modules/.pnpm/@jspm+core@2.0.0-beta.24/node_modules/@jspm/core/nodelibs/browser/chunk-44e51b61.js
var exports$2$1 = {};
var _dewExec$2$1 = false;
function dew$2$1() {
  if (_dewExec$2$1)
    return exports$2$1;
  _dewExec$2$1 = true;
  exports$2$1.byteLength = byteLength;
  exports$2$1.toByteArray = toByteArray;
  exports$2$1.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== \\"undefined\\" ? Uint8Array : Array;
  var code = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\";
  for (var i7 = 0, len = code.length; i7 < len; ++i7) {
    lookup[i7] = code[i7];
    revLookup[code.charCodeAt(i7)] = i7;
  }
  revLookup[\\"-\\".charCodeAt(0)] = 62;
  revLookup[\\"_\\".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error(\\"Invalid string. Length must be a multiple of 4\\");
    }
    var validLen = b64.indexOf(\\"=\\");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i8;
    for (i8 = 0; i8 < len2; i8 += 4) {
      tmp = revLookup[b64.charCodeAt(i8)] << 18 | revLookup[b64.charCodeAt(i8 + 1)] << 12 | revLookup[b64.charCodeAt(i8 + 2)] << 6 | revLookup[b64.charCodeAt(i8 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i8)] << 2 | revLookup[b64.charCodeAt(i8 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i8)] << 10 | revLookup[b64.charCodeAt(i8 + 1)] << 4 | revLookup[b64.charCodeAt(i8 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i8 = start; i8 < end; i8 += 3) {
      tmp = (uint8[i8] << 16 & 16711680) + (uint8[i8 + 1] << 8 & 65280) + (uint8[i8 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join(\\"\\");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i8 = 0, len22 = len2 - extraBytes; i8 < len22; i8 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i8, i8 + maxChunkLength > len22 ? len22 : i8 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \\"==\\");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \\"=\\");
    }
    return parts.join(\\"\\");
  }
  return exports$2$1;
}
var exports$1$1 = {};
var _dewExec$1$1 = false;
function dew$1$1() {
  if (_dewExec$1$1)
    return exports$1$1;
  _dewExec$1$1 = true;
  exports$1$1.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e9, m6;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i7 = isLE ? nBytes - 1 : 0;
    var d6 = isLE ? -1 : 1;
    var s6 = buffer2[offset + i7];
    i7 += d6;
    e9 = s6 & (1 << -nBits) - 1;
    s6 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e9 = e9 * 256 + buffer2[offset + i7], i7 += d6, nBits -= 8) {
    }
    m6 = e9 & (1 << -nBits) - 1;
    e9 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m6 = m6 * 256 + buffer2[offset + i7], i7 += d6, nBits -= 8) {
    }
    if (e9 === 0) {
      e9 = 1 - eBias;
    } else if (e9 === eMax) {
      return m6 ? NaN : (s6 ? -1 : 1) * Infinity;
    } else {
      m6 = m6 + Math.pow(2, mLen);
      e9 = e9 - eBias;
    }
    return (s6 ? -1 : 1) * m6 * Math.pow(2, e9 - mLen);
  };
  exports$1$1.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e9, m6, c7;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i7 = isLE ? 0 : nBytes - 1;
    var d6 = isLE ? 1 : -1;
    var s6 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m6 = isNaN(value) ? 1 : 0;
      e9 = eMax;
    } else {
      e9 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c7 = Math.pow(2, -e9)) < 1) {
        e9--;
        c7 *= 2;
      }
      if (e9 + eBias >= 1) {
        value += rt / c7;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c7 >= 2) {
        e9++;
        c7 /= 2;
      }
      if (e9 + eBias >= eMax) {
        m6 = 0;
        e9 = eMax;
      } else if (e9 + eBias >= 1) {
        m6 = (value * c7 - 1) * Math.pow(2, mLen);
        e9 = e9 + eBias;
      } else {
        m6 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e9 = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i7] = m6 & 255, i7 += d6, m6 /= 256, mLen -= 8) {
    }
    e9 = e9 << mLen | m6;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i7] = e9 & 255, i7 += d6, e9 /= 256, eLen -= 8) {
    }
    buffer2[offset + i7 - d6] |= s6 * 128;
  };
  return exports$1$1;
}
var exports$g = {};
var _dewExec$g = false;
function dew$g() {
  if (_dewExec$g)
    return exports$g;
  _dewExec$g = true;
  const base64 = dew$2$1();
  const ieee754 = dew$1$1();
  const customInspectSymbol = typeof Symbol === \\"function\\" && typeof Symbol[\\"for\\"] === \\"function\\" ? Symbol[\\"for\\"](\\"nodejs.util.inspect.custom\\") : null;
  exports$g.Buffer = Buffer2;
  exports$g.SlowBuffer = SlowBuffer;
  exports$g.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports$g.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \\"undefined\\" && typeof console.error === \\"function\\") {
    console.error(\\"This browser lacks typed array (Uint8Array) support which is required by \`buffer\` v5.x. Use \`buffer\` v4.x if you require old browser support.\\");
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = {
        foo: function() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e9) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, \\"parent\\", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, \\"offset\\", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value \\"' + length + '\\" is invalid for option \\"size\\"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === \\"number\\") {
      if (typeof encodingOrOffset === \\"string\\") {
        throw new TypeError('The \\"string\\" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === \\"string\\") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(\\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \\" + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== \\"undefined\\" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === \\"number\\") {
      throw new TypeError('The \\"value\\" argument must not be of type number. Received type number');
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    const b5 = fromObject(value);
    if (b5)
      return b5;
    if (typeof Symbol !== \\"undefined\\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \\"function\\") {
      return Buffer2.from(value[Symbol.toPrimitive](\\"string\\"), encodingOrOffset, length);
    }
    throw new TypeError(\\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \\" + typeof value);
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size) {
    if (typeof size !== \\"number\\") {
      throw new TypeError('\\"size\\" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value \\"' + size + '\\" is invalid for option \\"size\\"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === \\"string\\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== \\"string\\" || encoding === \\"\\") {
      encoding = \\"utf8\\";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError(\\"Unknown encoding: \\" + encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i7 = 0; i7 < length; i7 += 1) {
      buf[i7] = array[i7] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\\"offset\\" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\\"length\\" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== \\"number\\" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === \\"Buffer\\" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError(\\"Attempt to allocate Buffer larger than maximum size: 0x\\" + K_MAX_LENGTH.toString(16) + \\" bytes\\");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer3(b5) {
    return b5 != null && b5._isBuffer === true && b5 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a7, b5) {
    if (isInstance(a7, Uint8Array))
      a7 = Buffer2.from(a7, a7.offset, a7.byteLength);
    if (isInstance(b5, Uint8Array))
      b5 = Buffer2.from(b5, b5.offset, b5.byteLength);
    if (!Buffer2.isBuffer(a7) || !Buffer2.isBuffer(b5)) {
      throw new TypeError('The \\"buf1\\", \\"buf2\\" arguments must be one of type Buffer or Uint8Array');
    }
    if (a7 === b5)
      return 0;
    let x4 = a7.length;
    let y6 = b5.length;
    for (let i7 = 0, len = Math.min(x4, y6); i7 < len; ++i7) {
      if (a7[i7] !== b5[i7]) {
        x4 = a7[i7];
        y6 = b5[i7];
        break;
      }
    }
    if (x4 < y6)
      return -1;
    if (y6 < x4)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case \\"hex\\":
      case \\"utf8\\":
      case \\"utf-8\\":
      case \\"ascii\\":
      case \\"latin1\\":
      case \\"binary\\":
      case \\"base64\\":
      case \\"ucs2\\":
      case \\"ucs-2\\":
      case \\"utf16le\\":
      case \\"utf-16le\\":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('\\"list\\" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i7;
    if (length === void 0) {
      length = 0;
      for (i7 = 0; i7 < list.length; ++i7) {
        length += list[i7].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length);
    let pos = 0;
    for (i7 = 0; i7 < list.length; ++i7) {
      let buf = list[i7];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('\\"list\\" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength(string, encoding) {
    if (Buffer2.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== \\"string\\") {
      throw new TypeError('The \\"string\\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case \\"ascii\\":
        case \\"latin1\\":
        case \\"binary\\":
          return len;
        case \\"utf8\\":
        case \\"utf-8\\":
          return utf8ToBytes(string).length;
        case \\"ucs2\\":
        case \\"ucs-2\\":
        case \\"utf16le\\":
        case \\"utf-16le\\":
          return len * 2;
        case \\"hex\\":
          return len >>> 1;
        case \\"base64\\":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = (\\"\\" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return \\"\\";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return \\"\\";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return \\"\\";
    }
    if (!encoding)
      encoding = \\"utf8\\";
    while (true) {
      switch (encoding) {
        case \\"hex\\":
          return hexSlice(this, start, end);
        case \\"utf8\\":
        case \\"utf-8\\":
          return utf8Slice(this, start, end);
        case \\"ascii\\":
          return asciiSlice(this, start, end);
        case \\"latin1\\":
        case \\"binary\\":
          return latin1Slice(this, start, end);
        case \\"base64\\":
          return base64Slice(this, start, end);
        case \\"ucs2\\":
        case \\"ucs-2\\":
        case \\"utf16le\\":
        case \\"utf-16le\\":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError(\\"Unknown encoding: \\" + encoding);
          encoding = (encoding + \\"\\").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b5, n8, m6) {
    const i7 = b5[n8];
    b5[n8] = b5[m6];
    b5[m6] = i7;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError(\\"Buffer size must be a multiple of 16-bits\\");
    }
    for (let i7 = 0; i7 < len; i7 += 2) {
      swap(this, i7, i7 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError(\\"Buffer size must be a multiple of 32-bits\\");
    }
    for (let i7 = 0; i7 < len; i7 += 4) {
      swap(this, i7, i7 + 3);
      swap(this, i7 + 1, i7 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError(\\"Buffer size must be a multiple of 64-bits\\");
    }
    for (let i7 = 0; i7 < len; i7 += 8) {
      swap(this, i7, i7 + 7);
      swap(this, i7 + 1, i7 + 6);
      swap(this, i7 + 2, i7 + 5);
      swap(this, i7 + 3, i7 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0)
      return \\"\\";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b5) {
    if (!Buffer2.isBuffer(b5))
      throw new TypeError(\\"Argument must be a Buffer\\");
    if (this === b5)
      return true;
    return Buffer2.compare(this, b5) === 0;
  };
  Buffer2.prototype.inspect = function inspect3() {
    let str = \\"\\";
    const max = exports$g.INSPECT_MAX_BYTES;
    str = this.toString(\\"hex\\", 0, max).replace(/(.{2})/g, \\"$1 \\").trim();
    if (this.length > max)
      str += \\" ... \\";
    return \\"<Buffer \\" + str + \\">\\";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError('The \\"target\\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError(\\"out of range index\\");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x4 = thisEnd - thisStart;
    let y6 = end - start;
    const len = Math.min(x4, y6);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i7 = 0; i7 < len; ++i7) {
      if (thisCopy[i7] !== targetCopy[i7]) {
        x4 = thisCopy[i7];
        y6 = targetCopy[i7];
        break;
      }
    }
    if (x4 < y6)
      return -1;
    if (y6 < x4)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === \\"string\\") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === \\"string\\") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === \\"number\\") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === \\"function\\") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError(\\"val must be string, number or Buffer\\");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === \\"ucs2\\" || encoding === \\"ucs-2\\" || encoding === \\"utf16le\\" || encoding === \\"utf-16le\\") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i8) {
      if (indexSize === 1) {
        return buf[i8];
      } else {
        return buf.readUInt16BE(i8 * indexSize);
      }
    }
    let i7;
    if (dir) {
      let foundIndex = -1;
      for (i7 = byteOffset; i7 < arrLength; i7++) {
        if (read2(arr, i7) === read2(val, foundIndex === -1 ? 0 : i7 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i7;
          if (i7 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i7 -= i7 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i7 = byteOffset; i7 >= 0; i7--) {
        let found = true;
        for (let j4 = 0; j4 < valLength; j4++) {
          if (read2(arr, i7 + j4) !== read2(val, j4)) {
            found = false;
            break;
          }
        }
        if (found)
          return i7;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i7;
    for (i7 = 0; i7 < length; ++i7) {
      const parsed = parseInt(string.substr(i7 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i7;
      buf[offset + i7] = parsed;
    }
    return i7;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write2(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = \\"utf8\\";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === \\"string\\") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = \\"utf8\\";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(\\"Buffer.write(string, encoding, offset[, length]) is no longer supported\\");
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError(\\"Attempt to write outside buffer bounds\\");
    }
    if (!encoding)
      encoding = \\"utf8\\";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case \\"hex\\":
          return hexWrite(this, string, offset, length);
        case \\"utf8\\":
        case \\"utf-8\\":
          return utf8Write(this, string, offset, length);
        case \\"ascii\\":
        case \\"latin1\\":
        case \\"binary\\":
          return asciiWrite(this, string, offset, length);
        case \\"base64\\":
          return base64Write(this, string, offset, length);
        case \\"ucs2\\":
        case \\"ucs-2\\":
        case \\"utf16le\\":
        case \\"utf-16le\\":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError(\\"Unknown encoding: \\" + encoding);
          encoding = (\\"\\" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: \\"Buffer\\",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i7 = start;
    while (i7 < end) {
      const firstByte = buf[i7];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i7 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i7 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i7 + 1];
            thirdByte = buf[i7 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i7 + 1];
            thirdByte = buf[i7 + 2];
            fourthByte = buf[i7 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i7 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = \\"\\";
    let i7 = 0;
    while (i7 < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i7, i7 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = \\"\\";
    end = Math.min(buf.length, end);
    for (let i7 = start; i7 < end; ++i7) {
      ret += String.fromCharCode(buf[i7] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = \\"\\";
    end = Math.min(buf.length, end);
    for (let i7 = start; i7 < end; ++i7) {
      ret += String.fromCharCode(buf[i7]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = \\"\\";
    for (let i7 = start; i7 < end; ++i7) {
      out += hexSliceLookupTable[buf[i7]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = \\"\\";
    for (let i7 = 0; i7 < bytes.length - 1; i7 += 2) {
      res += String.fromCharCode(bytes[i7] + bytes[i7 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError(\\"offset is not uint\\");
    if (offset + ext > length)
      throw new RangeError(\\"Trying to access beyond buffer length\\");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i7 = 0;
    while (++i7 < byteLength2 && (mul *= 256)) {
      val += this[offset + i7] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    let val = this[offset + --byteLength2];
    let mul = 1;
    while (byteLength2 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength2] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, \\"offset\\");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, \\"offset\\");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i7 = 0;
    while (++i7 < byteLength2 && (mul *= 256)) {
      val += this[offset + i7] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let i7 = byteLength2;
    let mul = 1;
    let val = this[offset + --i7];
    while (i7 > 0 && (mul *= 256)) {
      val += this[offset + --i7] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, \\"offset\\");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, \\"offset\\");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('\\"buffer\\" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('\\"value\\" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError(\\"Index out of range\\");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let mul = 1;
    let i7 = 0;
    this[offset] = value & 255;
    while (++i7 < byteLength2 && (mul *= 256)) {
      this[offset + i7] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let i7 = byteLength2 - 1;
    let mul = 1;
    this[offset + i7] = value & 255;
    while (--i7 >= 0 && (mul *= 256)) {
      this[offset + i7] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\\"0xffffffffffffffff\\"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\\"0xffffffffffffffff\\"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i7 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i7 < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i7 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i7] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i7 = byteLength2 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i7] = value & 255;
    while (--i7 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i7 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i7] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt(\\"0x8000000000000000\\"), BigInt(\\"0x7fffffffffffffff\\"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt(\\"0x8000000000000000\\"), BigInt(\\"0x7fffffffffffffff\\"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError(\\"Index out of range\\");
    if (offset < 0)
      throw new RangeError(\\"Index out of range\\");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError(\\"argument should be a Buffer\\");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError(\\"targetStart out of bounds\\");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError(\\"Index out of range\\");
    if (end < 0)
      throw new RangeError(\\"sourceEnd out of bounds\\");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === \\"function\\") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === \\"string\\") {
      if (typeof start === \\"string\\") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === \\"string\\") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== \\"string\\") {
        throw new TypeError(\\"encoding must be a string\\");
      }
      if (typeof encoding === \\"string\\" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError(\\"Unknown encoding: \\" + encoding);
      }
      if (val.length === 1) {
        const code = val.charCodeAt(0);
        if (encoding === \\"utf8\\" && code < 128 || encoding === \\"latin1\\") {
          val = code;
        }
      }
    } else if (typeof val === \\"number\\") {
      val = val & 255;
    } else if (typeof val === \\"boolean\\") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError(\\"Out of range index\\");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i7;
    if (typeof val === \\"number\\") {
      for (i7 = start; i7 < end; ++i7) {
        this[i7] = val;
      }
    } else {
      const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value \\"' + val + '\\" is invalid for argument \\"value\\"');
      }
      for (i7 = 0; i7 < end - start; ++i7) {
        this[i7 + start] = bytes[i7 % len];
      }
    }
    return this;
  };
  const errors = {};
  function E4(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, \\"message\\", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = \`\${this.name} [\${sym}]\`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, \\"code\\", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return \`\${this.name} [\${sym}]: \${this.message}\`;
      }
    };
  }
  E4(\\"ERR_BUFFER_OUT_OF_BOUNDS\\", function(name2) {
    if (name2) {
      return \`\${name2} is outside of buffer bounds\`;
    }
    return \\"Attempt to access memory outside buffer bounds\\";
  }, RangeError);
  E4(\\"ERR_INVALID_ARG_TYPE\\", function(name2, actual) {
    return \`The \\"\${name2}\\" argument must be of type number. Received type \${typeof actual}\`;
  }, TypeError);
  E4(\\"ERR_OUT_OF_RANGE\\", function(str, range, input) {
    let msg = \`The value of \\"\${str}\\" is out of range.\`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === \\"bigint\\") {
      received = String(input);
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += \\"n\\";
    }
    msg += \` It must be \${range}. Received \${received}\`;
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    let res = \\"\\";
    let i7 = val.length;
    const start = val[0] === \\"-\\" ? 1 : 0;
    for (; i7 >= start + 4; i7 -= 3) {
      res = \`_\${val.slice(i7 - 3, i7)}\${res}\`;
    }
    return \`\${val.slice(0, i7)}\${res}\`;
  }
  function checkBounds(buf, offset, byteLength2) {
    validateNumber(offset, \\"offset\\");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
      boundsError(offset, buf.length - (byteLength2 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
      const n8 = typeof min === \\"bigint\\" ? \\"n\\" : \\"\\";
      let range;
      if (byteLength2 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = \`>= 0\${n8} and < 2\${n8} ** \${(byteLength2 + 1) * 8}\${n8}\`;
        } else {
          range = \`>= -(2\${n8} ** \${(byteLength2 + 1) * 8 - 1}\${n8}) and < 2 ** \${(byteLength2 + 1) * 8 - 1}\${n8}\`;
        }
      } else {
        range = \`>= \${min}\${n8} and <= \${max}\${n8}\`;
      }
      throw new errors.ERR_OUT_OF_RANGE(\\"value\\", range, value);
    }
    checkBounds(buf, offset, byteLength2);
  }
  function validateNumber(value, name2) {
    if (typeof value !== \\"number\\") {
      throw new errors.ERR_INVALID_ARG_TYPE(name2, \\"number\\", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE(type || \\"offset\\", \\"an integer\\", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(type || \\"offset\\", \`>= \${type ? 1 : 0} and <= \${length}\`, value);
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split(\\"=\\")[0];
    str = str.trim().replace(INVALID_BASE64_RE, \\"\\");
    if (str.length < 2)
      return \\"\\";
    while (str.length % 4 !== 0) {
      str = str + \\"=\\";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i7 = 0; i7 < length; ++i7) {
      codePoint = string.charCodeAt(i7);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i7 + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error(\\"Invalid code point\\");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i7 = 0; i7 < str.length; ++i7) {
      byteArray.push(str.charCodeAt(i7) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c7, hi, lo;
    const byteArray = [];
    for (let i7 = 0; i7 < str.length; ++i7) {
      if ((units -= 2) < 0)
        break;
      c7 = str.charCodeAt(i7);
      hi = c7 >> 8;
      lo = c7 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i7;
    for (i7 = 0; i7 < length; ++i7) {
      if (i7 + offset >= dst.length || i7 >= src.length)
        break;
      dst[i7 + offset] = src[i7];
    }
    return i7;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = \\"0123456789abcdef\\";
    const table = new Array(256);
    for (let i7 = 0; i7 < 16; ++i7) {
      const i16 = i7 * 16;
      for (let j4 = 0; j4 < 16; ++j4) {
        table[i16 + j4] = alphabet[i7] + alphabet[j4];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === \\"undefined\\" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error(\\"BigInt not supported\\");
  }
  return exports$g;
}
var buffer = dew$g();
buffer.Buffer;
buffer.INSPECT_MAX_BYTES;
buffer.kMaxLength;
var exports$f = {};
var _dewExec$f = false;
function dew$f() {
  if (_dewExec$f)
    return exports$f;
  _dewExec$f = true;
  if (typeof Object.create === \\"function\\") {
    exports$f = function inherits3(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    exports$f = function inherits3(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return exports$f;
}
var exports$e = {};
var _dewExec$e = false;
function dew$e() {
  if (_dewExec$e)
    return exports$e;
  _dewExec$e = true;
  exports$e = y.EventEmitter;
  return exports$e;
}
var exports$d = {};
var _dewExec$d = false;
function dew$d() {
  if (_dewExec$d)
    return exports$d;
  _dewExec$d = true;
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i7 = 1; i7 < arguments.length; i7++) {
      var source = arguments[i7] != null ? arguments[i7] : {};
      if (i7 % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError(\\"Cannot call a class as a function\\");
    }
  }
  function _defineProperties(target, props) {
    for (var i7 = 0; i7 < props.length; i7++) {
      var descriptor = props[i7];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if (\\"value\\" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var _require = buffer, Buffer2 = _require.Buffer;
  var _require2 = X, inspect3 = _require2.inspect;
  var custom = inspect3 && inspect3.custom || \\"inspect\\";
  function copyBuffer(src, target, offset) {
    Buffer2.prototype.copy.call(src, target, offset);
  }
  exports$d = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: \\"push\\",
      value: function push(v6) {
        var entry = {
          data: v6,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: \\"unshift\\",
      value: function unshift(v6) {
        var entry = {
          data: v6,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: \\"shift\\",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: \\"clear\\",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: \\"join\\",
      value: function join2(s6) {
        if (this.length === 0)
          return \\"\\";
        var p7 = this.head;
        var ret = \\"\\" + p7.data;
        while (p7 = p7.next) {
          ret += s6 + p7.data;
        }
        return ret;
      }
    }, {
      key: \\"concat\\",
      value: function concat(n8) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n8 >>> 0);
        var p7 = this.head;
        var i7 = 0;
        while (p7) {
          copyBuffer(p7.data, ret, i7);
          i7 += p7.data.length;
          p7 = p7.next;
        }
        return ret;
      }
    }, {
      key: \\"consume\\",
      value: function consume(n8, hasStrings) {
        var ret;
        if (n8 < this.head.data.length) {
          ret = this.head.data.slice(0, n8);
          this.head.data = this.head.data.slice(n8);
        } else if (n8 === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n8) : this._getBuffer(n8);
        }
        return ret;
      }
    }, {
      key: \\"first\\",
      value: function first() {
        return this.head.data;
      }
    }, {
      key: \\"_getString\\",
      value: function _getString(n8) {
        var p7 = this.head;
        var c7 = 1;
        var ret = p7.data;
        n8 -= ret.length;
        while (p7 = p7.next) {
          var str = p7.data;
          var nb = n8 > str.length ? str.length : n8;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n8);
          n8 -= nb;
          if (n8 === 0) {
            if (nb === str.length) {
              ++c7;
              if (p7.next)
                this.head = p7.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p7;
              p7.data = str.slice(nb);
            }
            break;
          }
          ++c7;
        }
        this.length -= c7;
        return ret;
      }
    }, {
      key: \\"_getBuffer\\",
      value: function _getBuffer(n8) {
        var ret = Buffer2.allocUnsafe(n8);
        var p7 = this.head;
        var c7 = 1;
        p7.data.copy(ret);
        n8 -= p7.data.length;
        while (p7 = p7.next) {
          var buf = p7.data;
          var nb = n8 > buf.length ? buf.length : n8;
          buf.copy(ret, ret.length - n8, 0, nb);
          n8 -= nb;
          if (n8 === 0) {
            if (nb === buf.length) {
              ++c7;
              if (p7.next)
                this.head = p7.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p7;
              p7.data = buf.slice(nb);
            }
            break;
          }
          ++c7;
        }
        this.length -= c7;
        return ret;
      }
    }, {
      key: custom,
      value: function value(_4, options) {
        return inspect3(this, _objectSpread({}, options, {
          depth: 0,
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
  return exports$d;
}
var exports$c = {};
var _dewExec$c = false;
function dew$c() {
  if (_dewExec$c)
    return exports$c;
  _dewExec$c = true;
  var process$1 = process;
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process$1.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process$1.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process$1.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose)
      return;
    if (self2._readableState && !self2._readableState.emitClose)
      return;
    self2.emit(\\"close\\");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit(\\"error\\", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy)
      stream.destroy(err);
    else
      stream.emit(\\"error\\", err);
  }
  exports$c = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  return exports$c;
}
var exports$b = {};
var _dewExec$b = false;
function dew$b() {
  if (_dewExec$b)
    return exports$b;
  _dewExec$b = true;
  const codes = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === \\"string\\") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i7) => String(i7));
      if (len > 2) {
        return \`one of \${thing} \${expected.slice(0, len - 1).join(\\", \\")}, or \` + expected[len - 1];
      } else if (len === 2) {
        return \`one of \${thing} \${expected[0]} or \${expected[1]}\`;
      } else {
        return \`of \${thing} \${expected[0]}\`;
      }
    } else {
      return \`of \${thing} \${String(expected)}\`;
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== \\"number\\") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType(\\"ERR_INVALID_OPT_VALUE\\", function(name2, value) {
    return 'The value \\"' + value + '\\" is invalid for option \\"' + name2 + '\\"';
  }, TypeError);
  createErrorType(\\"ERR_INVALID_ARG_TYPE\\", function(name2, expected, actual) {
    let determiner;
    if (typeof expected === \\"string\\" && startsWith(expected, \\"not \\")) {
      determiner = \\"must not be\\";
      expected = expected.replace(/^not /, \\"\\");
    } else {
      determiner = \\"must be\\";
    }
    let msg;
    if (endsWith(name2, \\" argument\\")) {
      msg = \`The \${name2} \${determiner} \${oneOf(expected, \\"type\\")}\`;
    } else {
      const type = includes(name2, \\".\\") ? \\"property\\" : \\"argument\\";
      msg = \`The \\"\${name2}\\" \${type} \${determiner} \${oneOf(expected, \\"type\\")}\`;
    }
    msg += \`. Received type \${typeof actual}\`;
    return msg;
  }, TypeError);
  createErrorType(\\"ERR_STREAM_PUSH_AFTER_EOF\\", \\"stream.push() after EOF\\");
  createErrorType(\\"ERR_METHOD_NOT_IMPLEMENTED\\", function(name2) {
    return \\"The \\" + name2 + \\" method is not implemented\\";
  });
  createErrorType(\\"ERR_STREAM_PREMATURE_CLOSE\\", \\"Premature close\\");
  createErrorType(\\"ERR_STREAM_DESTROYED\\", function(name2) {
    return \\"Cannot call \\" + name2 + \\" after a stream was destroyed\\";
  });
  createErrorType(\\"ERR_MULTIPLE_CALLBACK\\", \\"Callback called multiple times\\");
  createErrorType(\\"ERR_STREAM_CANNOT_PIPE\\", \\"Cannot pipe, not readable\\");
  createErrorType(\\"ERR_STREAM_WRITE_AFTER_END\\", \\"write after end\\");
  createErrorType(\\"ERR_STREAM_NULL_VALUES\\", \\"May not write null values to stream\\", TypeError);
  createErrorType(\\"ERR_UNKNOWN_ENCODING\\", function(arg) {
    return \\"Unknown encoding: \\" + arg;
  }, TypeError);
  createErrorType(\\"ERR_STREAM_UNSHIFT_AFTER_END_EVENT\\", \\"stream.unshift() after end event\\");
  exports$b.codes = codes;
  return exports$b;
}
var exports$a = {};
var _dewExec$a = false;
function dew$a() {
  if (_dewExec$a)
    return exports$a;
  _dewExec$a = true;
  var ERR_INVALID_OPT_VALUE = dew$b().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name2 = isDuplex ? duplexKey : \\"highWaterMark\\";
        throw new ERR_INVALID_OPT_VALUE(name2, hwm);
      }
      return Math.floor(hwm);
    }
    return state.objectMode ? 16 : 16 * 1024;
  }
  exports$a = {
    getHighWaterMark
  };
  return exports$a;
}
var exports$9 = {};
var _dewExec$9 = false;
var _global$2 = typeof globalThis !== \\"undefined\\" ? globalThis : typeof self !== \\"undefined\\" ? self : global;
function dew$9() {
  if (_dewExec$9)
    return exports$9;
  _dewExec$9 = true;
  exports$9 = deprecate3;
  function deprecate3(fn, msg) {
    if (config(\\"noDeprecation\\")) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (config(\\"throwDeprecation\\")) {
          throw new Error(msg);
        } else if (config(\\"traceDeprecation\\")) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned = true;
      }
      return fn.apply(this || _global$2, arguments);
    }
    return deprecated;
  }
  function config(name2) {
    try {
      if (!_global$2.localStorage)
        return false;
    } catch (_4) {
      return false;
    }
    var val = _global$2.localStorage[name2];
    if (val == null)
      return false;
    return String(val).toLowerCase() === \\"true\\";
  }
  return exports$9;
}
var exports$8 = {};
var _dewExec$8 = false;
var _global$1 = typeof globalThis !== \\"undefined\\" ? globalThis : typeof self !== \\"undefined\\" ? self : global;
function dew$8() {
  if (_dewExec$8)
    return exports$8;
  _dewExec$8 = true;
  var process$1 = process;
  exports$8 = Writable2;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var Duplex2;
  Writable2.WritableState = WritableState;
  var internalUtil = {
    deprecate: dew$9()
  };
  var Stream2 = dew$e();
  var Buffer2 = buffer.Buffer;
  var OurUint8Array = _global$1.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = dew$c();
  var _require = dew$a(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = dew$b().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  dew$f()(Writable2, Stream2);
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex2 = Duplex2 || dew$7();
    options = options || {};
    if (typeof isDuplex !== \\"boolean\\")
      isDuplex = stream instanceof Duplex2;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, \\"writableHighWaterMark\\", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || \\"utf8\\";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, \\"buffer\\", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, \\"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.\\", \\"DEP0003\\")
      });
    } catch (_4) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === \\"function\\" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === \\"function\\") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable2, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable2)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable2(options) {
    Duplex2 = Duplex2 || dew$7();
    var isDuplex = this instanceof Duplex2;
    if (!isDuplex && !realHasInstance.call(Writable2, this))
      return new Writable2(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === \\"function\\")
        this._write = options.write;
      if (typeof options.writev === \\"function\\")
        this._writev = options.writev;
      if (typeof options.destroy === \\"function\\")
        this._destroy = options.destroy;
      if (typeof options.final === \\"function\\")
        this._final = options.final;
    }
    Stream2.call(this);
  }
  Writable2.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream, er);
    process$1.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== \\"string\\" && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE(\\"chunk\\", [\\"string\\", \\"Buffer\\"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process$1.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable2.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === \\"function\\") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = \\"buffer\\";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== \\"function\\")
      cb = nop;
    if (state.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable2.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable2.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === \\"string\\")
      encoding = encoding.toLowerCase();
    if (!([\\"hex\\", \\"utf8\\", \\"utf-8\\", \\"ascii\\", \\"binary\\", \\"base64\\", \\"ucs2\\", \\"ucs-2\\", \\"utf16le\\", \\"utf-16le\\", \\"raw\\"].indexOf((encoding + \\"\\").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable2.prototype, \\"writableBuffer\\", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === \\"string\\") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable2.prototype, \\"writableHighWaterMark\\", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = \\"buffer\\";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev2, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED(\\"write\\"));
    else if (writev2)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      process$1.nextTick(cb, er);
      process$1.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== \\"function\\")
      throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished2 = needFinish(state) || stream.destroyed;
      if (!finished2 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        process$1.nextTick(afterWrite, stream, state, finished2, cb);
      } else {
        afterWrite(stream, state, finished2, cb);
      }
    }
  }
  function afterWrite(stream, state, finished2, cb) {
    if (!finished2)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit(\\"drain\\");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l7 = state.bufferedRequestCount;
      var buffer2 = new Array(l7);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer2, \\"\\", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable2.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED(\\"_write()\\"));
  };
  Writable2.prototype._writev = null;
  Writable2.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === \\"function\\") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === \\"function\\") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
    return this;
  };
  Object.defineProperty(Writable2.prototype, \\"writableLength\\", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state.prefinished = true;
      stream.emit(\\"prefinish\\");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === \\"function\\" && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process$1.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit(\\"prefinish\\");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit(\\"finish\\");
        if (state.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        process$1.nextTick(cb);
      else
        stream.once(\\"finish\\", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable2.prototype, \\"destroyed\\", {
    enumerable: false,
    get: function get() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable2.prototype.destroy = destroyImpl.destroy;
  Writable2.prototype._undestroy = destroyImpl.undestroy;
  Writable2.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return exports$8;
}
var exports$7 = {};
var _dewExec$7 = false;
function dew$7() {
  if (_dewExec$7)
    return exports$7;
  _dewExec$7 = true;
  var process$1 = process;
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  exports$7 = Duplex2;
  var Readable2 = dew$3();
  var Writable2 = dew$8();
  dew$f()(Duplex2, Readable2);
  {
    var keys = objectKeys(Writable2.prototype);
    for (var v6 = 0; v6 < keys.length; v6++) {
      var method = keys[v6];
      if (!Duplex2.prototype[method])
        Duplex2.prototype[method] = Writable2.prototype[method];
    }
  }
  function Duplex2(options) {
    if (!(this instanceof Duplex2))
      return new Duplex2(options);
    Readable2.call(this, options);
    Writable2.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once(\\"end\\", onend);
      }
    }
  }
  Object.defineProperty(Duplex2.prototype, \\"writableHighWaterMark\\", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex2.prototype, \\"writableBuffer\\", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex2.prototype, \\"writableLength\\", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended)
      return;
    process$1.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex2.prototype, \\"destroyed\\", {
    enumerable: false,
    get: function get() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return exports$7;
}
var exports$6 = {};
var _dewExec$6 = false;
function dew$6() {
  if (_dewExec$6)
    return exports$6;
  _dewExec$6 = true;
  var ERR_STREAM_PREMATURE_CLOSE = dew$b().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once2(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop() {
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === \\"function\\";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === \\"function\\")
      return eos(stream, null, opts);
    if (!opts)
      opts = {};
    callback = once2(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream.writable)
        onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable)
        callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable)
        callback.call(stream);
    };
    var onerror = function onerror2(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest2() {
      stream.req.on(\\"finish\\", onfinish);
    };
    if (isRequest(stream)) {
      stream.on(\\"complete\\", onfinish);
      stream.on(\\"abort\\", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on(\\"request\\", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on(\\"end\\", onlegacyfinish);
      stream.on(\\"close\\", onlegacyfinish);
    }
    stream.on(\\"end\\", onend);
    stream.on(\\"finish\\", onfinish);
    if (opts.error !== false)
      stream.on(\\"error\\", onerror);
    stream.on(\\"close\\", onclose);
    return function() {
      stream.removeListener(\\"complete\\", onfinish);
      stream.removeListener(\\"abort\\", onclose);
      stream.removeListener(\\"request\\", onrequest);
      if (stream.req)
        stream.req.removeListener(\\"finish\\", onfinish);
      stream.removeListener(\\"end\\", onlegacyfinish);
      stream.removeListener(\\"close\\", onlegacyfinish);
      stream.removeListener(\\"finish\\", onfinish);
      stream.removeListener(\\"end\\", onend);
      stream.removeListener(\\"error\\", onerror);
      stream.removeListener(\\"close\\", onclose);
    };
  }
  exports$6 = eos;
  return exports$6;
}
var exports$5 = {};
var _dewExec$5 = false;
function dew$5() {
  if (_dewExec$5)
    return exports$5;
  _dewExec$5 = true;
  var process$1 = process;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var finished2 = dew$6();
  var kLastResolve = Symbol(\\"lastResolve\\");
  var kLastReject = Symbol(\\"lastReject\\");
  var kError = Symbol(\\"error\\");
  var kEnded = Symbol(\\"ended\\");
  var kLastPromise = Symbol(\\"lastPromise\\");
  var kHandlePromise = Symbol(\\"handlePromise\\");
  var kStream = Symbol(\\"stream\\");
  function createIterResult2(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve3 = iter[kLastResolve];
    if (resolve3 !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve3(createIterResult2(data, false));
      }
    }
  }
  function onReadable(iter) {
    process$1.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve3, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve3(createIterResult2(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve3, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult2(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve3, reject) {
          process$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve3(createIterResult2(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult2(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, \\"return\\", function _return() {
    var _this2 = this;
    return new Promise(function(resolve3, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve3(createIterResult2(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve3, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve3(createIterResult2(data, false));
        } else {
          iterator[kLastResolve] = resolve3;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished2(stream, function(err) {
      if (err && err.code !== \\"ERR_STREAM_PREMATURE_CLOSE\\") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve3 = iterator[kLastResolve];
      if (resolve3 !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve3(createIterResult2(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream.on(\\"readable\\", onReadable.bind(null, iterator));
    return iterator;
  };
  exports$5 = createReadableStreamAsyncIterator;
  return exports$5;
}
var exports$4 = {};
var _dewExec$4 = false;
function dew$4() {
  if (_dewExec$4)
    return exports$4;
  _dewExec$4 = true;
  exports$4 = function() {
    throw new Error(\\"Readable.from is not available in the browser\\");
  };
  return exports$4;
}
var exports$3 = {};
var _dewExec$3 = false;
var _global2 = typeof globalThis !== \\"undefined\\" ? globalThis : typeof self !== \\"undefined\\" ? self : global;
function dew$3() {
  if (_dewExec$3)
    return exports$3;
  _dewExec$3 = true;
  var process$1 = process;
  exports$3 = Readable2;
  var Duplex2;
  Readable2.ReadableState = ReadableState;
  y.EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream2 = dew$e();
  var Buffer2 = buffer.Buffer;
  var OurUint8Array = _global2.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = X;
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog(\\"stream\\");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList = dew$d();
  var destroyImpl = dew$c();
  var _require = dew$a(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = dew$b().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  dew$f()(Readable2, Stream2);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = [\\"error\\", \\"close\\", \\"destroy\\", \\"pause\\", \\"resume\\"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === \\"function\\")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex2 = Duplex2 || dew$7();
    options = options || {};
    if (typeof isDuplex !== \\"boolean\\")
      isDuplex = stream instanceof Duplex2;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, \\"readableHighWaterMark\\", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || \\"utf8\\";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = e$12.StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex2 = Duplex2 || dew$7();
    if (!(this instanceof Readable2))
      return new Readable2(options);
    var isDuplex = this instanceof Duplex2;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === \\"function\\")
        this._read = options.read;
      if (typeof options.destroy === \\"function\\")
        this._destroy = options.destroy;
    }
    Stream2.call(this);
  }
  Object.defineProperty(Readable2.prototype, \\"destroyed\\", {
    enumerable: false,
    get: function get() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === \\"string\\") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = \\"\\";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug(\\"readableAddChunk\\", chunk);
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== \\"string\\" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream.emit(\\"data\\", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== \\"string\\" && chunk !== void 0 && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE(\\"chunk\\", [\\"string\\", \\"Buffer\\", \\"Uint8Array\\"], chunk);
    }
    return er;
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = e$12.StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p7 = this._readableState.buffer.head;
    var content = \\"\\";
    while (p7 !== null) {
      content += decoder.write(p7.data);
      p7 = p7.next;
    }
    this._readableState.buffer.clear();
    if (content !== \\"\\")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n8) {
    if (n8 >= MAX_HWM) {
      n8 = MAX_HWM;
    } else {
      n8--;
      n8 |= n8 >>> 1;
      n8 |= n8 >>> 2;
      n8 |= n8 >>> 4;
      n8 |= n8 >>> 8;
      n8 |= n8 >>> 16;
      n8++;
    }
    return n8;
  }
  function howMuchToRead(n8, state) {
    if (n8 <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n8 !== n8) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n8 > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n8);
    if (n8 <= state.length)
      return n8;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable2.prototype.read = function(n8) {
    debug(\\"read\\", n8);
    n8 = parseInt(n8, 10);
    var state = this._readableState;
    var nOrig = n8;
    if (n8 !== 0)
      state.emittedReadable = false;
    if (n8 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug(\\"read: emitReadable\\", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n8 = howMuchToRead(n8, state);
    if (n8 === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug(\\"need readable\\", doRead);
    if (state.length === 0 || state.length - n8 < state.highWaterMark) {
      doRead = true;
      debug(\\"length less than watermark\\", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug(\\"reading or ended\\", doRead);
    } else if (doRead) {
      debug(\\"do read\\");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n8 = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n8 > 0)
      ret = fromList(n8, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n8 = 0;
    } else {
      state.length -= n8;
      state.awaitDrain = 0;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n8 && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit(\\"data\\", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    debug(\\"onEofChunk\\");
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream);
    } else {
      state.needReadable = false;
      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    debug(\\"emitReadable\\", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug(\\"emitReadable\\", state.flowing);
      state.emittedReadable = true;
      process$1.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state = stream._readableState;
    debug(\\"emitReadable_\\", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
      stream.emit(\\"readable\\");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process$1.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug(\\"maybeReadMore read 0\\");
      stream.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  }
  Readable2.prototype._read = function(n8) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED(\\"_read()\\"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug(\\"pipe count=%d opts=%j\\", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      process$1.nextTick(endFn);
    else
      src.once(\\"end\\", endFn);
    dest.on(\\"unpipe\\", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug(\\"onunpipe\\");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug(\\"onend\\");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on(\\"drain\\", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug(\\"cleanup\\");
      dest.removeListener(\\"close\\", onclose);
      dest.removeListener(\\"finish\\", onfinish);
      dest.removeListener(\\"drain\\", ondrain);
      dest.removeListener(\\"error\\", onerror);
      dest.removeListener(\\"unpipe\\", onunpipe);
      src.removeListener(\\"end\\", onend);
      src.removeListener(\\"end\\", unpipe);
      src.removeListener(\\"data\\", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src.on(\\"data\\", ondata);
    function ondata(chunk) {
      debug(\\"ondata\\");
      var ret = dest.write(chunk);
      debug(\\"dest.write\\", ret);
      if (ret === false) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug(\\"false write response, pause\\", state.awaitDrain);
          state.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug(\\"onerror\\", er);
      unpipe();
      dest.removeListener(\\"error\\", onerror);
      if (EElistenerCount(dest, \\"error\\") === 0)
        errorOrDestroy(dest, er);
    }
    prependListener(dest, \\"error\\", onerror);
    function onclose() {
      dest.removeListener(\\"finish\\", onfinish);
      unpipe();
    }
    dest.once(\\"close\\", onclose);
    function onfinish() {
      debug(\\"onfinish\\");
      dest.removeListener(\\"close\\", onclose);
      unpipe();
    }
    dest.once(\\"finish\\", onfinish);
    function unpipe() {
      debug(\\"unpipe\\");
      src.unpipe(dest);
    }
    dest.emit(\\"pipe\\", src);
    if (!state.flowing) {
      debug(\\"pipe resume\\");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug(\\"pipeOnDrain\\", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, \\"data\\")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit(\\"unpipe\\", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i7 = 0; i7 < len; i7++) {
        dests[i7].emit(\\"unpipe\\", this, {
          hasUnpiped: false
        });
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit(\\"unpipe\\", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream2.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === \\"data\\") {
      state.readableListening = this.listenerCount(\\"readable\\") > 0;
      if (state.flowing !== false)
        this.resume();
    } else if (ev === \\"readable\\") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug(\\"on readable\\", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process$1.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  Readable2.prototype.removeListener = function(ev, fn) {
    var res = Stream2.prototype.removeListener.call(this, ev, fn);
    if (ev === \\"readable\\") {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable2.prototype.removeAllListeners = function(ev) {
    var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
    if (ev === \\"readable\\" || ev === void 0) {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state = self2._readableState;
    state.readableListening = self2.listenerCount(\\"readable\\") > 0;
    if (state.resumeScheduled && !state.paused) {
      state.flowing = true;
    } else if (self2.listenerCount(\\"data\\") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug(\\"readable nexttick read 0\\");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug(\\"resume\\");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state.paused = false;
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process$1.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    debug(\\"resume\\", state.reading);
    if (!state.reading) {
      stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit(\\"resume\\");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable2.prototype.pause = function() {
    debug(\\"call pause flowing=%j\\", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug(\\"pause\\");
      this._readableState.flowing = false;
      this.emit(\\"pause\\");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug(\\"flow\\", state.flowing);
    while (state.flowing && stream.read() !== null) {
    }
  }
  Readable2.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on(\\"end\\", function() {
      debug(\\"wrapped end\\");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on(\\"data\\", function(chunk) {
      debug(\\"wrapped data\\");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i7 in stream) {
      if (this[i7] === void 0 && typeof stream[i7] === \\"function\\") {
        this[i7] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i7);
      }
    }
    for (var n8 = 0; n8 < kProxyEvents.length; n8++) {
      stream.on(kProxyEvents[n8], this.emit.bind(this, kProxyEvents[n8]));
    }
    this._read = function(n9) {
      debug(\\"wrapped _read\\", n9);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === \\"function\\") {
    Readable2.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = dew$5();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable2.prototype, \\"readableHighWaterMark\\", {
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable2.prototype, \\"readableBuffer\\", {
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable2.prototype, \\"readableFlowing\\", {
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  });
  Readable2._fromList = fromList;
  Object.defineProperty(Readable2.prototype, \\"readableLength\\", {
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  });
  function fromList(n8, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n8 || n8 >= state.length) {
      if (state.decoder)
        ret = state.buffer.join(\\"\\");
      else if (state.buffer.length === 1)
        ret = state.buffer.first();
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n8, state.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    debug(\\"endReadable\\", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process$1.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    debug(\\"endReadableNT\\", state.endEmitted, state.length);
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit(\\"end\\");
      if (state.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === \\"function\\") {
    Readable2.from = function(iterable, opts) {
      if (from === void 0) {
        from = dew$4();
      }
      return from(Readable2, iterable, opts);
    };
  }
  function indexOf(xs, x4) {
    for (var i7 = 0, l7 = xs.length; i7 < l7; i7++) {
      if (xs[i7] === x4)
        return i7;
    }
    return -1;
  }
  return exports$3;
}
var exports$2 = {};
var _dewExec$2 = false;
function dew$2() {
  if (_dewExec$2)
    return exports$2;
  _dewExec$2 = true;
  exports$2 = Transform2;
  var _require$codes = dew$b().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex2 = dew$7();
  dew$f()(Transform2, Duplex2);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit(\\"error\\", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform2(options) {
    if (!(this instanceof Transform2))
      return new Transform2(options);
    Duplex2.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === \\"function\\")
        this._transform = options.transform;
      if (typeof options.flush === \\"function\\")
        this._flush = options.flush;
    }
    this.on(\\"prefinish\\", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === \\"function\\" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform2.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex2.prototype.push.call(this, chunk, encoding);
  };
  Transform2.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED(\\"_transform()\\"));
  };
  Transform2.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform2.prototype._read = function(n8) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform2.prototype._destroy = function(err, cb) {
    Duplex2.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit(\\"error\\", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming)
      throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }
  return exports$2;
}
var exports$1 = {};
var _dewExec$1 = false;
function dew$1() {
  if (_dewExec$1)
    return exports$1;
  _dewExec$1 = true;
  exports$1 = PassThrough2;
  var Transform2 = dew$2();
  dew$f()(PassThrough2, Transform2);
  function PassThrough2(options) {
    if (!(this instanceof PassThrough2))
      return new PassThrough2(options);
    Transform2.call(this, options);
  }
  PassThrough2.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return exports$1;
}
var exports2 = {};
var _dewExec2 = false;
function dew2() {
  if (_dewExec2)
    return exports2;
  _dewExec2 = true;
  var eos;
  function once2(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = dew$b().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop(err) {
    if (err)
      throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === \\"function\\";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once2(callback);
    var closed = false;
    stream.on(\\"close\\", function() {
      closed = true;
    });
    if (eos === void 0)
      eos = dew$6();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isRequest(stream))
        return stream.abort();
      if (typeof stream.destroy === \\"function\\")
        return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED(\\"pipe\\"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length)
      return noop;
    if (typeof streams[streams.length - 1] !== \\"function\\")
      return noop;
    return streams.pop();
  }
  function pipeline2() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS(\\"streams\\");
    }
    var error;
    var destroys = streams.map(function(stream, i7) {
      var reading = i7 < streams.length - 1;
      var writing = i7 > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  exports2 = pipeline2;
  return exports2;
}

// node_modules/.pnpm/@jspm+core@2.0.0-beta.24/node_modules/@jspm/core/nodelibs/browser/assert.js
function e5(e9, r9) {
  if (e9 == null)
    throw new TypeError(\\"Cannot convert first argument to object\\");
  for (var t8 = Object(e9), n8 = 1; n8 < arguments.length; n8++) {
    var o8 = arguments[n8];
    if (o8 != null)
      for (var a7 = Object.keys(Object(o8)), l7 = 0, i7 = a7.length; l7 < i7; l7++) {
        var c7 = a7[l7], b5 = Object.getOwnPropertyDescriptor(o8, c7);
        b5 !== void 0 && b5.enumerable && (t8[c7] = o8[c7]);
      }
  }
  return t8;
}
var r5 = { assign: e5, polyfill: function() {
  Object.assign || Object.defineProperty(Object, \\"assign\\", { enumerable: false, configurable: true, writable: true, value: e5 });
} };
var t5;
var e$13 = Object.prototype.toString;
var r$12 = function(t8) {
  var r9 = e$13.call(t8), n8 = r9 === \\"[object Arguments]\\";
  return n8 || (n8 = r9 !== \\"[object Array]\\" && t8 !== null && typeof t8 == \\"object\\" && typeof t8.length == \\"number\\" && t8.length >= 0 && e$13.call(t8.callee) === \\"[object Function]\\"), n8;
};
if (!Object.keys) {
  n8 = Object.prototype.hasOwnProperty, o8 = Object.prototype.toString, c7 = r$12, l7 = Object.prototype.propertyIsEnumerable, i7 = !l7.call({ toString: null }, \\"toString\\"), a7 = l7.call(function() {
  }, \\"prototype\\"), u7 = [\\"toString\\", \\"toLocaleString\\", \\"valueOf\\", \\"hasOwnProperty\\", \\"isPrototypeOf\\", \\"propertyIsEnumerable\\", \\"constructor\\"], f7 = function(t8) {
    var e9 = t8.constructor;
    return e9 && e9.prototype === t8;
  }, p7 = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, s6 = function() {
    if (typeof window == \\"undefined\\")
      return false;
    for (var t8 in window)
      try {
        if (!p7[\\"$\\" + t8] && n8.call(window, t8) && window[t8] !== null && typeof window[t8] == \\"object\\")
          try {
            f7(window[t8]);
          } catch (t9) {
            return true;
          }
      } catch (t9) {
        return true;
      }
    return false;
  }();
  t5 = function(t8) {
    var e9 = t8 !== null && typeof t8 == \\"object\\", r9 = o8.call(t8) === \\"[object Function]\\", l8 = c7(t8), p8 = e9 && o8.call(t8) === \\"[object String]\\", y6 = [];
    if (!e9 && !r9 && !l8)
      throw new TypeError(\\"Object.keys called on a non-object\\");
    var b5 = a7 && r9;
    if (p8 && t8.length > 0 && !n8.call(t8, 0))
      for (var g5 = 0; g5 < t8.length; ++g5)
        y6.push(String(g5));
    if (l8 && t8.length > 0)
      for (var h8 = 0; h8 < t8.length; ++h8)
        y6.push(String(h8));
    else
      for (var $3 in t8)
        b5 && $3 === \\"prototype\\" || !n8.call(t8, $3) || y6.push(String($3));
    if (i7)
      for (var j4 = function(t9) {
        if (typeof window == \\"undefined\\" || !s6)
          return f7(t9);
        try {
          return f7(t9);
        } catch (t10) {
          return false;
        }
      }(t8), w4 = 0; w4 < u7.length; ++w4)
        j4 && u7[w4] === \\"constructor\\" || !n8.call(t8, u7[w4]) || y6.push(u7[w4]);
    return y6;
  };
}
var n8;
var o8;
var c7;
var l7;
var i7;
var a7;
var u7;
var f7;
var p7;
var s6;
var y4 = t5;
var b3 = Array.prototype.slice;
var g3 = r$12;
var h5 = Object.keys;
var $2 = h5 ? function(t8) {
  return h5(t8);
} : y4;
var j3 = Object.keys;
$2.shim = function() {
  Object.keys ? function() {
    var t8 = Object.keys(arguments);
    return t8 && t8.length === arguments.length;
  }(1, 2) || (Object.keys = function(t8) {
    return g3(t8) ? j3(b3.call(t8)) : j3(t8);
  }) : Object.keys = $2;
  return Object.keys || $2;
};
var w3 = $2;
var r$2 = w3;
var e$2 = typeof Symbol == \\"function\\" && typeof Symbol(\\"foo\\") == \\"symbol\\";
var o$13 = Object.prototype.toString;
var n$13 = Array.prototype.concat;
var a$1 = Object.defineProperty;
var c$13 = a$1 && function() {
  var t8 = {};
  try {
    for (var r9 in a$1(t8, \\"x\\", { enumerable: false, value: t8 }), t8)
      return false;
    return t8.x === t8;
  } catch (t9) {
    return false;
  }
}();
var l$13 = function(t8, r9, e9, n8) {
  var l7;
  (!(r9 in t8) || typeof (l7 = n8) == \\"function\\" && o$13.call(l7) === \\"[object Function]\\" && n8()) && (c$13 ? a$1(t8, r9, { configurable: true, enumerable: false, value: e9, writable: true }) : t8[r9] = e9);
};
var u$13 = function(t8, o8) {
  var a7 = arguments.length > 2 ? arguments[2] : {}, c7 = r$2(o8);
  e$2 && (c7 = n$13.call(c7, Object.getOwnPropertySymbols(o8)));
  for (var u7 = 0; u7 < c7.length; u7 += 1)
    l$13(t8, c7[u7], o8[c7[u7]], a7[c7[u7]]);
};
u$13.supportsDescriptors = !!c$13;
var f$12 = u$13;
var t$12 = function() {
  if (typeof Symbol != \\"function\\" || typeof Object.getOwnPropertySymbols != \\"function\\")
    return false;
  if (typeof Symbol.iterator == \\"symbol\\")
    return true;
  var t8 = {}, e9 = Symbol(\\"test\\"), r9 = Object(e9);
  if (typeof e9 == \\"string\\")
    return false;
  if (Object.prototype.toString.call(e9) !== \\"[object Symbol]\\")
    return false;
  if (Object.prototype.toString.call(r9) !== \\"[object Symbol]\\")
    return false;
  for (e9 in t8[e9] = 42, t8)
    return false;
  if (typeof Object.keys == \\"function\\" && Object.keys(t8).length !== 0)
    return false;
  if (typeof Object.getOwnPropertyNames == \\"function\\" && Object.getOwnPropertyNames(t8).length !== 0)
    return false;
  var o8 = Object.getOwnPropertySymbols(t8);
  if (o8.length !== 1 || o8[0] !== e9)
    return false;
  if (!Object.prototype.propertyIsEnumerable.call(t8, e9))
    return false;
  if (typeof Object.getOwnPropertyDescriptor == \\"function\\") {
    var n8 = Object.getOwnPropertyDescriptor(t8, e9);
    if (n8.value !== 42 || n8.enumerable !== true)
      return false;
  }
  return true;
};
var f$22 = (typeof globalThis != \\"undefined\\" ? globalThis : typeof self != \\"undefined\\" ? self : global).Symbol;
var e$3 = t$12;
var l$2 = function() {
  return typeof f$22 == \\"function\\" && (typeof Symbol == \\"function\\" && (typeof f$22(\\"foo\\") == \\"symbol\\" && (typeof Symbol(\\"bar\\") == \\"symbol\\" && e$3())));
};
var t$22 = \\"Function.prototype.bind called on incompatible \\";
var n$2 = Array.prototype.slice;
var o$22 = Object.prototype.toString;
var r$3 = function(r9) {
  var e9 = this;
  if (typeof e9 != \\"function\\" || o$22.call(e9) !== \\"[object Function]\\")
    throw new TypeError(t$22 + e9);
  for (var p7, i7 = n$2.call(arguments, 1), c7 = function() {
    if (this instanceof p7) {
      var t8 = e9.apply(this, i7.concat(n$2.call(arguments)));
      return Object(t8) === t8 ? t8 : this;
    }
    return e9.apply(r9, i7.concat(n$2.call(arguments)));
  }, a7 = Math.max(0, e9.length - i7.length), l7 = [], u7 = 0; u7 < a7; u7++)
    l7.push(\\"$\\" + u7);
  if (p7 = Function(\\"binder\\", \\"return function (\\" + l7.join(\\",\\") + \\"){ return binder.apply(this,arguments); }\\")(c7), e9.prototype) {
    var y6 = function() {
    };
    y6.prototype = e9.prototype, p7.prototype = new y6(), y6.prototype = null;
  }
  return p7;
};
var e$4 = Function.prototype.bind || r$3;
var o$3 = TypeError;
var t$3 = Object.getOwnPropertyDescriptor;
if (t$3)
  try {
    t$3({}, \\"\\");
  } catch (r9) {
    t$3 = null;
  }
var n$3 = function() {
  throw new o$3();
};
var y$1 = t$3 ? function() {
  try {
    return arguments.callee, n$3;
  } catch (r9) {
    try {
      return t$3(arguments, \\"callee\\").get;
    } catch (r10) {
      return n$3;
    }
  }
}() : n$3;
var a$22 = l$2();
var i$13 = Object.getPrototypeOf || function(r9) {
  return r9.__proto__;
};
var d4 = typeof Uint8Array == \\"undefined\\" ? void 0 : i$13(Uint8Array);
var f$3 = { \\"%Array%\\": Array, \\"%ArrayBuffer%\\": typeof ArrayBuffer == \\"undefined\\" ? void 0 : ArrayBuffer, \\"%ArrayBufferPrototype%\\": typeof ArrayBuffer == \\"undefined\\" ? void 0 : ArrayBuffer.prototype, \\"%ArrayIteratorPrototype%\\": a$22 ? i$13([][Symbol.iterator]()) : void 0, \\"%ArrayPrototype%\\": Array.prototype, \\"%ArrayProto_entries%\\": Array.prototype.entries, \\"%ArrayProto_forEach%\\": Array.prototype.forEach, \\"%ArrayProto_keys%\\": Array.prototype.keys, \\"%ArrayProto_values%\\": Array.prototype.values, \\"%AsyncFromSyncIteratorPrototype%\\": void 0, \\"%AsyncFunction%\\": void 0, \\"%AsyncFunctionPrototype%\\": void 0, \\"%AsyncGenerator%\\": void 0, \\"%AsyncGeneratorFunction%\\": void 0, \\"%AsyncGeneratorPrototype%\\": void 0, \\"%AsyncIteratorPrototype%\\": void 0, \\"%Atomics%\\": typeof Atomics == \\"undefined\\" ? void 0 : Atomics, \\"%Boolean%\\": Boolean, \\"%BooleanPrototype%\\": Boolean.prototype, \\"%DataView%\\": typeof DataView == \\"undefined\\" ? void 0 : DataView, \\"%DataViewPrototype%\\": typeof DataView == \\"undefined\\" ? void 0 : DataView.prototype, \\"%Date%\\": Date, \\"%DatePrototype%\\": Date.prototype, \\"%decodeURI%\\": decodeURI, \\"%decodeURIComponent%\\": decodeURIComponent, \\"%encodeURI%\\": encodeURI, \\"%encodeURIComponent%\\": encodeURIComponent, \\"%Error%\\": Error, \\"%ErrorPrototype%\\": Error.prototype, \\"%eval%\\": eval, \\"%EvalError%\\": EvalError, \\"%EvalErrorPrototype%\\": EvalError.prototype, \\"%Float32Array%\\": typeof Float32Array == \\"undefined\\" ? void 0 : Float32Array, \\"%Float32ArrayPrototype%\\": typeof Float32Array == \\"undefined\\" ? void 0 : Float32Array.prototype, \\"%Float64Array%\\": typeof Float64Array == \\"undefined\\" ? void 0 : Float64Array, \\"%Float64ArrayPrototype%\\": typeof Float64Array == \\"undefined\\" ? void 0 : Float64Array.prototype, \\"%Function%\\": Function, \\"%FunctionPrototype%\\": Function.prototype, \\"%Generator%\\": void 0, \\"%GeneratorFunction%\\": void 0, \\"%GeneratorPrototype%\\": void 0, \\"%Int8Array%\\": typeof Int8Array == \\"undefined\\" ? void 0 : Int8Array, \\"%Int8ArrayPrototype%\\": typeof Int8Array == \\"undefined\\" ? void 0 : Int8Array.prototype, \\"%Int16Array%\\": typeof Int16Array == \\"undefined\\" ? void 0 : Int16Array, \\"%Int16ArrayPrototype%\\": typeof Int16Array == \\"undefined\\" ? void 0 : Int8Array.prototype, \\"%Int32Array%\\": typeof Int32Array == \\"undefined\\" ? void 0 : Int32Array, \\"%Int32ArrayPrototype%\\": typeof Int32Array == \\"undefined\\" ? void 0 : Int32Array.prototype, \\"%isFinite%\\": isFinite, \\"%isNaN%\\": isNaN, \\"%IteratorPrototype%\\": a$22 ? i$13(i$13([][Symbol.iterator]())) : void 0, \\"%JSON%\\": typeof JSON == \\"object\\" ? JSON : void 0, \\"%JSONParse%\\": typeof JSON == \\"object\\" ? JSON.parse : void 0, \\"%Map%\\": typeof Map == \\"undefined\\" ? void 0 : Map, \\"%MapIteratorPrototype%\\": typeof Map != \\"undefined\\" && a$22 ? i$13((/* @__PURE__ */ new Map())[Symbol.iterator]()) : void 0, \\"%MapPrototype%\\": typeof Map == \\"undefined\\" ? void 0 : Map.prototype, \\"%Math%\\": Math, \\"%Number%\\": Number, \\"%NumberPrototype%\\": Number.prototype, \\"%Object%\\": Object, \\"%ObjectPrototype%\\": Object.prototype, \\"%ObjProto_toString%\\": Object.prototype.toString, \\"%ObjProto_valueOf%\\": Object.prototype.valueOf, \\"%parseFloat%\\": parseFloat, \\"%parseInt%\\": parseInt, \\"%Promise%\\": typeof Promise == \\"undefined\\" ? void 0 : Promise, \\"%PromisePrototype%\\": typeof Promise == \\"undefined\\" ? void 0 : Promise.prototype, \\"%PromiseProto_then%\\": typeof Promise == \\"undefined\\" ? void 0 : Promise.prototype.then, \\"%Promise_all%\\": typeof Promise == \\"undefined\\" ? void 0 : Promise.all, \\"%Promise_reject%\\": typeof Promise == \\"undefined\\" ? void 0 : Promise.reject, \\"%Promise_resolve%\\": typeof Promise == \\"undefined\\" ? void 0 : Promise.resolve, \\"%Proxy%\\": typeof Proxy == \\"undefined\\" ? void 0 : Proxy, \\"%RangeError%\\": RangeError, \\"%RangeErrorPrototype%\\": RangeError.prototype, \\"%ReferenceError%\\": ReferenceError, \\"%ReferenceErrorPrototype%\\": ReferenceError.prototype, \\"%Reflect%\\": typeof Reflect == \\"undefined\\" ? void 0 : Reflect, \\"%RegExp%\\": RegExp, \\"%RegExpPrototype%\\": RegExp.prototype, \\"%Set%\\": typeof Set == \\"undefined\\" ? void 0 : Set, \\"%SetIteratorPrototype%\\": typeof Set != \\"undefined\\" && a$22 ? i$13((/* @__PURE__ */ new Set())[Symbol.iterator]()) : void 0, \\"%SetPrototype%\\": typeof Set == \\"undefined\\" ? void 0 : Set.prototype, \\"%SharedArrayBuffer%\\": typeof SharedArrayBuffer == \\"undefined\\" ? void 0 : SharedArrayBuffer, \\"%SharedArrayBufferPrototype%\\": typeof SharedArrayBuffer == \\"undefined\\" ? void 0 : SharedArrayBuffer.prototype, \\"%String%\\": String, \\"%StringIteratorPrototype%\\": a$22 ? i$13(\\"\\"[Symbol.iterator]()) : void 0, \\"%StringPrototype%\\": String.prototype, \\"%Symbol%\\": a$22 ? Symbol : void 0, \\"%SymbolPrototype%\\": a$22 ? Symbol.prototype : void 0, \\"%SyntaxError%\\": SyntaxError, \\"%SyntaxErrorPrototype%\\": SyntaxError.prototype, \\"%ThrowTypeError%\\": y$1, \\"%TypedArray%\\": d4, \\"%TypedArrayPrototype%\\": d4 ? d4.prototype : void 0, \\"%TypeError%\\": o$3, \\"%TypeErrorPrototype%\\": o$3.prototype, \\"%Uint8Array%\\": typeof Uint8Array == \\"undefined\\" ? void 0 : Uint8Array, \\"%Uint8ArrayPrototype%\\": typeof Uint8Array == \\"undefined\\" ? void 0 : Uint8Array.prototype, \\"%Uint8ClampedArray%\\": typeof Uint8ClampedArray == \\"undefined\\" ? void 0 : Uint8ClampedArray, \\"%Uint8ClampedArrayPrototype%\\": typeof Uint8ClampedArray == \\"undefined\\" ? void 0 : Uint8ClampedArray.prototype, \\"%Uint16Array%\\": typeof Uint16Array == \\"undefined\\" ? void 0 : Uint16Array, \\"%Uint16ArrayPrototype%\\": typeof Uint16Array == \\"undefined\\" ? void 0 : Uint16Array.prototype, \\"%Uint32Array%\\": typeof Uint32Array == \\"undefined\\" ? void 0 : Uint32Array, \\"%Uint32ArrayPrototype%\\": typeof Uint32Array == \\"undefined\\" ? void 0 : Uint32Array.prototype, \\"%URIError%\\": URIError, \\"%URIErrorPrototype%\\": URIError.prototype, \\"%WeakMap%\\": typeof WeakMap == \\"undefined\\" ? void 0 : WeakMap, \\"%WeakMapPrototype%\\": typeof WeakMap == \\"undefined\\" ? void 0 : WeakMap.prototype, \\"%WeakSet%\\": typeof WeakSet == \\"undefined\\" ? void 0 : WeakSet, \\"%WeakSetPrototype%\\": typeof WeakSet == \\"undefined\\" ? void 0 : WeakSet.prototype };
var u$22 = e$4.call(Function.call, String.prototype.replace);
var A3 = /[^%.[\\\\]]+|\\\\[(?:(-?\\\\d+(?:\\\\.\\\\d+)?)|([\\"'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2)\\\\]|(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|%$))/g;
var l$3 = /\\\\\\\\(\\\\\\\\)?/g;
var v4 = function(r9) {
  var e9 = [];
  return u$22(r9, A3, function(r10, o8, t8, n8) {
    e9[e9.length] = t8 ? u$22(n8, l$3, \\"$1\\") : o8 || r10;
  }), e9;
};
var P3 = function(r9, e9) {
  if (!(r9 in f$3))
    throw new SyntaxError(\\"intrinsic \\" + r9 + \\" does not exist!\\");
  if (f$3[r9] === void 0 && !e9)
    throw new o$3(\\"intrinsic \\" + r9 + \\" exists, but is not available. Please file an issue!\\");
  return f$3[r9];
};
var c$2 = function(r9, e9) {
  if (typeof r9 != \\"string\\" || r9.length === 0)
    throw new TypeError(\\"intrinsic name must be a non-empty string\\");
  if (arguments.length > 1 && typeof e9 != \\"boolean\\")
    throw new TypeError('\\"allowMissing\\" argument must be a boolean');
  for (var n8 = v4(r9), y6 = P3(\\"%\\" + (n8.length > 0 ? n8[0] : \\"\\") + \\"%\\", e9), a7 = 1; a7 < n8.length; a7 += 1)
    if (y6 != null)
      if (t$3 && a7 + 1 >= n8.length) {
        var i7 = t$3(y6, n8[a7]);
        if (!e9 && !(n8[a7] in y6))
          throw new o$3(\\"base intrinsic for \\" + r9 + \\" exists, but the property is not available.\\");
        y6 = i7 ? i7.get || i7.value : y6[n8[a7]];
      } else
        y6 = y6[n8[a7]];
  return y6;
};
var t$4;
var p$1 = e$4;
var o$4 = c$2(\\"%Function%\\");
var i$2 = o$4.apply;
var a$3 = o$4.call;
(t$4 = function() {
  return p$1.apply(a$3, arguments);
}).apply = function() {
  return p$1.apply(i$2, arguments);
};
var l$4 = t$4;
var r$4;
var n$4;
var i$3 = function(t8) {
  return t8 != t8;
};
var o$5 = (r$4 = function(t8, e9) {
  return t8 === 0 && e9 === 0 ? 1 / t8 == 1 / e9 : t8 === e9 || !(!i$3(t8) || !i$3(e9));
}, r$4);
var c$3 = (n$4 = function() {
  return typeof Object.is == \\"function\\" ? Object.is : o$5;
}, n$4);
var f$4 = f$12;
var u$3 = f$12;
var s$12 = r$4;
var a$4 = n$4;
var l$5 = function() {
  var t8 = c$3();
  return f$4(Object, { is: t8 }, { is: function() {
    return Object.is !== t8;
  } }), t8;
};
var p$2 = l$4(a$4(), Object);
u$3(p$2, { getPolyfill: a$4, implementation: s$12, shim: l$5 });
var m4 = p$2;
N3 = function(r9) {
  return r9 != r9;
};
var N3;
var e$5;
var i$4 = N3;
var n$5 = (e$5 = function() {
  return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN(\\"a\\") ? Number.isNaN : i$4;
}, f$12);
var t$5 = e$5;
var u$4 = f$12;
var a$5 = N3;
var m$1 = e$5;
var o$6 = function() {
  var r9 = t$5();
  return n$5(Number, { isNaN: r9 }, { isNaN: function() {
    return Number.isNaN !== r9;
  } }), r9;
};
var s$2 = m$1();
u$4(s$2, { getPolyfill: m$1, implementation: a$5, shim: o$6 });
var f$5 = s$2;
var c$4 = {};
var a$6 = false;
function i$5() {
  if (a$6)
    return c$4;
  function e9(t8) {
    return (e9 = typeof Symbol == \\"function\\" && typeof Symbol.iterator == \\"symbol\\" ? function(t9) {
      return typeof t9;
    } : function(t9) {
      return t9 && typeof Symbol == \\"function\\" && t9.constructor === Symbol && t9 !== Symbol.prototype ? \\"symbol\\" : typeof t9;
    })(t8);
  }
  function n8(t8, n9) {
    return !n9 || e9(n9) !== \\"object\\" && typeof n9 != \\"function\\" ? function(t9) {
      if (t9 === void 0)
        throw new ReferenceError(\\"this hasn't been initialised - super() hasn't been called\\");
      return t9;
    }(t8) : n9;
  }
  function r9(t8) {
    return (r9 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t9) {
      return t9.__proto__ || Object.getPrototypeOf(t9);
    })(t8);
  }
  function o8(t8, e10) {
    return (o8 = Object.setPrototypeOf || function(t9, e11) {
      return t9.__proto__ = e11, t9;
    })(t8, e10);
  }
  a$6 = true;
  var i7, u7, l7 = {};
  function f7(t8, e10, c7) {
    c7 || (c7 = Error);
    var a7 = function(c8) {
      function a8(o9, c9, i8) {
        var u8;
        return !function(t9, e11) {
          if (!(t9 instanceof e11))
            throw new TypeError(\\"Cannot call a class as a function\\");
        }(this, a8), (u8 = n8(this, r9(a8).call(this, function(t9, n9, r10) {
          return typeof e10 == \\"string\\" ? e10 : e10(t9, n9, r10);
        }(o9, c9, i8)))).code = t8, u8;
      }
      return !function(t9, e11) {
        if (typeof e11 != \\"function\\" && e11 !== null)
          throw new TypeError(\\"Super expression must either be null or a function\\");
        t9.prototype = Object.create(e11 && e11.prototype, { constructor: { value: t9, writable: true, configurable: true } }), e11 && o8(t9, e11);
      }(a8, c8), a8;
    }(c7);
    l7[t8] = a7;
  }
  function s6(t8, e10) {
    if (Array.isArray(t8)) {
      var n9 = t8.length;
      return t8 = t8.map(function(t9) {
        return String(t9);
      }), n9 > 2 ? \\"one of \\".concat(e10, \\" \\").concat(t8.slice(0, n9 - 1).join(\\", \\"), \\", or \\") + t8[n9 - 1] : n9 === 2 ? \\"one of \\".concat(e10, \\" \\").concat(t8[0], \\" or \\").concat(t8[1]) : \\"of \\".concat(e10, \\" \\").concat(t8[0]);
    }
    return \\"of \\".concat(e10, \\" \\").concat(String(t8));
  }
  return f7(\\"ERR_AMBIGUOUS_ARGUMENT\\", 'The \\"%s\\" argument is ambiguous. %s', TypeError), f7(\\"ERR_INVALID_ARG_TYPE\\", function(t8, n9, r10) {
    var o9, c7, u8;
    if (i7 === void 0 && (i7 = tt()), i7(typeof t8 == \\"string\\", \\"'name' must be a string\\"), typeof n9 == \\"string\\" && (c7 = \\"not \\", n9.substr(0, c7.length) === c7) ? (o9 = \\"must not be\\", n9 = n9.replace(/^not /, \\"\\")) : o9 = \\"must be\\", function(t9, e10, n10) {
      return (n10 === void 0 || n10 > t9.length) && (n10 = t9.length), t9.substring(n10 - e10.length, n10) === e10;
    }(t8, \\" argument\\"))
      u8 = \\"The \\".concat(t8, \\" \\").concat(o9, \\" \\").concat(s6(n9, \\"type\\"));
    else {
      var l8 = function(t9, e10, n10) {
        return typeof n10 != \\"number\\" && (n10 = 0), !(n10 + e10.length > t9.length) && t9.indexOf(e10, n10) !== -1;
      }(t8, \\".\\") ? \\"property\\" : \\"argument\\";
      u8 = 'The \\"'.concat(t8, '\\" ').concat(l8, \\" \\").concat(o9, \\" \\").concat(s6(n9, \\"type\\"));
    }
    return u8 += \\". Received type \\".concat(e9(r10));
  }, TypeError), f7(\\"ERR_INVALID_ARG_VALUE\\", function(e10, n9) {
    var r10 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \\"is invalid\\";
    u7 === void 0 && (u7 = X);
    var o9 = u7.inspect(n9);
    return o9.length > 128 && (o9 = \\"\\".concat(o9.slice(0, 128), \\"...\\")), \\"The argument '\\".concat(e10, \\"' \\").concat(r10, \\". Received \\").concat(o9);
  }, TypeError), f7(\\"ERR_INVALID_RETURN_VALUE\\", function(t8, n9, r10) {
    var o9;
    return o9 = r10 && r10.constructor && r10.constructor.name ? \\"instance of \\".concat(r10.constructor.name) : \\"type \\".concat(e9(r10)), \\"Expected \\".concat(t8, ' to be returned from the \\"').concat(n9, '\\"') + \\" function but got \\".concat(o9, \\".\\");
  }, TypeError), f7(\\"ERR_MISSING_ARGS\\", function() {
    for (var t8 = arguments.length, e10 = new Array(t8), n9 = 0; n9 < t8; n9++)
      e10[n9] = arguments[n9];
    i7 === void 0 && (i7 = tt()), i7(e10.length > 0, \\"At least one arg needs to be specified\\");
    var r10 = \\"The \\", o9 = e10.length;
    switch (e10 = e10.map(function(t9) {
      return '\\"'.concat(t9, '\\"');
    }), o9) {
      case 1:
        r10 += \\"\\".concat(e10[0], \\" argument\\");
        break;
      case 2:
        r10 += \\"\\".concat(e10[0], \\" and \\").concat(e10[1], \\" arguments\\");
        break;
      default:
        r10 += e10.slice(0, o9 - 1).join(\\", \\"), r10 += \\", and \\".concat(e10[o9 - 1], \\" arguments\\");
    }
    return \\"\\".concat(r10, \\" must be specified\\");
  }, TypeError), c$4.codes = l7, c$4;
}
var u$5 = {};
var l$6 = false;
function f$6() {
  if (l$6)
    return u$5;
  l$6 = true;
  var n8 = T;
  function r9(t8, e9, n9) {
    return e9 in t8 ? Object.defineProperty(t8, e9, { value: n9, enumerable: true, configurable: true, writable: true }) : t8[e9] = n9, t8;
  }
  function o8(t8, e9) {
    for (var n9 = 0; n9 < e9.length; n9++) {
      var r10 = e9[n9];
      r10.enumerable = r10.enumerable || false, r10.configurable = true, \\"value\\" in r10 && (r10.writable = true), Object.defineProperty(t8, r10.key, r10);
    }
  }
  function c7(t8, e9) {
    return !e9 || y6(e9) !== \\"object\\" && typeof e9 != \\"function\\" ? a7(t8) : e9;
  }
  function a7(t8) {
    if (t8 === void 0)
      throw new ReferenceError(\\"this hasn't been initialised - super() hasn't been called\\");
    return t8;
  }
  function f7(t8) {
    var e9 = typeof Map == \\"function\\" ? /* @__PURE__ */ new Map() : void 0;
    return (f7 = function(t9) {
      if (t9 === null || (n9 = t9, Function.toString.call(n9).indexOf(\\"[native code]\\") === -1))
        return t9;
      var n9;
      if (typeof t9 != \\"function\\")
        throw new TypeError(\\"Super expression must either be null or a function\\");
      if (e9 !== void 0) {
        if (e9.has(t9))
          return e9.get(t9);
        e9.set(t9, r10);
      }
      function r10() {
        return p7(t9, arguments, h8(this).constructor);
      }
      return r10.prototype = Object.create(t9.prototype, { constructor: { value: r10, enumerable: false, writable: true, configurable: true } }), g5(r10, t9);
    })(t8);
  }
  function s6() {
    if (typeof Reflect == \\"undefined\\" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy == \\"function\\")
      return true;
    try {
      return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      })), true;
    } catch (t8) {
      return false;
    }
  }
  function p7(t8, e9, n9) {
    return (p7 = s6() ? Reflect.construct : function(t9, e10, n10) {
      var r10 = [null];
      r10.push.apply(r10, e10);
      var o9 = new (Function.bind.apply(t9, r10))();
      return n10 && g5(o9, n10.prototype), o9;
    }).apply(null, arguments);
  }
  function g5(t8, e9) {
    return (g5 = Object.setPrototypeOf || function(t9, e10) {
      return t9.__proto__ = e10, t9;
    })(t8, e9);
  }
  function h8(t8) {
    return (h8 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t9) {
      return t9.__proto__ || Object.getPrototypeOf(t9);
    })(t8);
  }
  function y6(t8) {
    return (y6 = typeof Symbol == \\"function\\" && typeof Symbol.iterator == \\"symbol\\" ? function(t9) {
      return typeof t9;
    } : function(t9) {
      return t9 && typeof Symbol == \\"function\\" && t9.constructor === Symbol && t9 !== Symbol.prototype ? \\"symbol\\" : typeof t9;
    })(t8);
  }
  var b5 = X.inspect, v6 = i$5().codes.ERR_INVALID_ARG_TYPE;
  function d6(t8, e9, n9) {
    return (n9 === void 0 || n9 > t8.length) && (n9 = t8.length), t8.substring(n9 - e9.length, n9) === e9;
  }
  var m6 = \\"\\", E4 = \\"\\", w4 = \\"\\", S4 = \\"\\", j4 = { deepStrictEqual: \\"Expected values to be strictly deep-equal:\\", strictEqual: \\"Expected values to be strictly equal:\\", strictEqualObject: 'Expected \\"actual\\" to be reference-equal to \\"expected\\":', deepEqual: \\"Expected values to be loosely deep-equal:\\", equal: \\"Expected values to be loosely equal:\\", notDeepStrictEqual: 'Expected \\"actual\\" not to be strictly deep-equal to:', notStrictEqual: 'Expected \\"actual\\" to be strictly unequal to:', notStrictEqualObject: 'Expected \\"actual\\" not to be reference-equal to \\"expected\\":', notDeepEqual: 'Expected \\"actual\\" not to be loosely deep-equal to:', notEqual: 'Expected \\"actual\\" to be loosely unequal to:', notIdentical: \\"Values identical but not reference-equal:\\" };
  function O5(t8) {
    var e9 = Object.keys(t8), n9 = Object.create(Object.getPrototypeOf(t8));
    return e9.forEach(function(e10) {
      n9[e10] = t8[e10];
    }), Object.defineProperty(n9, \\"message\\", { value: t8.message }), n9;
  }
  function x4(t8) {
    return b5(t8, { compact: false, customInspect: false, depth: 1e3, maxArrayLength: 1 / 0, showHidden: false, breakLength: 1 / 0, showProxy: false, sorted: true, getters: true });
  }
  function q3(t8, e9, r10) {
    var o9 = \\"\\", c8 = \\"\\", a8 = 0, i7 = \\"\\", u7 = false, l7 = x4(t8), f8 = l7.split(\\"\\\\n\\"), s7 = x4(e9).split(\\"\\\\n\\"), p8 = 0, g6 = \\"\\";
    if (r10 === \\"strictEqual\\" && y6(t8) === \\"object\\" && y6(e9) === \\"object\\" && t8 !== null && e9 !== null && (r10 = \\"strictEqualObject\\"), f8.length === 1 && s7.length === 1 && f8[0] !== s7[0]) {
      var h9 = f8[0].length + s7[0].length;
      if (h9 <= 10) {
        if (!(y6(t8) === \\"object\\" && t8 !== null || y6(e9) === \\"object\\" && e9 !== null || t8 === 0 && e9 === 0))
          return \\"\\".concat(j4[r10], \\"\\\\n\\\\n\\") + \\"\\".concat(f8[0], \\" !== \\").concat(s7[0], \\"\\\\n\\");
      } else if (r10 !== \\"strictEqualObject\\") {
        if (h9 < (n8.stderr && n8.stderr.isTTY ? n8.stderr.columns : 80)) {
          for (; f8[0][p8] === s7[0][p8]; )
            p8++;
          p8 > 2 && (g6 = \\"\\\\n  \\".concat(function(t9, e10) {
            if (e10 = Math.floor(e10), t9.length == 0 || e10 == 0)
              return \\"\\";
            var n9 = t9.length * e10;
            for (e10 = Math.floor(Math.log(e10) / Math.log(2)); e10; )
              t9 += t9, e10--;
            return t9 += t9.substring(0, n9 - t9.length);
          }(\\" \\", p8), \\"^\\"), p8 = 0);
        }
      }
    }
    for (var b6 = f8[f8.length - 1], v7 = s7[s7.length - 1]; b6 === v7 && (p8++ < 2 ? i7 = \\"\\\\n  \\".concat(b6).concat(i7) : o9 = b6, f8.pop(), s7.pop(), f8.length !== 0 && s7.length !== 0); )
      b6 = f8[f8.length - 1], v7 = s7[s7.length - 1];
    var O6 = Math.max(f8.length, s7.length);
    if (O6 === 0) {
      var q4 = l7.split(\\"\\\\n\\");
      if (q4.length > 30)
        for (q4[26] = \\"\\".concat(m6, \\"...\\").concat(S4); q4.length > 27; )
          q4.pop();
      return \\"\\".concat(j4.notIdentical, \\"\\\\n\\\\n\\").concat(q4.join(\\"\\\\n\\"), \\"\\\\n\\");
    }
    p8 > 3 && (i7 = \\"\\\\n\\".concat(m6, \\"...\\").concat(S4).concat(i7), u7 = true), o9 !== \\"\\" && (i7 = \\"\\\\n  \\".concat(o9).concat(i7), o9 = \\"\\");
    var R5 = 0, A4 = j4[r10] + \\"\\\\n\\".concat(E4, \\"+ actual\\").concat(S4, \\" \\").concat(w4, \\"- expected\\").concat(S4), k4 = \\" \\".concat(m6, \\"...\\").concat(S4, \\" Lines skipped\\");
    for (p8 = 0; p8 < O6; p8++) {
      var _4 = p8 - a8;
      if (f8.length < p8 + 1)
        _4 > 1 && p8 > 2 && (_4 > 4 ? (c8 += \\"\\\\n\\".concat(m6, \\"...\\").concat(S4), u7 = true) : _4 > 3 && (c8 += \\"\\\\n  \\".concat(s7[p8 - 2]), R5++), c8 += \\"\\\\n  \\".concat(s7[p8 - 1]), R5++), a8 = p8, o9 += \\"\\\\n\\".concat(w4, \\"-\\").concat(S4, \\" \\").concat(s7[p8]), R5++;
      else if (s7.length < p8 + 1)
        _4 > 1 && p8 > 2 && (_4 > 4 ? (c8 += \\"\\\\n\\".concat(m6, \\"...\\").concat(S4), u7 = true) : _4 > 3 && (c8 += \\"\\\\n  \\".concat(f8[p8 - 2]), R5++), c8 += \\"\\\\n  \\".concat(f8[p8 - 1]), R5++), a8 = p8, c8 += \\"\\\\n\\".concat(E4, \\"+\\").concat(S4, \\" \\").concat(f8[p8]), R5++;
      else {
        var T5 = s7[p8], P4 = f8[p8], I4 = P4 !== T5 && (!d6(P4, \\",\\") || P4.slice(0, -1) !== T5);
        I4 && d6(T5, \\",\\") && T5.slice(0, -1) === P4 && (I4 = false, P4 += \\",\\"), I4 ? (_4 > 1 && p8 > 2 && (_4 > 4 ? (c8 += \\"\\\\n\\".concat(m6, \\"...\\").concat(S4), u7 = true) : _4 > 3 && (c8 += \\"\\\\n  \\".concat(f8[p8 - 2]), R5++), c8 += \\"\\\\n  \\".concat(f8[p8 - 1]), R5++), a8 = p8, c8 += \\"\\\\n\\".concat(E4, \\"+\\").concat(S4, \\" \\").concat(P4), o9 += \\"\\\\n\\".concat(w4, \\"-\\").concat(S4, \\" \\").concat(T5), R5 += 2) : (c8 += o9, o9 = \\"\\", _4 !== 1 && p8 !== 0 || (c8 += \\"\\\\n  \\".concat(P4), R5++));
      }
      if (R5 > 20 && p8 < O6 - 2)
        return \\"\\".concat(A4).concat(k4, \\"\\\\n\\").concat(c8, \\"\\\\n\\").concat(m6, \\"...\\").concat(S4).concat(o9, \\"\\\\n\\") + \\"\\".concat(m6, \\"...\\").concat(S4);
    }
    return \\"\\".concat(A4).concat(u7 ? k4 : \\"\\", \\"\\\\n\\").concat(c8).concat(o9).concat(i7).concat(g6);
  }
  var R4 = function(t8) {
    function e9(t9) {
      var r10;
      if (!function(t10, e10) {
        if (!(t10 instanceof e10))
          throw new TypeError(\\"Cannot call a class as a function\\");
      }(this, e9), y6(t9) !== \\"object\\" || t9 === null)
        throw new v6(\\"options\\", \\"Object\\", t9);
      var o9 = t9.message, i8 = t9.operator, u8 = t9.stackStartFn, l7 = t9.actual, f8 = t9.expected, s7 = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, o9 != null)
        r10 = c7(this, h8(e9).call(this, String(o9)));
      else if (n8.stderr && n8.stderr.isTTY && (n8.stderr && n8.stderr.getColorDepth && n8.stderr.getColorDepth() !== 1 ? (m6 = \\"\\\\x1B[34m\\", E4 = \\"\\\\x1B[32m\\", S4 = \\"\\\\x1B[39m\\", w4 = \\"\\\\x1B[31m\\") : (m6 = \\"\\", E4 = \\"\\", S4 = \\"\\", w4 = \\"\\")), y6(l7) === \\"object\\" && l7 !== null && y6(f8) === \\"object\\" && f8 !== null && \\"stack\\" in l7 && l7 instanceof Error && \\"stack\\" in f8 && f8 instanceof Error && (l7 = O5(l7), f8 = O5(f8)), i8 === \\"deepStrictEqual\\" || i8 === \\"strictEqual\\")
        r10 = c7(this, h8(e9).call(this, q3(l7, f8, i8)));
      else if (i8 === \\"notDeepStrictEqual\\" || i8 === \\"notStrictEqual\\") {
        var p8 = j4[i8], g6 = x4(l7).split(\\"\\\\n\\");
        if (i8 === \\"notStrictEqual\\" && y6(l7) === \\"object\\" && l7 !== null && (p8 = j4.notStrictEqualObject), g6.length > 30)
          for (g6[26] = \\"\\".concat(m6, \\"...\\").concat(S4); g6.length > 27; )
            g6.pop();
        r10 = g6.length === 1 ? c7(this, h8(e9).call(this, \\"\\".concat(p8, \\" \\").concat(g6[0]))) : c7(this, h8(e9).call(this, \\"\\".concat(p8, \\"\\\\n\\\\n\\").concat(g6.join(\\"\\\\n\\"), \\"\\\\n\\")));
      } else {
        var b6 = x4(l7), d7 = \\"\\", R5 = j4[i8];
        i8 === \\"notDeepEqual\\" || i8 === \\"notEqual\\" ? (b6 = \\"\\".concat(j4[i8], \\"\\\\n\\\\n\\").concat(b6)).length > 1024 && (b6 = \\"\\".concat(b6.slice(0, 1021), \\"...\\")) : (d7 = \\"\\".concat(x4(f8)), b6.length > 512 && (b6 = \\"\\".concat(b6.slice(0, 509), \\"...\\")), d7.length > 512 && (d7 = \\"\\".concat(d7.slice(0, 509), \\"...\\")), i8 === \\"deepEqual\\" || i8 === \\"equal\\" ? b6 = \\"\\".concat(R5, \\"\\\\n\\\\n\\").concat(b6, \\"\\\\n\\\\nshould equal\\\\n\\\\n\\") : d7 = \\" \\".concat(i8, \\" \\").concat(d7)), r10 = c7(this, h8(e9).call(this, \\"\\".concat(b6).concat(d7)));
      }
      return Error.stackTraceLimit = s7, r10.generatedMessage = !o9, Object.defineProperty(a7(r10), \\"name\\", { value: \\"AssertionError [ERR_ASSERTION]\\", enumerable: false, writable: true, configurable: true }), r10.code = \\"ERR_ASSERTION\\", r10.actual = l7, r10.expected = f8, r10.operator = i8, Error.captureStackTrace && Error.captureStackTrace(a7(r10), u8), r10.stack, r10.name = \\"AssertionError\\", c7(r10);
    }
    var i7, u7;
    return !function(t9, e10) {
      if (typeof e10 != \\"function\\" && e10 !== null)
        throw new TypeError(\\"Super expression must either be null or a function\\");
      t9.prototype = Object.create(e10 && e10.prototype, { constructor: { value: t9, writable: true, configurable: true } }), e10 && g5(t9, e10);
    }(e9, t8), i7 = e9, (u7 = [{ key: \\"toString\\", value: function() {
      return \\"\\".concat(this.name, \\" [\\").concat(this.code, \\"]: \\").concat(this.message);
    } }, { key: b5.custom, value: function(t9, e10) {
      return b5(this, function(t10) {
        for (var e11 = 1; e11 < arguments.length; e11++) {
          var n9 = arguments[e11] != null ? arguments[e11] : {}, o9 = Object.keys(n9);
          typeof Object.getOwnPropertySymbols == \\"function\\" && (o9 = o9.concat(Object.getOwnPropertySymbols(n9).filter(function(t11) {
            return Object.getOwnPropertyDescriptor(n9, t11).enumerable;
          }))), o9.forEach(function(e12) {
            r9(t10, e12, n9[e12]);
          });
        }
        return t10;
      }({}, e10, { customInspect: false, depth: 0 }));
    } }]) && o8(i7.prototype, u7), e9;
  }(f7(Error));
  return u$5 = R4;
}
function s$3(t8, e9) {
  return function(t9) {
    if (Array.isArray(t9))
      return t9;
  }(t8) || function(t9, e10) {
    var n8 = [], r9 = true, o8 = false, c7 = void 0;
    try {
      for (var a7, i7 = t9[Symbol.iterator](); !(r9 = (a7 = i7.next()).done) && (n8.push(a7.value), !e10 || n8.length !== e10); r9 = true)
        ;
    } catch (t10) {
      o8 = true, c7 = t10;
    } finally {
      try {
        r9 || i7.return == null || i7.return();
      } finally {
        if (o8)
          throw c7;
      }
    }
    return n8;
  }(t8, e9) || function() {
    throw new TypeError(\\"Invalid attempt to destructure non-iterable instance\\");
  }();
}
function p$3(t8) {
  return (p$3 = typeof Symbol == \\"function\\" && typeof Symbol.iterator == \\"symbol\\" ? function(t9) {
    return typeof t9;
  } : function(t9) {
    return t9 && typeof Symbol == \\"function\\" && t9.constructor === Symbol && t9 !== Symbol.prototype ? \\"symbol\\" : typeof t9;
  })(t8);
}
var g$1 = /a/g.flags !== void 0;
var h$1 = function(t8) {
  var e9 = [];
  return t8.forEach(function(t9) {
    return e9.push(t9);
  }), e9;
};
var y$2 = function(t8) {
  var e9 = [];
  return t8.forEach(function(t9, n8) {
    return e9.push([n8, t9]);
  }), e9;
};
var b$1 = Object.is ? Object.is : m4;
var v$1 = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
  return [];
};
var d$1 = Number.isNaN ? Number.isNaN : f$5;
function m$2(t8) {
  return t8.call.bind(t8);
}
var E3 = m$2(Object.prototype.hasOwnProperty);
var w$1 = m$2(Object.prototype.propertyIsEnumerable);
var S3 = m$2(Object.prototype.toString);
var j$1 = X.types;
var O3 = j$1.isAnyArrayBuffer;
var x3 = j$1.isArrayBufferView;
var q2 = j$1.isDate;
var R3 = j$1.isMap;
var A$1 = j$1.isRegExp;
var k3 = j$1.isSet;
var _3 = j$1.isNativeError;
var T4 = j$1.isBoxedPrimitive;
var P$1 = j$1.isNumberObject;
var I3 = j$1.isStringObject;
var D3 = j$1.isBooleanObject;
var F3 = j$1.isBigIntObject;
var N$1 = j$1.isSymbolObject;
var L3 = j$1.isFloat32Array;
var M3 = j$1.isFloat64Array;
function U3(t8) {
  if (t8.length === 0 || t8.length > 10)
    return true;
  for (var e9 = 0; e9 < t8.length; e9++) {
    var n8 = t8.charCodeAt(e9);
    if (n8 < 48 || n8 > 57)
      return true;
  }
  return t8.length === 10 && t8 >= Math.pow(2, 32);
}
function G2(t8) {
  return Object.keys(t8).filter(U3).concat(v$1(t8).filter(Object.prototype.propertyIsEnumerable.bind(t8)));
}
function V2(t8, e9) {
  if (t8 === e9)
    return 0;
  for (var n8 = t8.length, r9 = e9.length, o8 = 0, c7 = Math.min(n8, r9); o8 < c7; ++o8)
    if (t8[o8] !== e9[o8]) {
      n8 = t8[o8], r9 = e9[o8];
      break;
    }
  return n8 < r9 ? -1 : r9 < n8 ? 1 : 0;
}
function B3(t8, e9, n8, r9) {
  if (t8 === e9)
    return t8 !== 0 || (!n8 || b$1(t8, e9));
  if (n8) {
    if (p$3(t8) !== \\"object\\")
      return typeof t8 == \\"number\\" && d$1(t8) && d$1(e9);
    if (p$3(e9) !== \\"object\\" || t8 === null || e9 === null)
      return false;
    if (Object.getPrototypeOf(t8) !== Object.getPrototypeOf(e9))
      return false;
  } else {
    if (t8 === null || p$3(t8) !== \\"object\\")
      return (e9 === null || p$3(e9) !== \\"object\\") && t8 == e9;
    if (e9 === null || p$3(e9) !== \\"object\\")
      return false;
  }
  var o8, c7, a7, i7, u7 = S3(t8);
  if (u7 !== S3(e9))
    return false;
  if (Array.isArray(t8)) {
    if (t8.length !== e9.length)
      return false;
    var l7 = G2(t8), f7 = G2(e9);
    return l7.length === f7.length && C3(t8, e9, n8, r9, 1, l7);
  }
  if (u7 === \\"[object Object]\\" && (!R3(t8) && R3(e9) || !k3(t8) && k3(e9)))
    return false;
  if (q2(t8)) {
    if (!q2(e9) || Date.prototype.getTime.call(t8) !== Date.prototype.getTime.call(e9))
      return false;
  } else if (A$1(t8)) {
    if (!A$1(e9) || (a7 = t8, i7 = e9, !(g$1 ? a7.source === i7.source && a7.flags === i7.flags : RegExp.prototype.toString.call(a7) === RegExp.prototype.toString.call(i7))))
      return false;
  } else if (_3(t8) || t8 instanceof Error) {
    if (t8.message !== e9.message || t8.name !== e9.name)
      return false;
  } else {
    if (x3(t8)) {
      if (n8 || !L3(t8) && !M3(t8)) {
        if (!function(t9, e10) {
          return t9.byteLength === e10.byteLength && V2(new Uint8Array(t9.buffer, t9.byteOffset, t9.byteLength), new Uint8Array(e10.buffer, e10.byteOffset, e10.byteLength)) === 0;
        }(t8, e9))
          return false;
      } else if (!function(t9, e10) {
        if (t9.byteLength !== e10.byteLength)
          return false;
        for (var n9 = 0; n9 < t9.byteLength; n9++)
          if (t9[n9] !== e10[n9])
            return false;
        return true;
      }(t8, e9))
        return false;
      var s6 = G2(t8), h8 = G2(e9);
      return s6.length === h8.length && C3(t8, e9, n8, r9, 0, s6);
    }
    if (k3(t8))
      return !(!k3(e9) || t8.size !== e9.size) && C3(t8, e9, n8, r9, 2);
    if (R3(t8))
      return !(!R3(e9) || t8.size !== e9.size) && C3(t8, e9, n8, r9, 3);
    if (O3(t8)) {
      if (c7 = e9, (o8 = t8).byteLength !== c7.byteLength || V2(new Uint8Array(o8), new Uint8Array(c7)) !== 0)
        return false;
    } else if (T4(t8) && !function(t9, e10) {
      return P$1(t9) ? P$1(e10) && b$1(Number.prototype.valueOf.call(t9), Number.prototype.valueOf.call(e10)) : I3(t9) ? I3(e10) && String.prototype.valueOf.call(t9) === String.prototype.valueOf.call(e10) : D3(t9) ? D3(e10) && Boolean.prototype.valueOf.call(t9) === Boolean.prototype.valueOf.call(e10) : F3(t9) ? F3(e10) && BigInt.prototype.valueOf.call(t9) === BigInt.prototype.valueOf.call(e10) : N$1(e10) && Symbol.prototype.valueOf.call(t9) === Symbol.prototype.valueOf.call(e10);
    }(t8, e9))
      return false;
  }
  return C3(t8, e9, n8, r9, 0);
}
function z3(t8, e9) {
  return e9.filter(function(e10) {
    return w$1(t8, e10);
  });
}
function C3(t8, e9, n8, r9, o8, c7) {
  if (arguments.length === 5) {
    c7 = Object.keys(t8);
    var a7 = Object.keys(e9);
    if (c7.length !== a7.length)
      return false;
  }
  for (var i7 = 0; i7 < c7.length; i7++)
    if (!E3(e9, c7[i7]))
      return false;
  if (n8 && arguments.length === 5) {
    var u7 = v$1(t8);
    if (u7.length !== 0) {
      var l7 = 0;
      for (i7 = 0; i7 < u7.length; i7++) {
        var f7 = u7[i7];
        if (w$1(t8, f7)) {
          if (!w$1(e9, f7))
            return false;
          c7.push(f7), l7++;
        } else if (w$1(e9, f7))
          return false;
      }
      var s6 = v$1(e9);
      if (u7.length !== s6.length && z3(e9, s6).length !== l7)
        return false;
    } else {
      var p7 = v$1(e9);
      if (p7.length !== 0 && z3(e9, p7).length !== 0)
        return false;
    }
  }
  if (c7.length === 0 && (o8 === 0 || o8 === 1 && t8.length === 0 || t8.size === 0))
    return true;
  if (r9 === void 0)
    r9 = { val1: /* @__PURE__ */ new Map(), val2: /* @__PURE__ */ new Map(), position: 0 };
  else {
    var g5 = r9.val1.get(t8);
    if (g5 !== void 0) {
      var h8 = r9.val2.get(e9);
      if (h8 !== void 0)
        return g5 === h8;
    }
    r9.position++;
  }
  r9.val1.set(t8, r9.position), r9.val2.set(e9, r9.position);
  var y6 = Q2(t8, e9, n8, c7, r9, o8);
  return r9.val1.delete(t8), r9.val2.delete(e9), y6;
}
function Y3(t8, e9, n8, r9) {
  for (var o8 = h$1(t8), c7 = 0; c7 < o8.length; c7++) {
    var a7 = o8[c7];
    if (B3(e9, a7, n8, r9))
      return t8.delete(a7), true;
  }
  return false;
}
function W2(t8) {
  switch (p$3(t8)) {
    case \\"undefined\\":
      return null;
    case \\"object\\":
      return;
    case \\"symbol\\":
      return false;
    case \\"string\\":
      t8 = +t8;
    case \\"number\\":
      if (d$1(t8))
        return false;
  }
  return true;
}
function H2(t8, e9, n8) {
  var r9 = W2(n8);
  return r9 != null ? r9 : e9.has(r9) && !t8.has(r9);
}
function J2(t8, e9, n8, r9, o8) {
  var c7 = W2(n8);
  if (c7 != null)
    return c7;
  var a7 = e9.get(c7);
  return !(a7 === void 0 && !e9.has(c7) || !B3(r9, a7, false, o8)) && (!t8.has(c7) && B3(r9, a7, false, o8));
}
function K2(t8, e9, n8, r9, o8, c7) {
  for (var a7 = h$1(t8), i7 = 0; i7 < a7.length; i7++) {
    var u7 = a7[i7];
    if (B3(n8, u7, o8, c7) && B3(r9, e9.get(u7), o8, c7))
      return t8.delete(u7), true;
  }
  return false;
}
function Q2(t8, e9, n8, r9, o8, c7) {
  var a7 = 0;
  if (c7 === 2) {
    if (!function(t9, e10, n9, r10) {
      for (var o9 = null, c8 = h$1(t9), a8 = 0; a8 < c8.length; a8++) {
        var i8 = c8[a8];
        if (p$3(i8) === \\"object\\" && i8 !== null)
          o9 === null && (o9 = /* @__PURE__ */ new Set()), o9.add(i8);
        else if (!e10.has(i8)) {
          if (n9)
            return false;
          if (!H2(t9, e10, i8))
            return false;
          o9 === null && (o9 = /* @__PURE__ */ new Set()), o9.add(i8);
        }
      }
      if (o9 !== null) {
        for (var u8 = h$1(e10), l8 = 0; l8 < u8.length; l8++) {
          var f7 = u8[l8];
          if (p$3(f7) === \\"object\\" && f7 !== null) {
            if (!Y3(o9, f7, n9, r10))
              return false;
          } else if (!n9 && !t9.has(f7) && !Y3(o9, f7, n9, r10))
            return false;
        }
        return o9.size === 0;
      }
      return true;
    }(t8, e9, n8, o8))
      return false;
  } else if (c7 === 3) {
    if (!function(t9, e10, n9, r10) {
      for (var o9 = null, c8 = y$2(t9), a8 = 0; a8 < c8.length; a8++) {
        var i8 = s$3(c8[a8], 2), u8 = i8[0], l8 = i8[1];
        if (p$3(u8) === \\"object\\" && u8 !== null)
          o9 === null && (o9 = /* @__PURE__ */ new Set()), o9.add(u8);
        else {
          var f7 = e10.get(u8);
          if (f7 === void 0 && !e10.has(u8) || !B3(l8, f7, n9, r10)) {
            if (n9)
              return false;
            if (!J2(t9, e10, u8, l8, r10))
              return false;
            o9 === null && (o9 = /* @__PURE__ */ new Set()), o9.add(u8);
          }
        }
      }
      if (o9 !== null) {
        for (var g5 = y$2(e10), h8 = 0; h8 < g5.length; h8++) {
          var b5 = s$3(g5[h8], 2), v6 = (u8 = b5[0], b5[1]);
          if (p$3(u8) === \\"object\\" && u8 !== null) {
            if (!K2(o9, t9, u8, v6, n9, r10))
              return false;
          } else if (!(n9 || t9.has(u8) && B3(t9.get(u8), v6, false, r10) || K2(o9, t9, u8, v6, false, r10)))
            return false;
        }
        return o9.size === 0;
      }
      return true;
    }(t8, e9, n8, o8))
      return false;
  } else if (c7 === 1)
    for (; a7 < t8.length; a7++) {
      if (!E3(t8, a7)) {
        if (E3(e9, a7))
          return false;
        for (var i7 = Object.keys(t8); a7 < i7.length; a7++) {
          var u7 = i7[a7];
          if (!E3(e9, u7) || !B3(t8[u7], e9[u7], n8, o8))
            return false;
        }
        return i7.length === Object.keys(e9).length;
      }
      if (!E3(e9, a7) || !B3(t8[a7], e9[a7], n8, o8))
        return false;
    }
  for (a7 = 0; a7 < r9.length; a7++) {
    var l7 = r9[a7];
    if (!B3(t8[l7], e9[l7], n8, o8))
      return false;
  }
  return true;
}
var X2 = { isDeepEqual: function(t8, e9) {
  return B3(t8, e9, false);
}, isDeepStrictEqual: function(t8, e9) {
  return B3(t8, e9, true);
} };
var Z2 = {};
var $$1 = false;
function tt() {
  if ($$1)
    return Z2;
  $$1 = true;
  var o8 = T;
  function c7(t8) {
    return (c7 = typeof Symbol == \\"function\\" && typeof Symbol.iterator == \\"symbol\\" ? function(t9) {
      return typeof t9;
    } : function(t9) {
      return t9 && typeof Symbol == \\"function\\" && t9.constructor === Symbol && t9 !== Symbol.prototype ? \\"symbol\\" : typeof t9;
    })(t8);
  }
  var a7, u7, l7 = i$5().codes, s6 = l7.ERR_AMBIGUOUS_ARGUMENT, p7 = l7.ERR_INVALID_ARG_TYPE, g5 = l7.ERR_INVALID_ARG_VALUE, h8 = l7.ERR_INVALID_RETURN_VALUE, y6 = l7.ERR_MISSING_ARGS, b5 = f$6(), v6 = X.inspect, d6 = X.types, m$12 = d6.isPromise, E4 = d6.isRegExp, w4 = Object.assign ? Object.assign : r5.assign, S4 = Object.is ? Object.is : m4;
  function j4() {
    a7 = X2.isDeepEqual, u7 = X2.isDeepStrictEqual;
  }
  var O5 = false, x4 = Z2 = k4, q3 = {};
  function R4(t8) {
    if (t8.message instanceof Error)
      throw t8.message;
    throw new b5(t8);
  }
  function A4(t8, e9, n8, r9) {
    if (!n8) {
      var o9 = false;
      if (e9 === 0)
        o9 = true, r9 = \\"No value argument passed to \`assert.ok()\`\\";
      else if (r9 instanceof Error)
        throw r9;
      var c8 = new b5({ actual: n8, expected: true, message: r9, operator: \\"==\\", stackStartFn: t8 });
      throw c8.generatedMessage = o9, c8;
    }
  }
  function k4() {
    for (var t8 = arguments.length, e9 = new Array(t8), n8 = 0; n8 < t8; n8++)
      e9[n8] = arguments[n8];
    A4.apply(void 0, [k4, e9.length].concat(e9));
  }
  x4.fail = function t8(e9, n8, r9, c8, a8) {
    var i7, u8 = arguments.length;
    if (u8 === 0)
      i7 = \\"Failed\\";
    else if (u8 === 1)
      r9 = e9, e9 = void 0;
    else {
      if (O5 === false) {
        O5 = true;
        var l8 = o8.emitWarning ? o8.emitWarning : console.warn.bind(console);
        l8(\\"assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.\\", \\"DeprecationWarning\\", \\"DEP0094\\");
      }
      u8 === 2 && (c8 = \\"!=\\");
    }
    if (r9 instanceof Error)
      throw r9;
    var f7 = { actual: e9, expected: n8, operator: c8 === void 0 ? \\"fail\\" : c8, stackStartFn: a8 || t8 };
    r9 !== void 0 && (f7.message = r9);
    var s7 = new b5(f7);
    throw i7 && (s7.message = i7, s7.generatedMessage = true), s7;
  }, x4.AssertionError = b5, x4.ok = k4, x4.equal = function t8(e9, n8, r9) {
    if (arguments.length < 2)
      throw new y6(\\"actual\\", \\"expected\\");
    e9 != n8 && R4({ actual: e9, expected: n8, message: r9, operator: \\"==\\", stackStartFn: t8 });
  }, x4.notEqual = function t8(e9, n8, r9) {
    if (arguments.length < 2)
      throw new y6(\\"actual\\", \\"expected\\");
    e9 == n8 && R4({ actual: e9, expected: n8, message: r9, operator: \\"!=\\", stackStartFn: t8 });
  }, x4.deepEqual = function t8(e9, n8, r9) {
    if (arguments.length < 2)
      throw new y6(\\"actual\\", \\"expected\\");
    a7 === void 0 && j4(), a7(e9, n8) || R4({ actual: e9, expected: n8, message: r9, operator: \\"deepEqual\\", stackStartFn: t8 });
  }, x4.notDeepEqual = function t8(e9, n8, r9) {
    if (arguments.length < 2)
      throw new y6(\\"actual\\", \\"expected\\");
    a7 === void 0 && j4(), a7(e9, n8) && R4({ actual: e9, expected: n8, message: r9, operator: \\"notDeepEqual\\", stackStartFn: t8 });
  }, x4.deepStrictEqual = function t8(e9, n8, r9) {
    if (arguments.length < 2)
      throw new y6(\\"actual\\", \\"expected\\");
    a7 === void 0 && j4(), u7(e9, n8) || R4({ actual: e9, expected: n8, message: r9, operator: \\"deepStrictEqual\\", stackStartFn: t8 });
  }, x4.notDeepStrictEqual = function t8(e9, n8, r9) {
    if (arguments.length < 2)
      throw new y6(\\"actual\\", \\"expected\\");
    a7 === void 0 && j4();
    u7(e9, n8) && R4({ actual: e9, expected: n8, message: r9, operator: \\"notDeepStrictEqual\\", stackStartFn: t8 });
  }, x4.strictEqual = function t8(e9, n8, r9) {
    if (arguments.length < 2)
      throw new y6(\\"actual\\", \\"expected\\");
    S4(e9, n8) || R4({ actual: e9, expected: n8, message: r9, operator: \\"strictEqual\\", stackStartFn: t8 });
  }, x4.notStrictEqual = function t8(e9, n8, r9) {
    if (arguments.length < 2)
      throw new y6(\\"actual\\", \\"expected\\");
    S4(e9, n8) && R4({ actual: e9, expected: n8, message: r9, operator: \\"notStrictEqual\\", stackStartFn: t8 });
  };
  var _4 = function t8(e9, n8, r9) {
    var o9 = this;
    !function(t9, e10) {
      if (!(t9 instanceof e10))
        throw new TypeError(\\"Cannot call a class as a function\\");
    }(this, t8), n8.forEach(function(t9) {
      t9 in e9 && (r9 !== void 0 && typeof r9[t9] == \\"string\\" && E4(e9[t9]) && e9[t9].test(r9[t9]) ? o9[t9] = r9[t9] : o9[t9] = e9[t9]);
    });
  };
  function T5(t8, e9, n8, r9, o9, c8) {
    if (!(n8 in t8) || !u7(t8[n8], e9[n8])) {
      if (!r9) {
        var a8 = new _4(t8, o9), i7 = new _4(e9, o9, t8), l8 = new b5({ actual: a8, expected: i7, operator: \\"deepStrictEqual\\", stackStartFn: c8 });
        throw l8.actual = t8, l8.expected = e9, l8.operator = c8.name, l8;
      }
      R4({ actual: t8, expected: e9, message: r9, operator: c8.name, stackStartFn: c8 });
    }
  }
  function P4(t8, e9, n8, r9) {
    if (typeof e9 != \\"function\\") {
      if (E4(e9))
        return e9.test(t8);
      if (arguments.length === 2)
        throw new p7(\\"expected\\", [\\"Function\\", \\"RegExp\\"], e9);
      if (c7(t8) !== \\"object\\" || t8 === null) {
        var o9 = new b5({ actual: t8, expected: e9, message: n8, operator: \\"deepStrictEqual\\", stackStartFn: r9 });
        throw o9.operator = r9.name, o9;
      }
      var i7 = Object.keys(e9);
      if (e9 instanceof Error)
        i7.push(\\"name\\", \\"message\\");
      else if (i7.length === 0)
        throw new g5(\\"error\\", e9, \\"may not be an empty object\\");
      return a7 === void 0 && j4(), i7.forEach(function(o10) {
        typeof t8[o10] == \\"string\\" && E4(e9[o10]) && e9[o10].test(t8[o10]) || T5(t8, e9, o10, n8, i7, r9);
      }), true;
    }
    return e9.prototype !== void 0 && t8 instanceof e9 || !Error.isPrototypeOf(e9) && e9.call({}, t8) === true;
  }
  function I4(t8) {
    if (typeof t8 != \\"function\\")
      throw new p7(\\"fn\\", \\"Function\\", t8);
    try {
      t8();
    } catch (t9) {
      return t9;
    }
    return q3;
  }
  function D4(t8) {
    return m$12(t8) || t8 !== null && c7(t8) === \\"object\\" && typeof t8.then == \\"function\\" && typeof t8.catch == \\"function\\";
  }
  function F4(t8) {
    return Promise.resolve().then(function() {
      var e9;
      if (typeof t8 == \\"function\\") {
        if (!D4(e9 = t8()))
          throw new h8(\\"instance of Promise\\", \\"promiseFn\\", e9);
      } else {
        if (!D4(t8))
          throw new p7(\\"promiseFn\\", [\\"Function\\", \\"Promise\\"], t8);
        e9 = t8;
      }
      return Promise.resolve().then(function() {
        return e9;
      }).then(function() {
        return q3;
      }).catch(function(t9) {
        return t9;
      });
    });
  }
  function N4(t8, e9, n8, r9) {
    if (typeof n8 == \\"string\\") {
      if (arguments.length === 4)
        throw new p7(\\"error\\", [\\"Object\\", \\"Error\\", \\"Function\\", \\"RegExp\\"], n8);
      if (c7(e9) === \\"object\\" && e9 !== null) {
        if (e9.message === n8)
          throw new s6(\\"error/message\\", 'The error message \\"'.concat(e9.message, '\\" is identical to the message.'));
      } else if (e9 === n8)
        throw new s6(\\"error/message\\", 'The error \\"'.concat(e9, '\\" is identical to the message.'));
      r9 = n8, n8 = void 0;
    } else if (n8 != null && c7(n8) !== \\"object\\" && typeof n8 != \\"function\\")
      throw new p7(\\"error\\", [\\"Object\\", \\"Error\\", \\"Function\\", \\"RegExp\\"], n8);
    if (e9 === q3) {
      var o9 = \\"\\";
      n8 && n8.name && (o9 += \\" (\\".concat(n8.name, \\")\\")), o9 += r9 ? \\": \\".concat(r9) : \\".\\";
      var a8 = t8.name === \\"rejects\\" ? \\"rejection\\" : \\"exception\\";
      R4({ actual: void 0, expected: n8, operator: t8.name, message: \\"Missing expected \\".concat(a8).concat(o9), stackStartFn: t8 });
    }
    if (n8 && !P4(e9, n8, r9, t8))
      throw e9;
  }
  function L4(t8, e9, n8, r9) {
    if (e9 !== q3) {
      if (typeof n8 == \\"string\\" && (r9 = n8, n8 = void 0), !n8 || P4(e9, n8)) {
        var o9 = r9 ? \\": \\".concat(r9) : \\".\\", c8 = t8.name === \\"doesNotReject\\" ? \\"rejection\\" : \\"exception\\";
        R4({ actual: e9, expected: n8, operator: t8.name, message: \\"Got unwanted \\".concat(c8).concat(o9, \\"\\\\n\\") + 'Actual message: \\"'.concat(e9 && e9.message, '\\"'), stackStartFn: t8 });
      }
      throw e9;
    }
  }
  function M4() {
    for (var t8 = arguments.length, e9 = new Array(t8), n8 = 0; n8 < t8; n8++)
      e9[n8] = arguments[n8];
    A4.apply(void 0, [M4, e9.length].concat(e9));
  }
  return x4.throws = function t8(e9) {
    for (var n8 = arguments.length, r9 = new Array(n8 > 1 ? n8 - 1 : 0), o9 = 1; o9 < n8; o9++)
      r9[o9 - 1] = arguments[o9];
    N4.apply(void 0, [t8, I4(e9)].concat(r9));
  }, x4.rejects = function t8(e9) {
    for (var n8 = arguments.length, r9 = new Array(n8 > 1 ? n8 - 1 : 0), o9 = 1; o9 < n8; o9++)
      r9[o9 - 1] = arguments[o9];
    return F4(e9).then(function(e10) {
      return N4.apply(void 0, [t8, e10].concat(r9));
    });
  }, x4.doesNotThrow = function t8(e9) {
    for (var n8 = arguments.length, r9 = new Array(n8 > 1 ? n8 - 1 : 0), o9 = 1; o9 < n8; o9++)
      r9[o9 - 1] = arguments[o9];
    L4.apply(void 0, [t8, I4(e9)].concat(r9));
  }, x4.doesNotReject = function t8(e9) {
    for (var n8 = arguments.length, r9 = new Array(n8 > 1 ? n8 - 1 : 0), o9 = 1; o9 < n8; o9++)
      r9[o9 - 1] = arguments[o9];
    return F4(e9).then(function(e10) {
      return L4.apply(void 0, [t8, e10].concat(r9));
    });
  }, x4.ifError = function t8(e9) {
    if (e9 != null) {
      var n8 = \\"ifError got unwanted exception: \\";
      c7(e9) === \\"object\\" && typeof e9.message == \\"string\\" ? e9.message.length === 0 && e9.constructor ? n8 += e9.constructor.name : n8 += e9.message : n8 += v6(e9);
      var r9 = new b5({ actual: e9, expected: null, operator: \\"ifError\\", message: n8, stackStartFn: t8 }), o9 = e9.stack;
      if (typeof o9 == \\"string\\") {
        var a8 = o9.split(\\"\\\\n\\");
        a8.shift();
        for (var i7 = r9.stack.split(\\"\\\\n\\"), u8 = 0; u8 < a8.length; u8++) {
          var l8 = i7.indexOf(a8[u8]);
          if (l8 !== -1) {
            i7 = i7.slice(0, l8);
            break;
          }
        }
        r9.stack = \\"\\".concat(i7.join(\\"\\\\n\\"), \\"\\\\n\\").concat(a8.join(\\"\\\\n\\"));
      }
      throw r9;
    }
  }, x4.strict = w4(M4, x4, { equal: x4.strictEqual, deepEqual: x4.deepStrictEqual, notEqual: x4.notStrictEqual, notDeepEqual: x4.notDeepStrictEqual }), x4.strict.strict = x4.strict, Z2;
}
var et = tt();
et.AssertionError;
et.deepEqual;
et.deepStrictEqual;
et.doesNotReject;
et.doesNotThrow;
et.equal;
et.fail;
et.ifError;
et.notDeepEqual;
et.notDeepStrictEqual;
et.notEqual;
et.notStrictEqual;
et.ok;
et.rejects;
et.strict;
et.strictEqual;
et.throws;
et.AssertionError;
et.deepEqual;
et.deepStrictEqual;
et.doesNotReject;
et.doesNotThrow;
et.equal;
et.fail;
et.ifError;
et.notDeepEqual;
et.notDeepStrictEqual;
et.notEqual;
et.notStrictEqual;
et.ok;
et.rejects;
et.strict;
et.strictEqual;
et.throws;
var AssertionError = et.AssertionError;
var deepEqual = et.deepEqual;
var deepStrictEqual = et.deepStrictEqual;
var doesNotReject = et.doesNotReject;
var doesNotThrow = et.doesNotThrow;
var equal = et.equal;
var fail = et.fail;
var ifError = et.ifError;
var notDeepEqual = et.notDeepEqual;
var notDeepStrictEqual = et.notDeepStrictEqual;
var notEqual = et.notEqual;
var notStrictEqual = et.notStrictEqual;
var ok = et.ok;
var rejects = et.rejects;
var strict = et.strict;
var strictEqual = et.strictEqual;
var throws = et.throws;

// node_modules/.pnpm/@jspm+core@2.0.0-beta.24/node_modules/@jspm/core/nodelibs/browser/util.js
var _extend2 = X._extend;
var callbackify2 = X.callbackify;
var debuglog2 = X.debuglog;
var deprecate2 = X.deprecate;
var format2 = X.format;
var inherits2 = X.inherits;
var inspect2 = X.inspect;
var isArray2 = X.isArray;
var isBoolean2 = X.isBoolean;
var isBuffer2 = X.isBuffer;
var isDate2 = X.isDate;
var isError2 = X.isError;
var isFunction2 = X.isFunction;
var isNull2 = X.isNull;
var isNullOrUndefined2 = X.isNullOrUndefined;
var isNumber2 = X.isNumber;
var isObject2 = X.isObject;
var isPrimitive2 = X.isPrimitive;
var isRegExp2 = X.isRegExp;
var isString2 = X.isString;
var isSymbol2 = X.isSymbol;
var isUndefined2 = X.isUndefined;
var log2 = X.log;
var promisify2 = X.promisify;
var types2 = X.types;
var TextEncoder2 = X.TextEncoder = globalThis.TextEncoder;
var TextDecoder3 = X.TextDecoder = globalThis.TextDecoder;

// node_modules/.pnpm/@jspm+core@2.0.0-beta.24/node_modules/@jspm/core/nodelibs/browser/chunk-23dbec7b.js
var exports$12 = {};
var _dewExec3 = false;
function dew3() {
  if (_dewExec3)
    return exports$12;
  _dewExec3 = true;
  var process$1 = process;
  function assertPath(path2) {
    if (typeof path2 !== \\"string\\") {
      throw new TypeError(\\"Path must be a string. Received \\" + JSON.stringify(path2));
    }
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    var res = \\"\\";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i7 = 0; i7 <= path2.length; ++i7) {
      if (i7 < path2.length)
        code = path2.charCodeAt(i7);
      else if (code === 47)
        break;
      else
        code = 47;
      if (code === 47) {
        if (lastSlash === i7 - 1 || dots === 1)
          ;
        else if (lastSlash !== i7 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf(\\"/\\");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = \\"\\";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf(\\"/\\");
                }
                lastSlash = i7;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = \\"\\";
              lastSegmentLength = 0;
              lastSlash = i7;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0)
              res += \\"/..\\";
            else
              res = \\"..\\";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0)
            res += \\"/\\" + path2.slice(lastSlash + 1, i7);
          else
            res = path2.slice(lastSlash + 1, i7);
          lastSegmentLength = i7 - lastSlash - 1;
        }
        lastSlash = i7;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep2, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || \\"\\") + (pathObject.ext || \\"\\");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep2 + base;
  }
  var posix2 = {
    resolve: function resolve3() {
      var resolvedPath = \\"\\";
      var resolvedAbsolute = false;
      var cwd;
      for (var i7 = arguments.length - 1; i7 >= -1 && !resolvedAbsolute; i7--) {
        var path2;
        if (i7 >= 0)
          path2 = arguments[i7];
        else {
          if (cwd === void 0)
            cwd = process$1.cwd();
          path2 = cwd;
        }
        assertPath(path2);
        if (path2.length === 0) {
          continue;
        }
        resolvedPath = path2 + \\"/\\" + resolvedPath;
        resolvedAbsolute = path2.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0)
          return \\"/\\" + resolvedPath;
        else
          return \\"/\\";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return \\".\\";
      }
    },
    normalize: function normalize2(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return \\".\\";
      var isAbsolute2 = path2.charCodeAt(0) === 47;
      var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
      path2 = normalizeStringPosix(path2, !isAbsolute2);
      if (path2.length === 0 && !isAbsolute2)
        path2 = \\".\\";
      if (path2.length > 0 && trailingSeparator)
        path2 += \\"/\\";
      if (isAbsolute2)
        return \\"/\\" + path2;
      return path2;
    },
    isAbsolute: function isAbsolute2(path2) {
      assertPath(path2);
      return path2.length > 0 && path2.charCodeAt(0) === 47;
    },
    join: function join2() {
      if (arguments.length === 0)
        return \\".\\";
      var joined;
      for (var i7 = 0; i7 < arguments.length; ++i7) {
        var arg = arguments[i7];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else
            joined += \\"/\\" + arg;
        }
      }
      if (joined === void 0)
        return \\".\\";
      return posix2.normalize(joined);
    },
    relative: function relative2(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to)
        return \\"\\";
      from = posix2.resolve(from);
      to = posix2.resolve(to);
      if (from === to)
        return \\"\\";
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47)
          break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47)
          break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i7 = 0;
      for (; i7 <= length; ++i7) {
        if (i7 === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i7) === 47) {
              return to.slice(toStart + i7 + 1);
            } else if (i7 === 0) {
              return to.slice(toStart + i7);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i7) === 47) {
              lastCommonSep = i7;
            } else if (i7 === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i7);
        var toCode = to.charCodeAt(toStart + i7);
        if (fromCode !== toCode)
          break;
        else if (fromCode === 47)
          lastCommonSep = i7;
      }
      var out = \\"\\";
      for (i7 = fromStart + lastCommonSep + 1; i7 <= fromEnd; ++i7) {
        if (i7 === fromEnd || from.charCodeAt(i7) === 47) {
          if (out.length === 0)
            out += \\"..\\";
          else
            out += \\"/..\\";
        }
      }
      if (out.length > 0)
        return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47)
          ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong2(path2) {
      return path2;
    },
    dirname: function dirname2(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return \\".\\";
      var code = path2.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i7 = path2.length - 1; i7 >= 1; --i7) {
        code = path2.charCodeAt(i7);
        if (code === 47) {
          if (!matchedSlash) {
            end = i7;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1)
        return hasRoot ? \\"/\\" : \\".\\";
      if (hasRoot && end === 1)
        return \\"//\\";
      return path2.slice(0, end);
    },
    basename: function basename2(path2, ext) {
      if (ext !== void 0 && typeof ext !== \\"string\\")
        throw new TypeError('\\"ext\\" argument must be a string');
      assertPath(path2);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i7;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2)
          return \\"\\";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i7 = path2.length - 1; i7 >= 0; --i7) {
          var code = path2.charCodeAt(i7);
          if (code === 47) {
            if (!matchedSlash) {
              start = i7 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i7 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i7;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end)
          end = firstNonSlashEnd;
        else if (end === -1)
          end = path2.length;
        return path2.slice(start, end);
      } else {
        for (i7 = path2.length - 1; i7 >= 0; --i7) {
          if (path2.charCodeAt(i7) === 47) {
            if (!matchedSlash) {
              start = i7 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i7 + 1;
          }
        }
        if (end === -1)
          return \\"\\";
        return path2.slice(start, end);
      }
    },
    extname: function extname2(path2) {
      assertPath(path2);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i7 = path2.length - 1; i7 >= 0; --i7) {
        var code = path2.charCodeAt(i7);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i7 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i7 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i7;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return \\"\\";
      }
      return path2.slice(startDot, end);
    },
    format: function format5(pathObject) {
      if (pathObject === null || typeof pathObject !== \\"object\\") {
        throw new TypeError('The \\"pathObject\\" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format(\\"/\\", pathObject);
    },
    parse: function parse3(path2) {
      assertPath(path2);
      var ret = {
        root: \\"\\",
        dir: \\"\\",
        base: \\"\\",
        ext: \\"\\",
        name: \\"\\"
      };
      if (path2.length === 0)
        return ret;
      var code = path2.charCodeAt(0);
      var isAbsolute2 = code === 47;
      var start;
      if (isAbsolute2) {
        ret.root = \\"/\\";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i7 = path2.length - 1;
      var preDotState = 0;
      for (; i7 >= start; --i7) {
        code = path2.charCodeAt(i7);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i7 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i7 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i7;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute2)
            ret.base = ret.name = path2.slice(1, end);
          else
            ret.base = ret.name = path2.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute2) {
          ret.name = path2.slice(1, startDot);
          ret.base = path2.slice(1, end);
        } else {
          ret.name = path2.slice(startPart, startDot);
          ret.base = path2.slice(startPart, end);
        }
        ret.ext = path2.slice(startDot, end);
      }
      if (startPart > 0)
        ret.dir = path2.slice(0, startPart - 1);
      else if (isAbsolute2)
        ret.dir = \\"/\\";
      return ret;
    },
    sep: \\"/\\",
    delimiter: \\":\\",
    win32: null,
    posix: null
  };
  posix2.posix = posix2;
  exports$12 = posix2;
  return exports$12;
}
var exports3 = dew3();

// node_modules/.pnpm/@jspm+core@2.0.0-beta.24/node_modules/@jspm/core/nodelibs/browser/path.js
var _makeLong = exports3._makeLong;
var basename = exports3.basename;
var delimiter = exports3.delimiter;
var dirname = exports3.dirname;
var extname = exports3.extname;
var format3 = exports3.format;
var isAbsolute = exports3.isAbsolute;
var join = exports3.join;
var normalize = exports3.normalize;
var parse = exports3.parse;
var posix = exports3.posix;
var relative = exports3.relative;
var resolve = exports3.resolve;
var sep = exports3.sep;
var win32 = exports3.win32;

// node_modules/.pnpm/@jspm+core@2.0.0-beta.24/node_modules/@jspm/core/nodelibs/browser/events.js
y.once = function(emitter, event) {
  return new Promise((resolve3, reject) => {
    function eventListener(...args) {
      if (errorListener !== void 0) {
        emitter.removeListener(\\"error\\", errorListener);
      }
      resolve3(args);
    }
    let errorListener;
    if (event !== \\"error\\") {
      errorListener = (err) => {
        emitter.removeListener(name, eventListener);
        reject(err);
      };
      emitter.once(\\"error\\", errorListener);
    }
    emitter.once(event, eventListener);
  });
};
y.on = function(emitter, event) {
  const unconsumedEventValues = [];
  const unconsumedPromises = [];
  let error = null;
  let finished2 = false;
  const iterator = {
    async next() {
      const value = unconsumedEventValues.shift();
      if (value) {
        return createIterResult(value, false);
      }
      if (error) {
        const p7 = Promise.reject(error);
        error = null;
        return p7;
      }
      if (finished2) {
        return createIterResult(void 0, true);
      }
      return new Promise((resolve3, reject) => unconsumedPromises.push({ resolve: resolve3, reject }));
    },
    async return() {
      emitter.removeListener(event, eventHandler);
      emitter.removeListener(\\"error\\", errorHandler);
      finished2 = true;
      for (const promise of unconsumedPromises) {
        promise.resolve(createIterResult(void 0, true));
      }
      return createIterResult(void 0, true);
    },
    throw(err) {
      error = err;
      emitter.removeListener(event, eventHandler);
      emitter.removeListener(\\"error\\", errorHandler);
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
  emitter.on(event, eventHandler);
  emitter.on(\\"error\\", errorHandler);
  return iterator;
  function eventHandler(...args) {
    const promise = unconsumedPromises.shift();
    if (promise) {
      promise.resolve(createIterResult(args, false));
    } else {
      unconsumedEventValues.push(args);
    }
  }
  function errorHandler(err) {
    finished2 = true;
    const toError = unconsumedPromises.shift();
    if (toError) {
      toError.reject(err);
    } else {
      error = err;
    }
    iterator.return();
  }
};
var {
  EventEmitter,
  defaultMaxListeners,
  init,
  listenerCount,
  on,
  once
} = y;

// node_modules/.pnpm/@jspm+core@2.0.0-beta.24/node_modules/@jspm/core/nodelibs/browser/chunk-6c718bbe.js
var exports$13 = {};
var _dewExec4 = false;
var _global3 = typeof globalThis !== \\"undefined\\" ? globalThis : typeof self !== \\"undefined\\" ? self : global;
function dew4() {
  if (_dewExec4)
    return exports$13;
  _dewExec4 = true;
  exports$13 = Stream2;
  var EE = y.EventEmitter;
  var inherits3 = dew$f();
  inherits3(Stream2, EE);
  Stream2.Readable = dew$3();
  Stream2.Writable = dew$8();
  Stream2.Duplex = dew$7();
  Stream2.Transform = dew$2();
  Stream2.PassThrough = dew$1();
  Stream2.finished = dew$6();
  Stream2.pipeline = dew2();
  Stream2.Stream = Stream2;
  function Stream2() {
    EE.call(this || _global3);
  }
  Stream2.prototype.pipe = function(dest, options) {
    var source = this || _global3;
    function ondata(chunk) {
      if (dest.writable) {
        if (dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
    }
    source.on(\\"data\\", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on(\\"drain\\", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on(\\"end\\", onend);
      source.on(\\"close\\", onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      if (typeof dest.destroy === \\"function\\")
        dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this || _global3, \\"error\\") === 0) {
        throw er;
      }
    }
    source.on(\\"error\\", onerror);
    dest.on(\\"error\\", onerror);
    function cleanup() {
      source.removeListener(\\"data\\", ondata);
      dest.removeListener(\\"drain\\", ondrain);
      source.removeListener(\\"end\\", onend);
      source.removeListener(\\"close\\", onclose);
      source.removeListener(\\"error\\", onerror);
      dest.removeListener(\\"error\\", onerror);
      source.removeListener(\\"end\\", cleanup);
      source.removeListener(\\"close\\", cleanup);
      dest.removeListener(\\"close\\", cleanup);
    }
    source.on(\\"end\\", cleanup);
    source.on(\\"close\\", cleanup);
    dest.on(\\"close\\", cleanup);
    dest.emit(\\"pipe\\", source);
    return dest;
  };
  return exports$13;
}
var exports4 = dew4();

// node_modules/.pnpm/@jspm+core@2.0.0-beta.24/node_modules/@jspm/core/nodelibs/browser/stream.js
var Readable = exports4.Readable;
Readable.wrap = function(src, options) {
  options = Object.assign({ objectMode: src.readableObjectMode != null || src.objectMode != null || true }, options);
  options.destroy = function(err, callback) {
    src.destroy(err);
    callback(err);
  };
  return new Readable(options).wrap(src);
};
var Writable = exports4.Writable;
var Duplex = exports4.Duplex;
var Transform = exports4.Transform;
var PassThrough = exports4.PassThrough;
var finished = exports4.finished;
var pipeline = exports4.pipeline;
var Stream = exports4.Stream;
var promises = {
  finished: promisify2(exports4.finished),
  pipeline: promisify2(exports4.pipeline)
};

// node_modules/.pnpm/@jspm+core@2.0.0-beta.24/node_modules/@jspm/core/nodelibs/browser/chunk-924bb2e1.js
var t6 = 2147483647;
var o5 = /^xn--/;
var n5 = /[^\\\\0-\\\\x7E]/;
var e6 = /[\\\\x2E\\\\u3002\\\\uFF0E\\\\uFF61]/g;
var r6 = { overflow: \\"Overflow: input needs wider integers to process\\", \\"not-basic\\": \\"Illegal input >= 0x80 (not a basic code point)\\", \\"invalid-input\\": \\"Invalid input\\" };
var c5 = Math.floor;
var s5 = String.fromCharCode;
function i5(t8) {
  throw new RangeError(r6[t8]);
}
function f5(t8, o8) {
  const n8 = t8.split(\\"@\\");
  let r9 = \\"\\";
  n8.length > 1 && (r9 = n8[0] + \\"@\\", t8 = n8[1]);
  const c7 = function(t9, o9) {
    const n9 = [];
    let e9 = t9.length;
    for (; e9--; )
      n9[e9] = o9(t9[e9]);
    return n9;
  }((t8 = t8.replace(e6, \\".\\")).split(\\".\\"), o8).join(\\".\\");
  return r9 + c7;
}
function l5(t8) {
  const o8 = [];
  let n8 = 0;
  const e9 = t8.length;
  for (; n8 < e9; ) {
    const r9 = t8.charCodeAt(n8++);
    if (r9 >= 55296 && r9 <= 56319 && n8 < e9) {
      const e10 = t8.charCodeAt(n8++);
      (64512 & e10) == 56320 ? o8.push(((1023 & r9) << 10) + (1023 & e10) + 65536) : (o8.push(r9), n8--);
    } else
      o8.push(r9);
  }
  return o8;
}
var u5 = function(t8, o8) {
  return t8 + 22 + 75 * (t8 < 26) - ((o8 != 0) << 5);
};
var a5 = function(t8, o8, n8) {
  let e9 = 0;
  for (t8 = n8 ? c5(t8 / 700) : t8 >> 1, t8 += c5(t8 / o8); t8 > 455; e9 += 36)
    t8 = c5(t8 / 35);
  return c5(e9 + 36 * t8 / (t8 + 38));
};
var d5 = function(o8) {
  const n8 = [], e9 = o8.length;
  let r9 = 0, s6 = 128, f7 = 72, l7 = o8.lastIndexOf(\\"-\\");
  l7 < 0 && (l7 = 0);
  for (let t8 = 0; t8 < l7; ++t8)
    o8.charCodeAt(t8) >= 128 && i5(\\"not-basic\\"), n8.push(o8.charCodeAt(t8));
  for (let d6 = l7 > 0 ? l7 + 1 : 0; d6 < e9; ) {
    let l8 = r9;
    for (let n9 = 1, s7 = 36; ; s7 += 36) {
      d6 >= e9 && i5(\\"invalid-input\\");
      const l9 = (u7 = o8.charCodeAt(d6++)) - 48 < 10 ? u7 - 22 : u7 - 65 < 26 ? u7 - 65 : u7 - 97 < 26 ? u7 - 97 : 36;
      (l9 >= 36 || l9 > c5((t6 - r9) / n9)) && i5(\\"overflow\\"), r9 += l9 * n9;
      const a7 = s7 <= f7 ? 1 : s7 >= f7 + 26 ? 26 : s7 - f7;
      if (l9 < a7)
        break;
      const h9 = 36 - a7;
      n9 > c5(t6 / h9) && i5(\\"overflow\\"), n9 *= h9;
    }
    const h8 = n8.length + 1;
    f7 = a5(r9 - l8, h8, l8 == 0), c5(r9 / h8) > t6 - s6 && i5(\\"overflow\\"), s6 += c5(r9 / h8), r9 %= h8, n8.splice(r9++, 0, s6);
  }
  var u7;
  return String.fromCodePoint(...n8);
};
var h6 = function(o8) {
  const n8 = [];
  let e9 = (o8 = l5(o8)).length, r9 = 128, f7 = 0, d6 = 72;
  for (const t8 of o8)
    t8 < 128 && n8.push(s5(t8));
  let h8 = n8.length, p7 = h8;
  for (h8 && n8.push(\\"-\\"); p7 < e9; ) {
    let e10 = t6;
    for (const t8 of o8)
      t8 >= r9 && t8 < e10 && (e10 = t8);
    const l7 = p7 + 1;
    e10 - r9 > c5((t6 - f7) / l7) && i5(\\"overflow\\"), f7 += (e10 - r9) * l7, r9 = e10;
    for (const e11 of o8)
      if (e11 < r9 && ++f7 > t6 && i5(\\"overflow\\"), e11 == r9) {
        let t8 = f7;
        for (let o9 = 36; ; o9 += 36) {
          const e12 = o9 <= d6 ? 1 : o9 >= d6 + 26 ? 26 : o9 - d6;
          if (t8 < e12)
            break;
          const r10 = t8 - e12, i7 = 36 - e12;
          n8.push(s5(u5(e12 + r10 % i7, 0))), t8 = c5(r10 / i7);
        }
        n8.push(s5(u5(t8, 0))), d6 = a5(f7, l7, p7 == h8), f7 = 0, ++p7;
      }
    ++f7, ++r9;
  }
  return n8.join(\\"\\");
};
var p5 = { version: \\"2.1.0\\", ucs2: { decode: l5, encode: (t8) => String.fromCodePoint(...t8) }, decode: d5, encode: h6, toASCII: function(t8) {
  return f5(t8, function(t9) {
    return n5.test(t9) ? \\"xn--\\" + h6(t9) : t9;
  });
}, toUnicode: function(t8) {
  return f5(t8, function(t9) {
    return o5.test(t9) ? d5(t9.slice(4).toLowerCase()) : t9;
  });
} };
p5.decode;
p5.encode;
p5.toASCII;
p5.toUnicode;
p5.ucs2;
p5.version;

// node_modules/.pnpm/@jspm+core@2.0.0-beta.24/node_modules/@jspm/core/nodelibs/browser/chunk-b04e620d.js
function e7(e9, n8) {
  return Object.prototype.hasOwnProperty.call(e9, n8);
}
var n6 = function(n8, r9, t8, o8) {
  r9 = r9 || \\"&\\", t8 = t8 || \\"=\\";
  var a7 = {};
  if (typeof n8 != \\"string\\" || n8.length === 0)
    return a7;
  var u7 = /\\\\+/g;
  n8 = n8.split(r9);
  var c7 = 1e3;
  o8 && typeof o8.maxKeys == \\"number\\" && (c7 = o8.maxKeys);
  var i7 = n8.length;
  c7 > 0 && i7 > c7 && (i7 = c7);
  for (var s6 = 0; s6 < i7; ++s6) {
    var p7, f7, d6, y6, m6 = n8[s6].replace(u7, \\"%20\\"), l7 = m6.indexOf(t8);
    l7 >= 0 ? (p7 = m6.substr(0, l7), f7 = m6.substr(l7 + 1)) : (p7 = m6, f7 = \\"\\"), d6 = decodeURIComponent(p7), y6 = decodeURIComponent(f7), e7(a7, d6) ? Array.isArray(a7[d6]) ? a7[d6].push(y6) : a7[d6] = [a7[d6], y6] : a7[d6] = y6;
  }
  return a7;
};
var r7 = function(e9) {
  switch (typeof e9) {
    case \\"string\\":
      return e9;
    case \\"boolean\\":
      return e9 ? \\"true\\" : \\"false\\";
    case \\"number\\":
      return isFinite(e9) ? e9 : \\"\\";
    default:
      return \\"\\";
  }
};
var t7 = function(e9, n8, t8, o8) {
  return n8 = n8 || \\"&\\", t8 = t8 || \\"=\\", e9 === null && (e9 = void 0), typeof e9 == \\"object\\" ? Object.keys(e9).map(function(o9) {
    var a7 = encodeURIComponent(r7(o9)) + t8;
    return Array.isArray(e9[o9]) ? e9[o9].map(function(e10) {
      return a7 + encodeURIComponent(r7(e10));
    }).join(n8) : a7 + encodeURIComponent(r7(e9[o9]));
  }).join(n8) : o8 ? encodeURIComponent(r7(o8)) + t8 + encodeURIComponent(r7(e9)) : \\"\\";
};
var o6 = {};
o6.decode = o6.parse = n6, o6.encode = o6.stringify = t7;
o6.decode;
o6.encode;
o6.parse;
o6.stringify;

// node_modules/.pnpm/@jspm+core@2.0.0-beta.24/node_modules/@jspm/core/nodelibs/browser/url.js
var h7 = {};
var e8 = p5;
var a6 = { isString: function(t8) {
  return typeof t8 == \\"string\\";
}, isObject: function(t8) {
  return typeof t8 == \\"object\\" && t8 !== null;
}, isNull: function(t8) {
  return t8 === null;
}, isNullOrUndefined: function(t8) {
  return t8 == null;
} };
function r8() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
h7.parse = O4, h7.resolve = function(t8, s6) {
  return O4(t8, false, true).resolve(s6);
}, h7.resolveObject = function(t8, s6) {
  return t8 ? O4(t8, false, true).resolveObject(s6) : s6;
}, h7.format = function(t8) {
  a6.isString(t8) && (t8 = O4(t8));
  return t8 instanceof r8 ? t8.format() : r8.prototype.format.call(t8);
}, h7.Url = r8;
var o7 = /^([a-z0-9.+-]+:)/i;
var n7 = /:[0-9]*$/;
var i6 = /^(\\\\/\\\\/?(?!\\\\/)[^\\\\?\\\\s]*)(\\\\?[^\\\\s]*)?$/;
var l6 = [\\"{\\", \\"}\\", \\"|\\", \\"\\\\\\\\\\", \\"^\\", \\"\`\\"].concat([\\"<\\", \\">\\", '\\"', \\"\`\\", \\" \\", \\"\\\\r\\", \\"\\\\n\\", \\"	\\"]);
var p6 = [\\"'\\"].concat(l6);
var c6 = [\\"%\\", \\"/\\", \\"?\\", \\";\\", \\"#\\"].concat(p6);
var u6 = [\\"/\\", \\"?\\", \\"#\\"];
var f6 = /^[+a-z0-9A-Z_-]{0,63}$/;
var m5 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
var v5 = { javascript: true, \\"javascript:\\": true };
var g4 = { javascript: true, \\"javascript:\\": true };
var y5 = { http: true, https: true, ftp: true, gopher: true, file: true, \\"http:\\": true, \\"https:\\": true, \\"ftp:\\": true, \\"gopher:\\": true, \\"file:\\": true };
var b4 = o6;
function O4(t8, s6, h8) {
  if (t8 && a6.isObject(t8) && t8 instanceof r8)
    return t8;
  var e9 = new r8();
  return e9.parse(t8, s6, h8), e9;
}
r8.prototype.parse = function(t8, s6, h8) {
  if (!a6.isString(t8))
    throw new TypeError(\\"Parameter 'url' must be a string, not \\" + typeof t8);
  var r9 = t8.indexOf(\\"?\\"), n8 = r9 !== -1 && r9 < t8.indexOf(\\"#\\") ? \\"?\\" : \\"#\\", l7 = t8.split(n8);
  l7[0] = l7[0].replace(/\\\\\\\\/g, \\"/\\");
  var O5 = t8 = l7.join(n8);
  if (O5 = O5.trim(), !h8 && t8.split(\\"#\\").length === 1) {
    var d6 = i6.exec(O5);
    if (d6)
      return this.path = O5, this.href = O5, this.pathname = d6[1], d6[2] ? (this.search = d6[2], this.query = s6 ? b4.parse(this.search.substr(1)) : this.search.substr(1)) : s6 && (this.search = \\"\\", this.query = {}), this;
  }
  var j4 = o7.exec(O5);
  if (j4) {
    var q3 = (j4 = j4[0]).toLowerCase();
    this.protocol = q3, O5 = O5.substr(j4.length);
  }
  if (h8 || j4 || O5.match(/^\\\\/\\\\/[^@\\\\/]+@[^@\\\\/]+/)) {
    var x4 = O5.substr(0, 2) === \\"//\\";
    !x4 || j4 && g4[j4] || (O5 = O5.substr(2), this.slashes = true);
  }
  if (!g4[j4] && (x4 || j4 && !y5[j4])) {
    for (var A4, C4, I4 = -1, w4 = 0; w4 < u6.length; w4++) {
      (N4 = O5.indexOf(u6[w4])) !== -1 && (I4 === -1 || N4 < I4) && (I4 = N4);
    }
    (C4 = I4 === -1 ? O5.lastIndexOf(\\"@\\") : O5.lastIndexOf(\\"@\\", I4)) !== -1 && (A4 = O5.slice(0, C4), O5 = O5.slice(C4 + 1), this.auth = decodeURIComponent(A4)), I4 = -1;
    for (w4 = 0; w4 < c6.length; w4++) {
      var N4;
      (N4 = O5.indexOf(c6[w4])) !== -1 && (I4 === -1 || N4 < I4) && (I4 = N4);
    }
    I4 === -1 && (I4 = O5.length), this.host = O5.slice(0, I4), O5 = O5.slice(I4), this.parseHost(), this.hostname = this.hostname || \\"\\";
    var U4 = this.hostname[0] === \\"[\\" && this.hostname[this.hostname.length - 1] === \\"]\\";
    if (!U4)
      for (var k4 = this.hostname.split(/\\\\./), S4 = (w4 = 0, k4.length); w4 < S4; w4++) {
        var R4 = k4[w4];
        if (R4 && !R4.match(f6)) {
          for (var $3 = \\"\\", z4 = 0, H3 = R4.length; z4 < H3; z4++)
            R4.charCodeAt(z4) > 127 ? $3 += \\"x\\" : $3 += R4[z4];
          if (!$3.match(f6)) {
            var L4 = k4.slice(0, w4), Z3 = k4.slice(w4 + 1), _4 = R4.match(m5);
            _4 && (L4.push(_4[1]), Z3.unshift(_4[2])), Z3.length && (O5 = \\"/\\" + Z3.join(\\".\\") + O5), this.hostname = L4.join(\\".\\");
            break;
          }
        }
      }
    this.hostname.length > 255 ? this.hostname = \\"\\" : this.hostname = this.hostname.toLowerCase(), U4 || (this.hostname = e8.toASCII(this.hostname));
    var E4 = this.port ? \\":\\" + this.port : \\"\\", P4 = this.hostname || \\"\\";
    this.host = P4 + E4, this.href += this.host, U4 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), O5[0] !== \\"/\\" && (O5 = \\"/\\" + O5));
  }
  if (!v5[q3])
    for (w4 = 0, S4 = p6.length; w4 < S4; w4++) {
      var T5 = p6[w4];
      if (O5.indexOf(T5) !== -1) {
        var B4 = encodeURIComponent(T5);
        B4 === T5 && (B4 = escape(T5)), O5 = O5.split(T5).join(B4);
      }
    }
  var D4 = O5.indexOf(\\"#\\");
  D4 !== -1 && (this.hash = O5.substr(D4), O5 = O5.slice(0, D4));
  var F4 = O5.indexOf(\\"?\\");
  if (F4 !== -1 ? (this.search = O5.substr(F4), this.query = O5.substr(F4 + 1), s6 && (this.query = b4.parse(this.query)), O5 = O5.slice(0, F4)) : s6 && (this.search = \\"\\", this.query = {}), O5 && (this.pathname = O5), y5[q3] && this.hostname && !this.pathname && (this.pathname = \\"/\\"), this.pathname || this.search) {
    E4 = this.pathname || \\"\\";
    var G3 = this.search || \\"\\";
    this.path = E4 + G3;
  }
  return this.href = this.format(), this;
}, r8.prototype.format = function() {
  var t8 = this.auth || \\"\\";
  t8 && (t8 = (t8 = encodeURIComponent(t8)).replace(/%3A/i, \\":\\"), t8 += \\"@\\");
  var s6 = this.protocol || \\"\\", h8 = this.pathname || \\"\\", e9 = this.hash || \\"\\", r9 = false, o8 = \\"\\";
  this.host ? r9 = t8 + this.host : this.hostname && (r9 = t8 + (this.hostname.indexOf(\\":\\") === -1 ? this.hostname : \\"[\\" + this.hostname + \\"]\\"), this.port && (r9 += \\":\\" + this.port)), this.query && a6.isObject(this.query) && Object.keys(this.query).length && (o8 = b4.stringify(this.query));
  var n8 = this.search || o8 && \\"?\\" + o8 || \\"\\";
  return s6 && s6.substr(-1) !== \\":\\" && (s6 += \\":\\"), this.slashes || (!s6 || y5[s6]) && r9 !== false ? (r9 = \\"//\\" + (r9 || \\"\\"), h8 && h8.charAt(0) !== \\"/\\" && (h8 = \\"/\\" + h8)) : r9 || (r9 = \\"\\"), e9 && e9.charAt(0) !== \\"#\\" && (e9 = \\"#\\" + e9), n8 && n8.charAt(0) !== \\"?\\" && (n8 = \\"?\\" + n8), s6 + r9 + (h8 = h8.replace(/[?#]/g, function(t9) {
    return encodeURIComponent(t9);
  })) + (n8 = n8.replace(\\"#\\", \\"%23\\")) + e9;
}, r8.prototype.resolve = function(t8) {
  return this.resolveObject(O4(t8, false, true)).format();
}, r8.prototype.resolveObject = function(t8) {
  if (a6.isString(t8)) {
    var s6 = new r8();
    s6.parse(t8, false, true), t8 = s6;
  }
  for (var h8 = new r8(), e9 = Object.keys(this), o8 = 0; o8 < e9.length; o8++) {
    var n8 = e9[o8];
    h8[n8] = this[n8];
  }
  if (h8.hash = t8.hash, t8.href === \\"\\")
    return h8.href = h8.format(), h8;
  if (t8.slashes && !t8.protocol) {
    for (var i7 = Object.keys(t8), l7 = 0; l7 < i7.length; l7++) {
      var p7 = i7[l7];
      p7 !== \\"protocol\\" && (h8[p7] = t8[p7]);
    }
    return y5[h8.protocol] && h8.hostname && !h8.pathname && (h8.path = h8.pathname = \\"/\\"), h8.href = h8.format(), h8;
  }
  if (t8.protocol && t8.protocol !== h8.protocol) {
    if (!y5[t8.protocol]) {
      for (var c7 = Object.keys(t8), u7 = 0; u7 < c7.length; u7++) {
        var f7 = c7[u7];
        h8[f7] = t8[f7];
      }
      return h8.href = h8.format(), h8;
    }
    if (h8.protocol = t8.protocol, t8.host || g4[t8.protocol])
      h8.pathname = t8.pathname;
    else {
      for (var m6 = (t8.pathname || \\"\\").split(\\"/\\"); m6.length && !(t8.host = m6.shift()); )
        ;
      t8.host || (t8.host = \\"\\"), t8.hostname || (t8.hostname = \\"\\"), m6[0] !== \\"\\" && m6.unshift(\\"\\"), m6.length < 2 && m6.unshift(\\"\\"), h8.pathname = m6.join(\\"/\\");
    }
    if (h8.search = t8.search, h8.query = t8.query, h8.host = t8.host || \\"\\", h8.auth = t8.auth, h8.hostname = t8.hostname || t8.host, h8.port = t8.port, h8.pathname || h8.search) {
      var v6 = h8.pathname || \\"\\", b5 = h8.search || \\"\\";
      h8.path = v6 + b5;
    }
    return h8.slashes = h8.slashes || t8.slashes, h8.href = h8.format(), h8;
  }
  var O5 = h8.pathname && h8.pathname.charAt(0) === \\"/\\", d6 = t8.host || t8.pathname && t8.pathname.charAt(0) === \\"/\\", j4 = d6 || O5 || h8.host && t8.pathname, q3 = j4, x4 = h8.pathname && h8.pathname.split(\\"/\\") || [], A4 = (m6 = t8.pathname && t8.pathname.split(\\"/\\") || [], h8.protocol && !y5[h8.protocol]);
  if (A4 && (h8.hostname = \\"\\", h8.port = null, h8.host && (x4[0] === \\"\\" ? x4[0] = h8.host : x4.unshift(h8.host)), h8.host = \\"\\", t8.protocol && (t8.hostname = null, t8.port = null, t8.host && (m6[0] === \\"\\" ? m6[0] = t8.host : m6.unshift(t8.host)), t8.host = null), j4 = j4 && (m6[0] === \\"\\" || x4[0] === \\"\\")), d6)
    h8.host = t8.host || t8.host === \\"\\" ? t8.host : h8.host, h8.hostname = t8.hostname || t8.hostname === \\"\\" ? t8.hostname : h8.hostname, h8.search = t8.search, h8.query = t8.query, x4 = m6;
  else if (m6.length)
    x4 || (x4 = []), x4.pop(), x4 = x4.concat(m6), h8.search = t8.search, h8.query = t8.query;
  else if (!a6.isNullOrUndefined(t8.search)) {
    if (A4)
      h8.hostname = h8.host = x4.shift(), (U4 = !!(h8.host && h8.host.indexOf(\\"@\\") > 0) && h8.host.split(\\"@\\")) && (h8.auth = U4.shift(), h8.host = h8.hostname = U4.shift());
    return h8.search = t8.search, h8.query = t8.query, a6.isNull(h8.pathname) && a6.isNull(h8.search) || (h8.path = (h8.pathname ? h8.pathname : \\"\\") + (h8.search ? h8.search : \\"\\")), h8.href = h8.format(), h8;
  }
  if (!x4.length)
    return h8.pathname = null, h8.search ? h8.path = \\"/\\" + h8.search : h8.path = null, h8.href = h8.format(), h8;
  for (var C4 = x4.slice(-1)[0], I4 = (h8.host || t8.host || x4.length > 1) && (C4 === \\".\\" || C4 === \\"..\\") || C4 === \\"\\", w4 = 0, N4 = x4.length; N4 >= 0; N4--)
    (C4 = x4[N4]) === \\".\\" ? x4.splice(N4, 1) : C4 === \\"..\\" ? (x4.splice(N4, 1), w4++) : w4 && (x4.splice(N4, 1), w4--);
  if (!j4 && !q3)
    for (; w4--; w4)
      x4.unshift(\\"..\\");
  !j4 || x4[0] === \\"\\" || x4[0] && x4[0].charAt(0) === \\"/\\" || x4.unshift(\\"\\"), I4 && x4.join(\\"/\\").substr(-1) !== \\"/\\" && x4.push(\\"\\");
  var U4, k4 = x4[0] === \\"\\" || x4[0] && x4[0].charAt(0) === \\"/\\";
  A4 && (h8.hostname = h8.host = k4 ? \\"\\" : x4.length ? x4.shift() : \\"\\", (U4 = !!(h8.host && h8.host.indexOf(\\"@\\") > 0) && h8.host.split(\\"@\\")) && (h8.auth = U4.shift(), h8.host = h8.hostname = U4.shift()));
  return (j4 = j4 || h8.host && x4.length) && !k4 && x4.unshift(\\"\\"), x4.length ? h8.pathname = x4.join(\\"/\\") : (h8.pathname = null, h8.path = null), a6.isNull(h8.pathname) && a6.isNull(h8.search) || (h8.path = (h8.pathname ? h8.pathname : \\"\\") + (h8.search ? h8.search : \\"\\")), h8.auth = t8.auth || h8.auth, h8.slashes = h8.slashes || t8.slashes, h8.href = h8.format(), h8;
}, r8.prototype.parseHost = function() {
  var t8 = this.host, s6 = n7.exec(t8);
  s6 && ((s6 = s6[0]) !== \\":\\" && (this.port = s6.substr(1)), t8 = t8.substr(0, t8.length - s6.length)), t8 && (this.hostname = t8);
};
h7.Url;
h7.format;
h7.resolve;
h7.resolveObject;
var exports5 = {};
var _dewExec5 = false;
function dew5() {
  if (_dewExec5)
    return exports5;
  _dewExec5 = true;
  var process2 = T;
  function assertPath(path2) {
    if (typeof path2 !== \\"string\\") {
      throw new TypeError(\\"Path must be a string. Received \\" + JSON.stringify(path2));
    }
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    var res = \\"\\";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i7 = 0; i7 <= path2.length; ++i7) {
      if (i7 < path2.length)
        code = path2.charCodeAt(i7);
      else if (code === 47)
        break;
      else
        code = 47;
      if (code === 47) {
        if (lastSlash === i7 - 1 || dots === 1)
          ;
        else if (lastSlash !== i7 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf(\\"/\\");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = \\"\\";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf(\\"/\\");
                }
                lastSlash = i7;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = \\"\\";
              lastSegmentLength = 0;
              lastSlash = i7;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0)
              res += \\"/..\\";
            else
              res = \\"..\\";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0)
            res += \\"/\\" + path2.slice(lastSlash + 1, i7);
          else
            res = path2.slice(lastSlash + 1, i7);
          lastSegmentLength = i7 - lastSlash - 1;
        }
        lastSlash = i7;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep2, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || \\"\\") + (pathObject.ext || \\"\\");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep2 + base;
  }
  var posix2 = {
    resolve: function resolve3() {
      var resolvedPath = \\"\\";
      var resolvedAbsolute = false;
      var cwd;
      for (var i7 = arguments.length - 1; i7 >= -1 && !resolvedAbsolute; i7--) {
        var path2;
        if (i7 >= 0)
          path2 = arguments[i7];
        else {
          if (cwd === void 0)
            cwd = process2.cwd();
          path2 = cwd;
        }
        assertPath(path2);
        if (path2.length === 0) {
          continue;
        }
        resolvedPath = path2 + \\"/\\" + resolvedPath;
        resolvedAbsolute = path2.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0)
          return \\"/\\" + resolvedPath;
        else
          return \\"/\\";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return \\".\\";
      }
    },
    normalize: function normalize2(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return \\".\\";
      var isAbsolute2 = path2.charCodeAt(0) === 47;
      var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
      path2 = normalizeStringPosix(path2, !isAbsolute2);
      if (path2.length === 0 && !isAbsolute2)
        path2 = \\".\\";
      if (path2.length > 0 && trailingSeparator)
        path2 += \\"/\\";
      if (isAbsolute2)
        return \\"/\\" + path2;
      return path2;
    },
    isAbsolute: function isAbsolute2(path2) {
      assertPath(path2);
      return path2.length > 0 && path2.charCodeAt(0) === 47;
    },
    join: function join2() {
      if (arguments.length === 0)
        return \\".\\";
      var joined;
      for (var i7 = 0; i7 < arguments.length; ++i7) {
        var arg = arguments[i7];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else
            joined += \\"/\\" + arg;
        }
      }
      if (joined === void 0)
        return \\".\\";
      return posix2.normalize(joined);
    },
    relative: function relative2(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to)
        return \\"\\";
      from = posix2.resolve(from);
      to = posix2.resolve(to);
      if (from === to)
        return \\"\\";
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47)
          break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47)
          break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i7 = 0;
      for (; i7 <= length; ++i7) {
        if (i7 === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i7) === 47) {
              return to.slice(toStart + i7 + 1);
            } else if (i7 === 0) {
              return to.slice(toStart + i7);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i7) === 47) {
              lastCommonSep = i7;
            } else if (i7 === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i7);
        var toCode = to.charCodeAt(toStart + i7);
        if (fromCode !== toCode)
          break;
        else if (fromCode === 47)
          lastCommonSep = i7;
      }
      var out = \\"\\";
      for (i7 = fromStart + lastCommonSep + 1; i7 <= fromEnd; ++i7) {
        if (i7 === fromEnd || from.charCodeAt(i7) === 47) {
          if (out.length === 0)
            out += \\"..\\";
          else
            out += \\"/..\\";
        }
      }
      if (out.length > 0)
        return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47)
          ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong2(path2) {
      return path2;
    },
    dirname: function dirname2(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return \\".\\";
      var code = path2.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i7 = path2.length - 1; i7 >= 1; --i7) {
        code = path2.charCodeAt(i7);
        if (code === 47) {
          if (!matchedSlash) {
            end = i7;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1)
        return hasRoot ? \\"/\\" : \\".\\";
      if (hasRoot && end === 1)
        return \\"//\\";
      return path2.slice(0, end);
    },
    basename: function basename2(path2, ext) {
      if (ext !== void 0 && typeof ext !== \\"string\\")
        throw new TypeError('\\"ext\\" argument must be a string');
      assertPath(path2);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i7;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2)
          return \\"\\";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i7 = path2.length - 1; i7 >= 0; --i7) {
          var code = path2.charCodeAt(i7);
          if (code === 47) {
            if (!matchedSlash) {
              start = i7 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i7 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i7;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end)
          end = firstNonSlashEnd;
        else if (end === -1)
          end = path2.length;
        return path2.slice(start, end);
      } else {
        for (i7 = path2.length - 1; i7 >= 0; --i7) {
          if (path2.charCodeAt(i7) === 47) {
            if (!matchedSlash) {
              start = i7 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i7 + 1;
          }
        }
        if (end === -1)
          return \\"\\";
        return path2.slice(start, end);
      }
    },
    extname: function extname2(path2) {
      assertPath(path2);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i7 = path2.length - 1; i7 >= 0; --i7) {
        var code = path2.charCodeAt(i7);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i7 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i7 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i7;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return \\"\\";
      }
      return path2.slice(startDot, end);
    },
    format: function format5(pathObject) {
      if (pathObject === null || typeof pathObject !== \\"object\\") {
        throw new TypeError('The \\"pathObject\\" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format(\\"/\\", pathObject);
    },
    parse: function parse3(path2) {
      assertPath(path2);
      var ret = {
        root: \\"\\",
        dir: \\"\\",
        base: \\"\\",
        ext: \\"\\",
        name: \\"\\"
      };
      if (path2.length === 0)
        return ret;
      var code = path2.charCodeAt(0);
      var isAbsolute2 = code === 47;
      var start;
      if (isAbsolute2) {
        ret.root = \\"/\\";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i7 = path2.length - 1;
      var preDotState = 0;
      for (; i7 >= start; --i7) {
        code = path2.charCodeAt(i7);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i7 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i7 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i7;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute2)
            ret.base = ret.name = path2.slice(1, end);
          else
            ret.base = ret.name = path2.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute2) {
          ret.name = path2.slice(1, startDot);
          ret.base = path2.slice(1, end);
        } else {
          ret.name = path2.slice(startPart, startDot);
          ret.base = path2.slice(startPart, end);
        }
        ret.ext = path2.slice(startDot, end);
      }
      if (startPart > 0)
        ret.dir = path2.slice(0, startPart - 1);
      else if (isAbsolute2)
        ret.dir = \\"/\\";
      return ret;
    },
    sep: \\"/\\",
    delimiter: \\":\\",
    win32: null,
    posix: null
  };
  posix2.posix = posix2;
  exports5 = posix2;
  return exports5;
}
var path = dew5();
var processPlatform$1 = typeof Deno !== \\"undefined\\" ? Deno.build.os === \\"windows\\" ? \\"win32\\" : Deno.build.os : void 0;
h7.URL = typeof URL !== \\"undefined\\" ? URL : null;
h7.pathToFileURL = pathToFileURL$1;
h7.fileURLToPath = fileURLToPath$1;
h7.Url;
h7.format;
h7.resolve;
h7.resolveObject;
h7.URL;
var CHAR_BACKWARD_SLASH$1 = 92;
var CHAR_FORWARD_SLASH$1 = 47;
var CHAR_LOWERCASE_A$1 = 97;
var CHAR_LOWERCASE_Z$1 = 122;
var isWindows$1 = processPlatform$1 === \\"win32\\";
var forwardSlashRegEx$1 = /\\\\//g;
var percentRegEx$1 = /%/g;
var backslashRegEx$1 = /\\\\\\\\/g;
var newlineRegEx$1 = /\\\\n/g;
var carriageReturnRegEx$1 = /\\\\r/g;
var tabRegEx$1 = /\\\\t/g;
function fileURLToPath$1(path2) {
  if (typeof path2 === \\"string\\")
    path2 = new URL(path2);
  else if (!(path2 instanceof URL)) {
    throw new Deno.errors.InvalidData(\\"invalid argument path , must be a string or URL\\");
  }
  if (path2.protocol !== \\"file:\\") {
    throw new Deno.errors.InvalidData(\\"invalid url scheme\\");
  }
  return isWindows$1 ? getPathFromURLWin$1(path2) : getPathFromURLPosix$1(path2);
}
function getPathFromURLWin$1(url) {
  const hostname = url.hostname;
  let pathname = url.pathname;
  for (let n8 = 0; n8 < pathname.length; n8++) {
    if (pathname[n8] === \\"%\\") {
      const third = pathname.codePointAt(n8 + 2) || 32;
      if (pathname[n8 + 1] === \\"2\\" && third === 102 || pathname[n8 + 1] === \\"5\\" && third === 99) {
        throw new Deno.errors.InvalidData(\\"must not include encoded \\\\\\\\ or / characters\\");
      }
    }
  }
  pathname = pathname.replace(forwardSlashRegEx$1, \\"\\\\\\\\\\");
  pathname = decodeURIComponent(pathname);
  if (hostname !== \\"\\") {
    return \`\\\\\\\\\\\\\\\\\${hostname}\${pathname}\`;
  } else {
    const letter = pathname.codePointAt(1) | 32;
    const sep2 = pathname[2];
    if (letter < CHAR_LOWERCASE_A$1 || letter > CHAR_LOWERCASE_Z$1 || sep2 !== \\":\\") {
      throw new Deno.errors.InvalidData(\\"file url path must be absolute\\");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix$1(url) {
  if (url.hostname !== \\"\\") {
    throw new Deno.errors.InvalidData(\\"invalid file url hostname\\");
  }
  const pathname = url.pathname;
  for (let n8 = 0; n8 < pathname.length; n8++) {
    if (pathname[n8] === \\"%\\") {
      const third = pathname.codePointAt(n8 + 2) || 32;
      if (pathname[n8 + 1] === \\"2\\" && third === 102) {
        throw new Deno.errors.InvalidData(\\"must not include encoded / characters\\");
      }
    }
  }
  return decodeURIComponent(pathname);
}
function pathToFileURL$1(filepath) {
  let resolved = path.resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if ((filePathLast === CHAR_FORWARD_SLASH$1 || isWindows$1 && filePathLast === CHAR_BACKWARD_SLASH$1) && resolved[resolved.length - 1] !== path.sep) {
    resolved += \\"/\\";
  }
  const outURL = new URL(\\"file://\\");
  if (resolved.includes(\\"%\\"))
    resolved = resolved.replace(percentRegEx$1, \\"%25\\");
  if (!isWindows$1 && resolved.includes(\\"\\\\\\\\\\")) {
    resolved = resolved.replace(backslashRegEx$1, \\"%5C\\");
  }
  if (resolved.includes(\\"\\\\n\\"))
    resolved = resolved.replace(newlineRegEx$1, \\"%0A\\");
  if (resolved.includes(\\"\\\\r\\")) {
    resolved = resolved.replace(carriageReturnRegEx$1, \\"%0D\\");
  }
  if (resolved.includes(\\"	\\"))
    resolved = resolved.replace(tabRegEx$1, \\"%09\\");
  outURL.pathname = resolved;
  return outURL;
}
var processPlatform = typeof Deno !== \\"undefined\\" ? Deno.build.os === \\"windows\\" ? \\"win32\\" : Deno.build.os : void 0;
h7.URL = typeof URL !== \\"undefined\\" ? URL : null;
h7.pathToFileURL = pathToFileURL;
h7.fileURLToPath = fileURLToPath;
var Url = h7.Url;
var format4 = h7.format;
var resolve2 = h7.resolve;
var resolveObject = h7.resolveObject;
var parse2 = h7.parse;
var _URL = h7.URL;
var CHAR_BACKWARD_SLASH = 92;
var CHAR_FORWARD_SLASH = 47;
var CHAR_LOWERCASE_A = 97;
var CHAR_LOWERCASE_Z = 122;
var isWindows = processPlatform === \\"win32\\";
var forwardSlashRegEx = /\\\\//g;
var percentRegEx = /%/g;
var backslashRegEx = /\\\\\\\\/g;
var newlineRegEx = /\\\\n/g;
var carriageReturnRegEx = /\\\\r/g;
var tabRegEx = /\\\\t/g;
function fileURLToPath(path2) {
  if (typeof path2 === \\"string\\")
    path2 = new URL(path2);
  else if (!(path2 instanceof URL)) {
    throw new Deno.errors.InvalidData(\\"invalid argument path , must be a string or URL\\");
  }
  if (path2.protocol !== \\"file:\\") {
    throw new Deno.errors.InvalidData(\\"invalid url scheme\\");
  }
  return isWindows ? getPathFromURLWin(path2) : getPathFromURLPosix(path2);
}
function getPathFromURLWin(url) {
  const hostname = url.hostname;
  let pathname = url.pathname;
  for (let n8 = 0; n8 < pathname.length; n8++) {
    if (pathname[n8] === \\"%\\") {
      const third = pathname.codePointAt(n8 + 2) || 32;
      if (pathname[n8 + 1] === \\"2\\" && third === 102 || pathname[n8 + 1] === \\"5\\" && third === 99) {
        throw new Deno.errors.InvalidData(\\"must not include encoded \\\\\\\\ or / characters\\");
      }
    }
  }
  pathname = pathname.replace(forwardSlashRegEx, \\"\\\\\\\\\\");
  pathname = decodeURIComponent(pathname);
  if (hostname !== \\"\\") {
    return \`\\\\\\\\\\\\\\\\\${hostname}\${pathname}\`;
  } else {
    const letter = pathname.codePointAt(1) | 32;
    const sep2 = pathname[2];
    if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z || sep2 !== \\":\\") {
      throw new Deno.errors.InvalidData(\\"file url path must be absolute\\");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix(url) {
  if (url.hostname !== \\"\\") {
    throw new Deno.errors.InvalidData(\\"invalid file url hostname\\");
  }
  const pathname = url.pathname;
  for (let n8 = 0; n8 < pathname.length; n8++) {
    if (pathname[n8] === \\"%\\") {
      const third = pathname.codePointAt(n8 + 2) || 32;
      if (pathname[n8 + 1] === \\"2\\" && third === 102) {
        throw new Deno.errors.InvalidData(\\"must not include encoded / characters\\");
      }
    }
  }
  return decodeURIComponent(pathname);
}
function pathToFileURL(filepath) {
  let resolved = exports3.resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if ((filePathLast === CHAR_FORWARD_SLASH || isWindows && filePathLast === CHAR_BACKWARD_SLASH) && resolved[resolved.length - 1] !== exports3.sep) {
    resolved += \\"/\\";
  }
  const outURL = new URL(\\"file://\\");
  if (resolved.includes(\\"%\\"))
    resolved = resolved.replace(percentRegEx, \\"%25\\");
  if (!isWindows && resolved.includes(\\"\\\\\\\\\\")) {
    resolved = resolved.replace(backslashRegEx, \\"%5C\\");
  }
  if (resolved.includes(\\"\\\\n\\"))
    resolved = resolved.replace(newlineRegEx, \\"%0A\\");
  if (resolved.includes(\\"\\\\r\\")) {
    resolved = resolved.replace(carriageReturnRegEx, \\"%0D\\");
  }
  if (resolved.includes(\\"	\\"))
    resolved = resolved.replace(tabRegEx, \\"%09\\");
  outURL.pathname = resolved;
  return outURL;
}

// node_modules/.pnpm/@jspm+core@2.0.0-beta.24/node_modules/@jspm/core/nodelibs/browser/buffer.js
var exports$32 = {};
var _dewExec$22 = false;
function dew$22() {
  if (_dewExec$22)
    return exports$32;
  _dewExec$22 = true;
  exports$32.byteLength = byteLength;
  exports$32.toByteArray = toByteArray;
  exports$32.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== \\"undefined\\" ? Uint8Array : Array;
  var code = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\";
  for (var i7 = 0, len = code.length; i7 < len; ++i7) {
    lookup[i7] = code[i7];
    revLookup[code.charCodeAt(i7)] = i7;
  }
  revLookup[\\"-\\".charCodeAt(0)] = 62;
  revLookup[\\"_\\".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error(\\"Invalid string. Length must be a multiple of 4\\");
    }
    var validLen = b64.indexOf(\\"=\\");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i8;
    for (i8 = 0; i8 < len2; i8 += 4) {
      tmp = revLookup[b64.charCodeAt(i8)] << 18 | revLookup[b64.charCodeAt(i8 + 1)] << 12 | revLookup[b64.charCodeAt(i8 + 2)] << 6 | revLookup[b64.charCodeAt(i8 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i8)] << 2 | revLookup[b64.charCodeAt(i8 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i8)] << 10 | revLookup[b64.charCodeAt(i8 + 1)] << 4 | revLookup[b64.charCodeAt(i8 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i8 = start; i8 < end; i8 += 3) {
      tmp = (uint8[i8] << 16 & 16711680) + (uint8[i8 + 1] << 8 & 65280) + (uint8[i8 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join(\\"\\");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i8 = 0, len22 = len2 - extraBytes; i8 < len22; i8 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i8, i8 + maxChunkLength > len22 ? len22 : i8 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \\"==\\");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \\"=\\");
    }
    return parts.join(\\"\\");
  }
  return exports$32;
}
var exports$22 = {};
var _dewExec$12 = false;
function dew$12() {
  if (_dewExec$12)
    return exports$22;
  _dewExec$12 = true;
  exports$22.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e9, m6;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i7 = isLE ? nBytes - 1 : 0;
    var d6 = isLE ? -1 : 1;
    var s6 = buffer2[offset + i7];
    i7 += d6;
    e9 = s6 & (1 << -nBits) - 1;
    s6 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e9 = e9 * 256 + buffer2[offset + i7], i7 += d6, nBits -= 8) {
    }
    m6 = e9 & (1 << -nBits) - 1;
    e9 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m6 = m6 * 256 + buffer2[offset + i7], i7 += d6, nBits -= 8) {
    }
    if (e9 === 0) {
      e9 = 1 - eBias;
    } else if (e9 === eMax) {
      return m6 ? NaN : (s6 ? -1 : 1) * Infinity;
    } else {
      m6 = m6 + Math.pow(2, mLen);
      e9 = e9 - eBias;
    }
    return (s6 ? -1 : 1) * m6 * Math.pow(2, e9 - mLen);
  };
  exports$22.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e9, m6, c7;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i7 = isLE ? 0 : nBytes - 1;
    var d6 = isLE ? 1 : -1;
    var s6 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m6 = isNaN(value) ? 1 : 0;
      e9 = eMax;
    } else {
      e9 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c7 = Math.pow(2, -e9)) < 1) {
        e9--;
        c7 *= 2;
      }
      if (e9 + eBias >= 1) {
        value += rt / c7;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c7 >= 2) {
        e9++;
        c7 /= 2;
      }
      if (e9 + eBias >= eMax) {
        m6 = 0;
        e9 = eMax;
      } else if (e9 + eBias >= 1) {
        m6 = (value * c7 - 1) * Math.pow(2, mLen);
        e9 = e9 + eBias;
      } else {
        m6 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e9 = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i7] = m6 & 255, i7 += d6, m6 /= 256, mLen -= 8) {
    }
    e9 = e9 << mLen | m6;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i7] = e9 & 255, i7 += d6, e9 /= 256, eLen -= 8) {
    }
    buffer2[offset + i7 - d6] |= s6 * 128;
  };
  return exports$22;
}
var exports$14 = {};
var _dewExec6 = false;
function dew6() {
  if (_dewExec6)
    return exports$14;
  _dewExec6 = true;
  const base64 = dew$22();
  const ieee754 = dew$12();
  const customInspectSymbol = typeof Symbol === \\"function\\" && typeof Symbol[\\"for\\"] === \\"function\\" ? Symbol[\\"for\\"](\\"nodejs.util.inspect.custom\\") : null;
  exports$14.Buffer = Buffer2;
  exports$14.SlowBuffer = SlowBuffer;
  exports$14.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports$14.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \\"undefined\\" && typeof console.error === \\"function\\") {
    console.error(\\"This browser lacks typed array (Uint8Array) support which is required by \`buffer\` v5.x. Use \`buffer\` v4.x if you require old browser support.\\");
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = {
        foo: function() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e9) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, \\"parent\\", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, \\"offset\\", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value \\"' + length + '\\" is invalid for option \\"size\\"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === \\"number\\") {
      if (typeof encodingOrOffset === \\"string\\") {
        throw new TypeError('The \\"string\\" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === \\"string\\") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(\\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \\" + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== \\"undefined\\" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === \\"number\\") {
      throw new TypeError('The \\"value\\" argument must not be of type number. Received type number');
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    const b5 = fromObject(value);
    if (b5)
      return b5;
    if (typeof Symbol !== \\"undefined\\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \\"function\\") {
      return Buffer2.from(value[Symbol.toPrimitive](\\"string\\"), encodingOrOffset, length);
    }
    throw new TypeError(\\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \\" + typeof value);
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size) {
    if (typeof size !== \\"number\\") {
      throw new TypeError('\\"size\\" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value \\"' + size + '\\" is invalid for option \\"size\\"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === \\"string\\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== \\"string\\" || encoding === \\"\\") {
      encoding = \\"utf8\\";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError(\\"Unknown encoding: \\" + encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i7 = 0; i7 < length; i7 += 1) {
      buf[i7] = array[i7] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\\"offset\\" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\\"length\\" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== \\"number\\" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === \\"Buffer\\" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError(\\"Attempt to allocate Buffer larger than maximum size: 0x\\" + K_MAX_LENGTH.toString(16) + \\" bytes\\");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer3(b5) {
    return b5 != null && b5._isBuffer === true && b5 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a7, b5) {
    if (isInstance(a7, Uint8Array))
      a7 = Buffer2.from(a7, a7.offset, a7.byteLength);
    if (isInstance(b5, Uint8Array))
      b5 = Buffer2.from(b5, b5.offset, b5.byteLength);
    if (!Buffer2.isBuffer(a7) || !Buffer2.isBuffer(b5)) {
      throw new TypeError('The \\"buf1\\", \\"buf2\\" arguments must be one of type Buffer or Uint8Array');
    }
    if (a7 === b5)
      return 0;
    let x4 = a7.length;
    let y6 = b5.length;
    for (let i7 = 0, len = Math.min(x4, y6); i7 < len; ++i7) {
      if (a7[i7] !== b5[i7]) {
        x4 = a7[i7];
        y6 = b5[i7];
        break;
      }
    }
    if (x4 < y6)
      return -1;
    if (y6 < x4)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case \\"hex\\":
      case \\"utf8\\":
      case \\"utf-8\\":
      case \\"ascii\\":
      case \\"latin1\\":
      case \\"binary\\":
      case \\"base64\\":
      case \\"ucs2\\":
      case \\"ucs-2\\":
      case \\"utf16le\\":
      case \\"utf-16le\\":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('\\"list\\" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i7;
    if (length === void 0) {
      length = 0;
      for (i7 = 0; i7 < list.length; ++i7) {
        length += list[i7].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length);
    let pos = 0;
    for (i7 = 0; i7 < list.length; ++i7) {
      let buf = list[i7];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('\\"list\\" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength(string, encoding) {
    if (Buffer2.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== \\"string\\") {
      throw new TypeError('The \\"string\\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case \\"ascii\\":
        case \\"latin1\\":
        case \\"binary\\":
          return len;
        case \\"utf8\\":
        case \\"utf-8\\":
          return utf8ToBytes(string).length;
        case \\"ucs2\\":
        case \\"ucs-2\\":
        case \\"utf16le\\":
        case \\"utf-16le\\":
          return len * 2;
        case \\"hex\\":
          return len >>> 1;
        case \\"base64\\":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = (\\"\\" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return \\"\\";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return \\"\\";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return \\"\\";
    }
    if (!encoding)
      encoding = \\"utf8\\";
    while (true) {
      switch (encoding) {
        case \\"hex\\":
          return hexSlice(this, start, end);
        case \\"utf8\\":
        case \\"utf-8\\":
          return utf8Slice(this, start, end);
        case \\"ascii\\":
          return asciiSlice(this, start, end);
        case \\"latin1\\":
        case \\"binary\\":
          return latin1Slice(this, start, end);
        case \\"base64\\":
          return base64Slice(this, start, end);
        case \\"ucs2\\":
        case \\"ucs-2\\":
        case \\"utf16le\\":
        case \\"utf-16le\\":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError(\\"Unknown encoding: \\" + encoding);
          encoding = (encoding + \\"\\").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b5, n8, m6) {
    const i7 = b5[n8];
    b5[n8] = b5[m6];
    b5[m6] = i7;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError(\\"Buffer size must be a multiple of 16-bits\\");
    }
    for (let i7 = 0; i7 < len; i7 += 2) {
      swap(this, i7, i7 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError(\\"Buffer size must be a multiple of 32-bits\\");
    }
    for (let i7 = 0; i7 < len; i7 += 4) {
      swap(this, i7, i7 + 3);
      swap(this, i7 + 1, i7 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError(\\"Buffer size must be a multiple of 64-bits\\");
    }
    for (let i7 = 0; i7 < len; i7 += 8) {
      swap(this, i7, i7 + 7);
      swap(this, i7 + 1, i7 + 6);
      swap(this, i7 + 2, i7 + 5);
      swap(this, i7 + 3, i7 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0)
      return \\"\\";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b5) {
    if (!Buffer2.isBuffer(b5))
      throw new TypeError(\\"Argument must be a Buffer\\");
    if (this === b5)
      return true;
    return Buffer2.compare(this, b5) === 0;
  };
  Buffer2.prototype.inspect = function inspect3() {
    let str = \\"\\";
    const max = exports$14.INSPECT_MAX_BYTES;
    str = this.toString(\\"hex\\", 0, max).replace(/(.{2})/g, \\"$1 \\").trim();
    if (this.length > max)
      str += \\" ... \\";
    return \\"<Buffer \\" + str + \\">\\";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError('The \\"target\\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError(\\"out of range index\\");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x4 = thisEnd - thisStart;
    let y6 = end - start;
    const len = Math.min(x4, y6);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i7 = 0; i7 < len; ++i7) {
      if (thisCopy[i7] !== targetCopy[i7]) {
        x4 = thisCopy[i7];
        y6 = targetCopy[i7];
        break;
      }
    }
    if (x4 < y6)
      return -1;
    if (y6 < x4)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === \\"string\\") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === \\"string\\") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === \\"number\\") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === \\"function\\") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError(\\"val must be string, number or Buffer\\");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === \\"ucs2\\" || encoding === \\"ucs-2\\" || encoding === \\"utf16le\\" || encoding === \\"utf-16le\\") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i8) {
      if (indexSize === 1) {
        return buf[i8];
      } else {
        return buf.readUInt16BE(i8 * indexSize);
      }
    }
    let i7;
    if (dir) {
      let foundIndex = -1;
      for (i7 = byteOffset; i7 < arrLength; i7++) {
        if (read2(arr, i7) === read2(val, foundIndex === -1 ? 0 : i7 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i7;
          if (i7 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i7 -= i7 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i7 = byteOffset; i7 >= 0; i7--) {
        let found = true;
        for (let j4 = 0; j4 < valLength; j4++) {
          if (read2(arr, i7 + j4) !== read2(val, j4)) {
            found = false;
            break;
          }
        }
        if (found)
          return i7;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i7;
    for (i7 = 0; i7 < length; ++i7) {
      const parsed = parseInt(string.substr(i7 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i7;
      buf[offset + i7] = parsed;
    }
    return i7;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write2(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = \\"utf8\\";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === \\"string\\") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = \\"utf8\\";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(\\"Buffer.write(string, encoding, offset[, length]) is no longer supported\\");
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError(\\"Attempt to write outside buffer bounds\\");
    }
    if (!encoding)
      encoding = \\"utf8\\";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case \\"hex\\":
          return hexWrite(this, string, offset, length);
        case \\"utf8\\":
        case \\"utf-8\\":
          return utf8Write(this, string, offset, length);
        case \\"ascii\\":
        case \\"latin1\\":
        case \\"binary\\":
          return asciiWrite(this, string, offset, length);
        case \\"base64\\":
          return base64Write(this, string, offset, length);
        case \\"ucs2\\":
        case \\"ucs-2\\":
        case \\"utf16le\\":
        case \\"utf-16le\\":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError(\\"Unknown encoding: \\" + encoding);
          encoding = (\\"\\" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: \\"Buffer\\",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i7 = start;
    while (i7 < end) {
      const firstByte = buf[i7];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i7 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i7 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i7 + 1];
            thirdByte = buf[i7 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i7 + 1];
            thirdByte = buf[i7 + 2];
            fourthByte = buf[i7 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i7 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = \\"\\";
    let i7 = 0;
    while (i7 < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i7, i7 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = \\"\\";
    end = Math.min(buf.length, end);
    for (let i7 = start; i7 < end; ++i7) {
      ret += String.fromCharCode(buf[i7] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = \\"\\";
    end = Math.min(buf.length, end);
    for (let i7 = start; i7 < end; ++i7) {
      ret += String.fromCharCode(buf[i7]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = \\"\\";
    for (let i7 = start; i7 < end; ++i7) {
      out += hexSliceLookupTable[buf[i7]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = \\"\\";
    for (let i7 = 0; i7 < bytes.length - 1; i7 += 2) {
      res += String.fromCharCode(bytes[i7] + bytes[i7 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError(\\"offset is not uint\\");
    if (offset + ext > length)
      throw new RangeError(\\"Trying to access beyond buffer length\\");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i7 = 0;
    while (++i7 < byteLength2 && (mul *= 256)) {
      val += this[offset + i7] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    let val = this[offset + --byteLength2];
    let mul = 1;
    while (byteLength2 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength2] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, \\"offset\\");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, \\"offset\\");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i7 = 0;
    while (++i7 < byteLength2 && (mul *= 256)) {
      val += this[offset + i7] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let i7 = byteLength2;
    let mul = 1;
    let val = this[offset + --i7];
    while (i7 > 0 && (mul *= 256)) {
      val += this[offset + --i7] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, \\"offset\\");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, \\"offset\\");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('\\"buffer\\" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('\\"value\\" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError(\\"Index out of range\\");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let mul = 1;
    let i7 = 0;
    this[offset] = value & 255;
    while (++i7 < byteLength2 && (mul *= 256)) {
      this[offset + i7] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let i7 = byteLength2 - 1;
    let mul = 1;
    this[offset + i7] = value & 255;
    while (--i7 >= 0 && (mul *= 256)) {
      this[offset + i7] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\\"0xffffffffffffffff\\"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\\"0xffffffffffffffff\\"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i7 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i7 < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i7 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i7] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i7 = byteLength2 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i7] = value & 255;
    while (--i7 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i7 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i7] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt(\\"0x8000000000000000\\"), BigInt(\\"0x7fffffffffffffff\\"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt(\\"0x8000000000000000\\"), BigInt(\\"0x7fffffffffffffff\\"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError(\\"Index out of range\\");
    if (offset < 0)
      throw new RangeError(\\"Index out of range\\");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError(\\"argument should be a Buffer\\");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError(\\"targetStart out of bounds\\");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError(\\"Index out of range\\");
    if (end < 0)
      throw new RangeError(\\"sourceEnd out of bounds\\");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === \\"function\\") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === \\"string\\") {
      if (typeof start === \\"string\\") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === \\"string\\") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== \\"string\\") {
        throw new TypeError(\\"encoding must be a string\\");
      }
      if (typeof encoding === \\"string\\" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError(\\"Unknown encoding: \\" + encoding);
      }
      if (val.length === 1) {
        const code = val.charCodeAt(0);
        if (encoding === \\"utf8\\" && code < 128 || encoding === \\"latin1\\") {
          val = code;
        }
      }
    } else if (typeof val === \\"number\\") {
      val = val & 255;
    } else if (typeof val === \\"boolean\\") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError(\\"Out of range index\\");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i7;
    if (typeof val === \\"number\\") {
      for (i7 = start; i7 < end; ++i7) {
        this[i7] = val;
      }
    } else {
      const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value \\"' + val + '\\" is invalid for argument \\"value\\"');
      }
      for (i7 = 0; i7 < end - start; ++i7) {
        this[i7 + start] = bytes[i7 % len];
      }
    }
    return this;
  };
  const errors = {};
  function E4(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, \\"message\\", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = \`\${this.name} [\${sym}]\`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, \\"code\\", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return \`\${this.name} [\${sym}]: \${this.message}\`;
      }
    };
  }
  E4(\\"ERR_BUFFER_OUT_OF_BOUNDS\\", function(name2) {
    if (name2) {
      return \`\${name2} is outside of buffer bounds\`;
    }
    return \\"Attempt to access memory outside buffer bounds\\";
  }, RangeError);
  E4(\\"ERR_INVALID_ARG_TYPE\\", function(name2, actual) {
    return \`The \\"\${name2}\\" argument must be of type number. Received type \${typeof actual}\`;
  }, TypeError);
  E4(\\"ERR_OUT_OF_RANGE\\", function(str, range, input) {
    let msg = \`The value of \\"\${str}\\" is out of range.\`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === \\"bigint\\") {
      received = String(input);
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += \\"n\\";
    }
    msg += \` It must be \${range}. Received \${received}\`;
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    let res = \\"\\";
    let i7 = val.length;
    const start = val[0] === \\"-\\" ? 1 : 0;
    for (; i7 >= start + 4; i7 -= 3) {
      res = \`_\${val.slice(i7 - 3, i7)}\${res}\`;
    }
    return \`\${val.slice(0, i7)}\${res}\`;
  }
  function checkBounds(buf, offset, byteLength2) {
    validateNumber(offset, \\"offset\\");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
      boundsError(offset, buf.length - (byteLength2 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
      const n8 = typeof min === \\"bigint\\" ? \\"n\\" : \\"\\";
      let range;
      if (byteLength2 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = \`>= 0\${n8} and < 2\${n8} ** \${(byteLength2 + 1) * 8}\${n8}\`;
        } else {
          range = \`>= -(2\${n8} ** \${(byteLength2 + 1) * 8 - 1}\${n8}) and < 2 ** \${(byteLength2 + 1) * 8 - 1}\${n8}\`;
        }
      } else {
        range = \`>= \${min}\${n8} and <= \${max}\${n8}\`;
      }
      throw new errors.ERR_OUT_OF_RANGE(\\"value\\", range, value);
    }
    checkBounds(buf, offset, byteLength2);
  }
  function validateNumber(value, name2) {
    if (typeof value !== \\"number\\") {
      throw new errors.ERR_INVALID_ARG_TYPE(name2, \\"number\\", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE(type || \\"offset\\", \\"an integer\\", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(type || \\"offset\\", \`>= \${type ? 1 : 0} and <= \${length}\`, value);
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split(\\"=\\")[0];
    str = str.trim().replace(INVALID_BASE64_RE, \\"\\");
    if (str.length < 2)
      return \\"\\";
    while (str.length % 4 !== 0) {
      str = str + \\"=\\";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i7 = 0; i7 < length; ++i7) {
      codePoint = string.charCodeAt(i7);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i7 + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error(\\"Invalid code point\\");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i7 = 0; i7 < str.length; ++i7) {
      byteArray.push(str.charCodeAt(i7) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c7, hi, lo;
    const byteArray = [];
    for (let i7 = 0; i7 < str.length; ++i7) {
      if ((units -= 2) < 0)
        break;
      c7 = str.charCodeAt(i7);
      hi = c7 >> 8;
      lo = c7 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i7;
    for (i7 = 0; i7 < length; ++i7) {
      if (i7 + offset >= dst.length || i7 >= src.length)
        break;
      dst[i7 + offset] = src[i7];
    }
    return i7;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = \\"0123456789abcdef\\";
    const table = new Array(256);
    for (let i7 = 0; i7 < 16; ++i7) {
      const i16 = i7 * 16;
      for (let j4 = 0; j4 < 16; ++j4) {
        table[i16 + j4] = alphabet[i7] + alphabet[j4];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === \\"undefined\\" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error(\\"BigInt not supported\\");
  }
  return exports$14;
}
var exports6 = dew6();
exports6[\\"Buffer\\"];
exports6[\\"SlowBuffer\\"];
exports6[\\"INSPECT_MAX_BYTES\\"];
exports6[\\"kMaxLength\\"];
var Buffer = exports6.Buffer;
var INSPECT_MAX_BYTES = exports6.INSPECT_MAX_BYTES;
var kMaxLength = exports6.kMaxLength;

// node_modules/.pnpm/@jspm+core@2.0.0-beta.24/node_modules/@jspm/core/nodelibs/browser/fs.js
var exports$h = {};
var _dewExec$f2 = false;
function dew$f2() {
  if (_dewExec$f2)
    return exports$h;
  _dewExec$f2 = true;
  Object.defineProperty(exports$h, \\"__esModule\\", {
    value: true
  });
  exports$h.constants = void 0;
  exports$h.constants = {
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 64,
    O_EXCL: 128,
    O_NOCTTY: 256,
    O_TRUNC: 512,
    O_APPEND: 1024,
    O_DIRECTORY: 65536,
    O_NOATIME: 262144,
    O_NOFOLLOW: 131072,
    O_SYNC: 1052672,
    O_DIRECT: 16384,
    O_NONBLOCK: 2048,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    UV_FS_COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_EXCL: 1,
    COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE_FORCE: 4
  };
  return exports$h;
}
var exports$g2 = {};
var _dewExec$e2 = false;
function dew$e2() {
  if (_dewExec$e2)
    return exports$g2;
  _dewExec$e2 = true;
  if (typeof BigInt === \\"function\\")
    exports$g2.default = BigInt;
  else
    exports$g2.default = function BigIntNotSupported() {
      throw new Error(\\"BigInt is not supported in this environment.\\");
    };
  return exports$g2;
}
var exports$f2 = {};
var _dewExec$d2 = false;
function dew$d2() {
  if (_dewExec$d2)
    return exports$f2;
  _dewExec$d2 = true;
  Object.defineProperty(exports$f2, \\"__esModule\\", {
    value: true
  });
  exports$f2.Stats = void 0;
  var constants_1 = dew$f2();
  var getBigInt_1 = dew$e2();
  var S_IFMT = constants_1.constants.S_IFMT, S_IFDIR = constants_1.constants.S_IFDIR, S_IFREG = constants_1.constants.S_IFREG, S_IFBLK = constants_1.constants.S_IFBLK, S_IFCHR = constants_1.constants.S_IFCHR, S_IFLNK = constants_1.constants.S_IFLNK, S_IFIFO = constants_1.constants.S_IFIFO, S_IFSOCK = constants_1.constants.S_IFSOCK;
  var Stats2 = function() {
    function Stats3() {
    }
    Stats3.build = function(node, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }
      var stats = new Stats3();
      var uid = node.uid, gid = node.gid, atime = node.atime, mtime = node.mtime, ctime = node.ctime;
      var getStatNumber = !bigint ? function(number) {
        return number;
      } : getBigInt_1.default;
      stats.uid = getStatNumber(uid);
      stats.gid = getStatNumber(gid);
      stats.rdev = getStatNumber(0);
      stats.blksize = getStatNumber(4096);
      stats.ino = getStatNumber(node.ino);
      stats.size = getStatNumber(node.getSize());
      stats.blocks = getStatNumber(1);
      stats.atime = atime;
      stats.mtime = mtime;
      stats.ctime = ctime;
      stats.birthtime = ctime;
      stats.atimeMs = getStatNumber(atime.getTime());
      stats.mtimeMs = getStatNumber(mtime.getTime());
      var ctimeMs = getStatNumber(ctime.getTime());
      stats.ctimeMs = ctimeMs;
      stats.birthtimeMs = ctimeMs;
      stats.dev = getStatNumber(0);
      stats.mode = getStatNumber(node.mode);
      stats.nlink = getStatNumber(node.nlink);
      return stats;
    };
    Stats3.prototype._checkModeProperty = function(property) {
      return (Number(this.mode) & S_IFMT) === property;
    };
    Stats3.prototype.isDirectory = function() {
      return this._checkModeProperty(S_IFDIR);
    };
    Stats3.prototype.isFile = function() {
      return this._checkModeProperty(S_IFREG);
    };
    Stats3.prototype.isBlockDevice = function() {
      return this._checkModeProperty(S_IFBLK);
    };
    Stats3.prototype.isCharacterDevice = function() {
      return this._checkModeProperty(S_IFCHR);
    };
    Stats3.prototype.isSymbolicLink = function() {
      return this._checkModeProperty(S_IFLNK);
    };
    Stats3.prototype.isFIFO = function() {
      return this._checkModeProperty(S_IFIFO);
    };
    Stats3.prototype.isSocket = function() {
      return this._checkModeProperty(S_IFSOCK);
    };
    return Stats3;
  }();
  exports$f2.Stats = Stats2;
  exports$f2.default = Stats2;
  return exports$f2;
}
var exports$e2 = {};
var _dewExec$c2 = false;
function dew$c2() {
  if (_dewExec$c2)
    return exports$e2;
  _dewExec$c2 = true;
  var __spreadArray = exports$e2 && exports$e2.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i7 = 0, l7 = from.length, ar; i7 < l7; i7++) {
        if (ar || !(i7 in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i7);
          ar[i7] = from[i7];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports$e2, \\"__esModule\\", {
    value: true
  });
  exports$e2.bufferFrom = exports$e2.bufferAllocUnsafe = exports$e2.Buffer = void 0;
  var buffer_1 = buffer;
  Object.defineProperty(exports$e2, \\"Buffer\\", {
    enumerable: true,
    get: function() {
      return buffer_1.Buffer;
    }
  });
  function bufferV0P12Ponyfill(arg0) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    return new (buffer_1.Buffer.bind.apply(buffer_1.Buffer, __spreadArray([void 0, arg0], args, false)))();
  }
  var bufferAllocUnsafe = buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;
  exports$e2.bufferAllocUnsafe = bufferAllocUnsafe;
  var bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;
  exports$e2.bufferFrom = bufferFrom;
  return exports$e2;
}
var exports$d2 = {};
var _dewExec$b2 = false;
var _global$3 = typeof globalThis !== \\"undefined\\" ? globalThis : typeof self !== \\"undefined\\" ? self : global;
function dew$b2() {
  if (_dewExec$b2)
    return exports$d2;
  _dewExec$b2 = true;
  var __extends = exports$d2 && exports$d2.__extends || function() {
    var extendStatics = function(d6, b5) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d7, b6) {
        d7.__proto__ = b6;
      } || function(d7, b6) {
        for (var p7 in b6)
          if (Object.prototype.hasOwnProperty.call(b6, p7))
            d7[p7] = b6[p7];
      };
      return extendStatics(d6, b5);
    };
    return function(d6, b5) {
      if (typeof b5 !== \\"function\\" && b5 !== null)
        throw new TypeError(\\"Class extends value \\" + String(b5) + \\" is not a constructor or null\\");
      extendStatics(d6, b5);
      function __() {
        this.constructor = d6;
      }
      d6.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
    };
  }();
  Object.defineProperty(exports$d2, \\"__esModule\\", {
    value: true
  });
  exports$d2.E = exports$d2.AssertionError = exports$d2.message = exports$d2.RangeError = exports$d2.TypeError = exports$d2.Error = void 0;
  var assert = et;
  var util = X;
  var kCode = typeof Symbol === \\"undefined\\" ? \\"_kCode\\" : Symbol(\\"code\\");
  var messages = {};
  function makeNodeError(Base) {
    return function(_super) {
      __extends(NodeError, _super);
      function NodeError(key) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var _this = _super.call(this, message(key, args)) || this;
        _this.code = key;
        _this[kCode] = key;
        _this.name = _super.prototype.name + \\" [\\" + _this[kCode] + \\"]\\";
        return _this;
      }
      return NodeError;
    }(Base);
  }
  var g5 = typeof globalThis !== \\"undefined\\" ? globalThis : _global$3;
  var AssertionError2 = function(_super) {
    __extends(AssertionError3, _super);
    function AssertionError3(options) {
      var _this = this;
      if (typeof options !== \\"object\\" || options === null) {
        throw new exports$d2.TypeError(\\"ERR_INVALID_ARG_TYPE\\", \\"options\\", \\"object\\");
      }
      if (options.message) {
        _this = _super.call(this, options.message) || this;
      } else {
        _this = _super.call(this, util.inspect(options.actual).slice(0, 128) + \\" \\" + (options.operator + \\" \\" + util.inspect(options.expected).slice(0, 128))) || this;
      }
      _this.generatedMessage = !options.message;
      _this.name = \\"AssertionError [ERR_ASSERTION]\\";
      _this.code = \\"ERR_ASSERTION\\";
      _this.actual = options.actual;
      _this.expected = options.expected;
      _this.operator = options.operator;
      exports$d2.Error.captureStackTrace(_this, options.stackStartFunction);
      return _this;
    }
    return AssertionError3;
  }(g5.Error);
  exports$d2.AssertionError = AssertionError2;
  function message(key, args) {
    assert.strictEqual(typeof key, \\"string\\");
    var msg = messages[key];
    assert(msg, \\"An invalid error message key was used: \\" + key + \\".\\");
    var fmt;
    if (typeof msg === \\"function\\") {
      fmt = msg;
    } else {
      fmt = util.format;
      if (args === void 0 || args.length === 0)
        return msg;
      args.unshift(msg);
    }
    return String(fmt.apply(null, args));
  }
  exports$d2.message = message;
  function E4(sym, val) {
    messages[sym] = typeof val === \\"function\\" ? val : String(val);
  }
  exports$d2.E = E4;
  exports$d2.Error = makeNodeError(g5.Error);
  exports$d2.TypeError = makeNodeError(g5.TypeError);
  exports$d2.RangeError = makeNodeError(g5.RangeError);
  E4(\\"ERR_ARG_NOT_ITERABLE\\", \\"%s must be iterable\\");
  E4(\\"ERR_ASSERTION\\", \\"%s\\");
  E4(\\"ERR_BUFFER_OUT_OF_BOUNDS\\", bufferOutOfBounds);
  E4(\\"ERR_CHILD_CLOSED_BEFORE_REPLY\\", \\"Child closed before reply received\\");
  E4(\\"ERR_CONSOLE_WRITABLE_STREAM\\", \\"Console expects a writable stream instance for %s\\");
  E4(\\"ERR_CPU_USAGE\\", \\"Unable to obtain cpu usage %s\\");
  E4(\\"ERR_DNS_SET_SERVERS_FAILED\\", function(err, servers) {
    return 'c-ares failed to set servers: \\"' + err + '\\" [' + servers + \\"]\\";
  });
  E4(\\"ERR_FALSY_VALUE_REJECTION\\", \\"Promise was rejected with falsy value\\");
  E4(\\"ERR_ENCODING_NOT_SUPPORTED\\", function(enc) {
    return 'The \\"' + enc + '\\" encoding is not supported';
  });
  E4(\\"ERR_ENCODING_INVALID_ENCODED_DATA\\", function(enc) {
    return \\"The encoded data was not valid for encoding \\" + enc;
  });
  E4(\\"ERR_HTTP_HEADERS_SENT\\", \\"Cannot render headers after they are sent to the client\\");
  E4(\\"ERR_HTTP_INVALID_STATUS_CODE\\", \\"Invalid status code: %s\\");
  E4(\\"ERR_HTTP_TRAILER_INVALID\\", \\"Trailers are invalid with this transfer encoding\\");
  E4(\\"ERR_INDEX_OUT_OF_RANGE\\", \\"Index out of range\\");
  E4(\\"ERR_INVALID_ARG_TYPE\\", invalidArgType);
  E4(\\"ERR_INVALID_ARRAY_LENGTH\\", function(name2, len, actual) {
    assert.strictEqual(typeof actual, \\"number\\");
    return 'The array \\"' + name2 + '\\" (length ' + actual + \\") must be of length \\" + len + \\".\\";
  });
  E4(\\"ERR_INVALID_BUFFER_SIZE\\", \\"Buffer size must be a multiple of %s\\");
  E4(\\"ERR_INVALID_CALLBACK\\", \\"Callback must be a function\\");
  E4(\\"ERR_INVALID_CHAR\\", \\"Invalid character in %s\\");
  E4(\\"ERR_INVALID_CURSOR_POS\\", \\"Cannot set cursor row without setting its column\\");
  E4(\\"ERR_INVALID_FD\\", '\\"fd\\" must be a positive integer: %s');
  E4(\\"ERR_INVALID_FILE_URL_HOST\\", 'File URL host must be \\"localhost\\" or empty on %s');
  E4(\\"ERR_INVALID_FILE_URL_PATH\\", \\"File URL path %s\\");
  E4(\\"ERR_INVALID_HANDLE_TYPE\\", \\"This handle type cannot be sent\\");
  E4(\\"ERR_INVALID_IP_ADDRESS\\", \\"Invalid IP address: %s\\");
  E4(\\"ERR_INVALID_OPT_VALUE\\", function(name2, value) {
    return 'The value \\"' + String(value) + '\\" is invalid for option \\"' + name2 + '\\"';
  });
  E4(\\"ERR_INVALID_OPT_VALUE_ENCODING\\", function(value) {
    return 'The value \\"' + String(value) + '\\" is invalid for option \\"encoding\\"';
  });
  E4(\\"ERR_INVALID_REPL_EVAL_CONFIG\\", 'Cannot specify both \\"breakEvalOnSigint\\" and \\"eval\\" for REPL');
  E4(\\"ERR_INVALID_SYNC_FORK_INPUT\\", \\"Asynchronous forks do not support Buffer, Uint8Array or string input: %s\\");
  E4(\\"ERR_INVALID_THIS\\", 'Value of \\"this\\" must be of type %s');
  E4(\\"ERR_INVALID_TUPLE\\", \\"%s must be an iterable %s tuple\\");
  E4(\\"ERR_INVALID_URL\\", \\"Invalid URL: %s\\");
  E4(\\"ERR_INVALID_URL_SCHEME\\", function(expected) {
    return \\"The URL must be \\" + oneOf(expected, \\"scheme\\");
  });
  E4(\\"ERR_IPC_CHANNEL_CLOSED\\", \\"Channel closed\\");
  E4(\\"ERR_IPC_DISCONNECTED\\", \\"IPC channel is already disconnected\\");
  E4(\\"ERR_IPC_ONE_PIPE\\", \\"Child process can have only one IPC pipe\\");
  E4(\\"ERR_IPC_SYNC_FORK\\", \\"IPC cannot be used with synchronous forks\\");
  E4(\\"ERR_MISSING_ARGS\\", missingArgs);
  E4(\\"ERR_MULTIPLE_CALLBACK\\", \\"Callback called multiple times\\");
  E4(\\"ERR_NAPI_CONS_FUNCTION\\", \\"Constructor must be a function\\");
  E4(\\"ERR_NAPI_CONS_PROTOTYPE_OBJECT\\", \\"Constructor.prototype must be an object\\");
  E4(\\"ERR_NO_CRYPTO\\", \\"Node.js is not compiled with OpenSSL crypto support\\");
  E4(\\"ERR_NO_LONGER_SUPPORTED\\", \\"%s is no longer supported\\");
  E4(\\"ERR_PARSE_HISTORY_DATA\\", \\"Could not parse history data in %s\\");
  E4(\\"ERR_SOCKET_ALREADY_BOUND\\", \\"Socket is already bound\\");
  E4(\\"ERR_SOCKET_BAD_PORT\\", \\"Port should be > 0 and < 65536\\");
  E4(\\"ERR_SOCKET_BAD_TYPE\\", \\"Bad socket type specified. Valid types are: udp4, udp6\\");
  E4(\\"ERR_SOCKET_CANNOT_SEND\\", \\"Unable to send data\\");
  E4(\\"ERR_SOCKET_CLOSED\\", \\"Socket is closed\\");
  E4(\\"ERR_SOCKET_DGRAM_NOT_RUNNING\\", \\"Not running\\");
  E4(\\"ERR_STDERR_CLOSE\\", \\"process.stderr cannot be closed\\");
  E4(\\"ERR_STDOUT_CLOSE\\", \\"process.stdout cannot be closed\\");
  E4(\\"ERR_STREAM_WRAP\\", \\"Stream has StringDecoder set or is in objectMode\\");
  E4(\\"ERR_TLS_CERT_ALTNAME_INVALID\\", \\"Hostname/IP does not match certificate's altnames: %s\\");
  E4(\\"ERR_TLS_DH_PARAM_SIZE\\", function(size) {
    return \\"DH parameter size \\" + size + \\" is less than 2048\\";
  });
  E4(\\"ERR_TLS_HANDSHAKE_TIMEOUT\\", \\"TLS handshake timeout\\");
  E4(\\"ERR_TLS_RENEGOTIATION_FAILED\\", \\"Failed to renegotiate\\");
  E4(\\"ERR_TLS_REQUIRED_SERVER_NAME\\", '\\"servername\\" is required parameter for Server.addContext');
  E4(\\"ERR_TLS_SESSION_ATTACK\\", \\"TSL session renegotiation attack detected\\");
  E4(\\"ERR_TRANSFORM_ALREADY_TRANSFORMING\\", \\"Calling transform done when still transforming\\");
  E4(\\"ERR_TRANSFORM_WITH_LENGTH_0\\", \\"Calling transform done when writableState.length != 0\\");
  E4(\\"ERR_UNKNOWN_ENCODING\\", \\"Unknown encoding: %s\\");
  E4(\\"ERR_UNKNOWN_SIGNAL\\", \\"Unknown signal: %s\\");
  E4(\\"ERR_UNKNOWN_STDIN_TYPE\\", \\"Unknown stdin file type\\");
  E4(\\"ERR_UNKNOWN_STREAM_TYPE\\", \\"Unknown stream file type\\");
  E4(\\"ERR_V8BREAKITERATOR\\", \\"Full ICU data not installed. See https://github.com/nodejs/node/wiki/Intl\\");
  function invalidArgType(name2, expected, actual) {
    assert(name2, \\"name is required\\");
    var determiner;
    if (expected.includes(\\"not \\")) {
      determiner = \\"must not be\\";
      expected = expected.split(\\"not \\")[1];
    } else {
      determiner = \\"must be\\";
    }
    var msg;
    if (Array.isArray(name2)) {
      var names = name2.map(function(val) {
        return '\\"' + val + '\\"';
      }).join(\\", \\");
      msg = \\"The \\" + names + \\" arguments \\" + determiner + \\" \\" + oneOf(expected, \\"type\\");
    } else if (name2.includes(\\" argument\\")) {
      msg = \\"The \\" + name2 + \\" \\" + determiner + \\" \\" + oneOf(expected, \\"type\\");
    } else {
      var type = name2.includes(\\".\\") ? \\"property\\" : \\"argument\\";
      msg = 'The \\"' + name2 + '\\" ' + type + \\" \\" + determiner + \\" \\" + oneOf(expected, \\"type\\");
    }
    if (arguments.length >= 3) {
      msg += \\". Received type \\" + (actual !== null ? typeof actual : \\"null\\");
    }
    return msg;
  }
  function missingArgs() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    assert(args.length > 0, \\"At least one arg needs to be specified\\");
    var msg = \\"The \\";
    var len = args.length;
    args = args.map(function(a7) {
      return '\\"' + a7 + '\\"';
    });
    switch (len) {
      case 1:
        msg += args[0] + \\" argument\\";
        break;
      case 2:
        msg += args[0] + \\" and \\" + args[1] + \\" arguments\\";
        break;
      default:
        msg += args.slice(0, len - 1).join(\\", \\");
        msg += \\", and \\" + args[len - 1] + \\" arguments\\";
        break;
    }
    return msg + \\" must be specified\\";
  }
  function oneOf(expected, thing) {
    assert(expected, \\"expected is required\\");
    assert(typeof thing === \\"string\\", \\"thing is required\\");
    if (Array.isArray(expected)) {
      var len = expected.length;
      assert(len > 0, \\"At least one expected value needs to be specified\\");
      expected = expected.map(function(i7) {
        return String(i7);
      });
      if (len > 2) {
        return \\"one of \\" + thing + \\" \\" + expected.slice(0, len - 1).join(\\", \\") + \\", or \\" + expected[len - 1];
      } else if (len === 2) {
        return \\"one of \\" + thing + \\" \\" + expected[0] + \\" or \\" + expected[1];
      } else {
        return \\"of \\" + thing + \\" \\" + expected[0];
      }
    } else {
      return \\"of \\" + thing + \\" \\" + String(expected);
    }
  }
  function bufferOutOfBounds(name2, isWriting) {
    if (isWriting) {
      return \\"Attempt to write outside buffer bounds\\";
    } else {
      return '\\"' + name2 + '\\" is outside of buffer bounds';
    }
  }
  return exports$d2;
}
var exports$c2 = {};
var _dewExec$a2 = false;
function dew$a2() {
  if (_dewExec$a2)
    return exports$c2;
  _dewExec$a2 = true;
  Object.defineProperty(exports$c2, \\"__esModule\\", {
    value: true
  });
  exports$c2.strToEncoding = exports$c2.assertEncoding = exports$c2.ENCODING_UTF8 = void 0;
  var buffer_1 = dew$c2();
  var errors = dew$b2();
  exports$c2.ENCODING_UTF8 = \\"utf8\\";
  function assertEncoding(encoding) {
    if (encoding && !buffer_1.Buffer.isEncoding(encoding))
      throw new errors.TypeError(\\"ERR_INVALID_OPT_VALUE_ENCODING\\", encoding);
  }
  exports$c2.assertEncoding = assertEncoding;
  function strToEncoding(str, encoding) {
    if (!encoding || encoding === exports$c2.ENCODING_UTF8)
      return str;
    if (encoding === \\"buffer\\")
      return new buffer_1.Buffer(str);
    return new buffer_1.Buffer(str).toString(encoding);
  }
  exports$c2.strToEncoding = strToEncoding;
  return exports$c2;
}
var exports$b2 = {};
var _dewExec$92 = false;
function dew$92() {
  if (_dewExec$92)
    return exports$b2;
  _dewExec$92 = true;
  Object.defineProperty(exports$b2, \\"__esModule\\", {
    value: true
  });
  exports$b2.Dirent = void 0;
  var constants_1 = dew$f2();
  var encoding_1 = dew$a2();
  var S_IFMT = constants_1.constants.S_IFMT, S_IFDIR = constants_1.constants.S_IFDIR, S_IFREG = constants_1.constants.S_IFREG, S_IFBLK = constants_1.constants.S_IFBLK, S_IFCHR = constants_1.constants.S_IFCHR, S_IFLNK = constants_1.constants.S_IFLNK, S_IFIFO = constants_1.constants.S_IFIFO, S_IFSOCK = constants_1.constants.S_IFSOCK;
  var Dirent2 = function() {
    function Dirent3() {
      this.name = \\"\\";
      this.mode = 0;
    }
    Dirent3.build = function(link2, encoding) {
      var dirent = new Dirent3();
      var mode = link2.getNode().mode;
      dirent.name = (0, encoding_1.strToEncoding)(link2.getName(), encoding);
      dirent.mode = mode;
      return dirent;
    };
    Dirent3.prototype._checkModeProperty = function(property) {
      return (this.mode & S_IFMT) === property;
    };
    Dirent3.prototype.isDirectory = function() {
      return this._checkModeProperty(S_IFDIR);
    };
    Dirent3.prototype.isFile = function() {
      return this._checkModeProperty(S_IFREG);
    };
    Dirent3.prototype.isBlockDevice = function() {
      return this._checkModeProperty(S_IFBLK);
    };
    Dirent3.prototype.isCharacterDevice = function() {
      return this._checkModeProperty(S_IFCHR);
    };
    Dirent3.prototype.isSymbolicLink = function() {
      return this._checkModeProperty(S_IFLNK);
    };
    Dirent3.prototype.isFIFO = function() {
      return this._checkModeProperty(S_IFIFO);
    };
    Dirent3.prototype.isSocket = function() {
      return this._checkModeProperty(S_IFSOCK);
    };
    return Dirent3;
  }();
  exports$b2.Dirent = Dirent2;
  exports$b2.default = Dirent2;
  return exports$b2;
}
var exports$a2 = {};
var _dewExec$82 = false;
var _global$22 = typeof globalThis !== \\"undefined\\" ? globalThis : typeof self !== \\"undefined\\" ? self : global;
function dew$82() {
  if (_dewExec$82)
    return exports$a2;
  _dewExec$82 = true;
  var process$1 = process;
  Object.defineProperty(exports$a2, \\"__esModule\\", {
    value: true
  });
  var _setImmediate;
  if (typeof process$1.nextTick === \\"function\\")
    _setImmediate = process$1.nextTick.bind(typeof globalThis !== \\"undefined\\" ? globalThis : _global$22);
  else
    _setImmediate = setTimeout.bind(typeof globalThis !== \\"undefined\\" ? globalThis : _global$22);
  exports$a2.default = _setImmediate;
  return exports$a2;
}
var exports$92 = {};
var _dewExec$72 = false;
function dew$72() {
  if (_dewExec$72)
    return exports$92;
  _dewExec$72 = true;
  var process$1 = process;
  Object.defineProperty(exports$92, \\"__esModule\\", {
    value: true
  });
  exports$92.createProcess = void 0;
  var maybeReturnProcess = function() {
    if (typeof process$1 !== \\"undefined\\") {
      return process$1;
    }
    try {
      return process;
    } catch (_a) {
      return void 0;
    }
  };
  function createProcess() {
    var p7 = maybeReturnProcess() || {};
    if (!p7.getuid)
      p7.getuid = function() {
        return 0;
      };
    if (!p7.getgid)
      p7.getgid = function() {
        return 0;
      };
    if (!p7.cwd)
      p7.cwd = function() {
        return \\"/\\";
      };
    if (!p7.nextTick)
      p7.nextTick = dew$82().default;
    if (!p7.emitWarning)
      p7.emitWarning = function(message, type) {
        console.warn(\\"\\" + type + (type ? \\": \\" : \\"\\") + message);
      };
    if (!p7.env)
      p7.env = {};
    return p7;
  }
  exports$92.createProcess = createProcess;
  exports$92.default = createProcess();
  return exports$92;
}
var exports$82 = {};
var _dewExec$62 = false;
function dew$62() {
  if (_dewExec$62)
    return exports$82;
  _dewExec$62 = true;
  var __extends = exports$82 && exports$82.__extends || function() {
    var extendStatics = function(d6, b5) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d7, b6) {
        d7.__proto__ = b6;
      } || function(d7, b6) {
        for (var p7 in b6)
          if (Object.prototype.hasOwnProperty.call(b6, p7))
            d7[p7] = b6[p7];
      };
      return extendStatics(d6, b5);
    };
    return function(d6, b5) {
      if (typeof b5 !== \\"function\\" && b5 !== null)
        throw new TypeError(\\"Class extends value \\" + String(b5) + \\" is not a constructor or null\\");
      extendStatics(d6, b5);
      function __() {
        this.constructor = d6;
      }
      d6.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
    };
  }();
  Object.defineProperty(exports$82, \\"__esModule\\", {
    value: true
  });
  exports$82.File = exports$82.Link = exports$82.Node = exports$82.SEP = void 0;
  var process_1 = dew$72();
  var buffer_1 = dew$c2();
  var constants_1 = dew$f2();
  var events_1 = y;
  var Stats_1 = dew$d2();
  var S_IFMT = constants_1.constants.S_IFMT, S_IFDIR = constants_1.constants.S_IFDIR, S_IFREG = constants_1.constants.S_IFREG, S_IFLNK = constants_1.constants.S_IFLNK, O_APPEND = constants_1.constants.O_APPEND;
  exports$82.SEP = \\"/\\";
  var Node = function(_super) {
    __extends(Node2, _super);
    function Node2(ino, perm) {
      if (perm === void 0) {
        perm = 438;
      }
      var _this = _super.call(this) || this;
      _this.uid = process_1.default.getuid();
      _this.gid = process_1.default.getgid();
      _this.atime = new Date();
      _this.mtime = new Date();
      _this.ctime = new Date();
      _this.perm = 438;
      _this.mode = S_IFREG;
      _this.nlink = 1;
      _this.perm = perm;
      _this.mode |= perm;
      _this.ino = ino;
      return _this;
    }
    Node2.prototype.getString = function(encoding) {
      if (encoding === void 0) {
        encoding = \\"utf8\\";
      }
      return this.getBuffer().toString(encoding);
    };
    Node2.prototype.setString = function(str) {
      this.buf = (0, buffer_1.bufferFrom)(str, \\"utf8\\");
      this.touch();
    };
    Node2.prototype.getBuffer = function() {
      if (!this.buf)
        this.setBuffer((0, buffer_1.bufferAllocUnsafe)(0));
      return (0, buffer_1.bufferFrom)(this.buf);
    };
    Node2.prototype.setBuffer = function(buf) {
      this.buf = (0, buffer_1.bufferFrom)(buf);
      this.touch();
    };
    Node2.prototype.getSize = function() {
      return this.buf ? this.buf.length : 0;
    };
    Node2.prototype.setModeProperty = function(property) {
      this.mode = this.mode & ~S_IFMT | property;
    };
    Node2.prototype.setIsFile = function() {
      this.setModeProperty(S_IFREG);
    };
    Node2.prototype.setIsDirectory = function() {
      this.setModeProperty(S_IFDIR);
    };
    Node2.prototype.setIsSymlink = function() {
      this.setModeProperty(S_IFLNK);
    };
    Node2.prototype.isFile = function() {
      return (this.mode & S_IFMT) === S_IFREG;
    };
    Node2.prototype.isDirectory = function() {
      return (this.mode & S_IFMT) === S_IFDIR;
    };
    Node2.prototype.isSymlink = function() {
      return (this.mode & S_IFMT) === S_IFLNK;
    };
    Node2.prototype.makeSymlink = function(steps) {
      this.symlink = steps;
      this.setIsSymlink();
    };
    Node2.prototype.write = function(buf, off, len, pos) {
      if (off === void 0) {
        off = 0;
      }
      if (len === void 0) {
        len = buf.length;
      }
      if (pos === void 0) {
        pos = 0;
      }
      if (!this.buf)
        this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
      if (pos + len > this.buf.length) {
        var newBuf = (0, buffer_1.bufferAllocUnsafe)(pos + len);
        this.buf.copy(newBuf, 0, 0, this.buf.length);
        this.buf = newBuf;
      }
      buf.copy(this.buf, pos, off, off + len);
      this.touch();
      return len;
    };
    Node2.prototype.read = function(buf, off, len, pos) {
      if (off === void 0) {
        off = 0;
      }
      if (len === void 0) {
        len = buf.byteLength;
      }
      if (pos === void 0) {
        pos = 0;
      }
      if (!this.buf)
        this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
      var actualLen = len;
      if (actualLen > buf.byteLength) {
        actualLen = buf.byteLength;
      }
      if (actualLen + pos > this.buf.length) {
        actualLen = this.buf.length - pos;
      }
      this.buf.copy(buf, off, pos, pos + actualLen);
      return actualLen;
    };
    Node2.prototype.truncate = function(len) {
      if (len === void 0) {
        len = 0;
      }
      if (!len)
        this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
      else {
        if (!this.buf)
          this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        if (len <= this.buf.length) {
          this.buf = this.buf.slice(0, len);
        } else {
          var buf = (0, buffer_1.bufferAllocUnsafe)(0);
          this.buf.copy(buf);
          buf.fill(0, len);
        }
      }
      this.touch();
    };
    Node2.prototype.chmod = function(perm) {
      this.perm = perm;
      this.mode = this.mode & ~511 | perm;
      this.touch();
    };
    Node2.prototype.chown = function(uid, gid) {
      this.uid = uid;
      this.gid = gid;
      this.touch();
    };
    Node2.prototype.touch = function() {
      this.mtime = new Date();
      this.emit(\\"change\\", this);
    };
    Node2.prototype.canRead = function(uid, gid) {
      if (uid === void 0) {
        uid = process_1.default.getuid();
      }
      if (gid === void 0) {
        gid = process_1.default.getgid();
      }
      if (this.perm & 4) {
        return true;
      }
      if (gid === this.gid) {
        if (this.perm & 32) {
          return true;
        }
      }
      if (uid === this.uid) {
        if (this.perm & 256) {
          return true;
        }
      }
      return false;
    };
    Node2.prototype.canWrite = function(uid, gid) {
      if (uid === void 0) {
        uid = process_1.default.getuid();
      }
      if (gid === void 0) {
        gid = process_1.default.getgid();
      }
      if (this.perm & 2) {
        return true;
      }
      if (gid === this.gid) {
        if (this.perm & 16) {
          return true;
        }
      }
      if (uid === this.uid) {
        if (this.perm & 128) {
          return true;
        }
      }
      return false;
    };
    Node2.prototype.del = function() {
      this.emit(\\"delete\\", this);
    };
    Node2.prototype.toJSON = function() {
      return {
        ino: this.ino,
        uid: this.uid,
        gid: this.gid,
        atime: this.atime.getTime(),
        mtime: this.mtime.getTime(),
        ctime: this.ctime.getTime(),
        perm: this.perm,
        mode: this.mode,
        nlink: this.nlink,
        symlink: this.symlink,
        data: this.getString()
      };
    };
    return Node2;
  }(events_1.EventEmitter);
  exports$82.Node = Node;
  var Link = function(_super) {
    __extends(Link2, _super);
    function Link2(vol2, parent, name2) {
      var _this = _super.call(this) || this;
      _this.children = {};
      _this.steps = [];
      _this.ino = 0;
      _this.length = 0;
      _this.vol = vol2;
      _this.parent = parent;
      _this.steps = parent ? parent.steps.concat([name2]) : [name2];
      return _this;
    }
    Link2.prototype.setNode = function(node) {
      this.node = node;
      this.ino = node.ino;
    };
    Link2.prototype.getNode = function() {
      return this.node;
    };
    Link2.prototype.createChild = function(name2, node) {
      if (node === void 0) {
        node = this.vol.createNode();
      }
      var link2 = new Link2(this.vol, this, name2);
      link2.setNode(node);
      if (node.isDirectory())
        ;
      this.setChild(name2, link2);
      return link2;
    };
    Link2.prototype.setChild = function(name2, link2) {
      if (link2 === void 0) {
        link2 = new Link2(this.vol, this, name2);
      }
      this.children[name2] = link2;
      link2.parent = this;
      this.length++;
      this.emit(\\"child:add\\", link2, this);
      return link2;
    };
    Link2.prototype.deleteChild = function(link2) {
      delete this.children[link2.getName()];
      this.length--;
      this.emit(\\"child:delete\\", link2, this);
    };
    Link2.prototype.getChild = function(name2) {
      if (Object.hasOwnProperty.call(this.children, name2)) {
        return this.children[name2];
      }
    };
    Link2.prototype.getPath = function() {
      return this.steps.join(exports$82.SEP);
    };
    Link2.prototype.getName = function() {
      return this.steps[this.steps.length - 1];
    };
    Link2.prototype.walk = function(steps, stop, i7) {
      if (stop === void 0) {
        stop = steps.length;
      }
      if (i7 === void 0) {
        i7 = 0;
      }
      if (i7 >= steps.length)
        return this;
      if (i7 >= stop)
        return this;
      var step = steps[i7];
      var link2 = this.getChild(step);
      if (!link2)
        return null;
      return link2.walk(steps, stop, i7 + 1);
    };
    Link2.prototype.toJSON = function() {
      return {
        steps: this.steps,
        ino: this.ino,
        children: Object.keys(this.children)
      };
    };
    return Link2;
  }(events_1.EventEmitter);
  exports$82.Link = Link;
  var File = function() {
    function File2(link2, node, flags, fd) {
      this.position = 0;
      this.link = link2;
      this.node = node;
      this.flags = flags;
      this.fd = fd;
    }
    File2.prototype.getString = function(encoding) {
      return this.node.getString();
    };
    File2.prototype.setString = function(str) {
      this.node.setString(str);
    };
    File2.prototype.getBuffer = function() {
      return this.node.getBuffer();
    };
    File2.prototype.setBuffer = function(buf) {
      this.node.setBuffer(buf);
    };
    File2.prototype.getSize = function() {
      return this.node.getSize();
    };
    File2.prototype.truncate = function(len) {
      this.node.truncate(len);
    };
    File2.prototype.seekTo = function(position) {
      this.position = position;
    };
    File2.prototype.stats = function() {
      return Stats_1.default.build(this.node);
    };
    File2.prototype.write = function(buf, offset, length, position) {
      if (offset === void 0) {
        offset = 0;
      }
      if (length === void 0) {
        length = buf.length;
      }
      if (typeof position !== \\"number\\")
        position = this.position;
      if (this.flags & O_APPEND)
        position = this.getSize();
      var bytes = this.node.write(buf, offset, length, position);
      this.position = position + bytes;
      return bytes;
    };
    File2.prototype.read = function(buf, offset, length, position) {
      if (offset === void 0) {
        offset = 0;
      }
      if (length === void 0) {
        length = buf.byteLength;
      }
      if (typeof position !== \\"number\\")
        position = this.position;
      var bytes = this.node.read(buf, offset, length, position);
      this.position = position + bytes;
      return bytes;
    };
    File2.prototype.chmod = function(perm) {
      this.node.chmod(perm);
    };
    File2.prototype.chown = function(uid, gid) {
      this.node.chown(uid, gid);
    };
    return File2;
  }();
  exports$82.File = File;
  return exports$82;
}
var exports$72 = {};
var _dewExec$52 = false;
var _global$12 = typeof globalThis !== \\"undefined\\" ? globalThis : typeof self !== \\"undefined\\" ? self : global;
function dew$52() {
  if (_dewExec$52)
    return exports$72;
  _dewExec$52 = true;
  Object.defineProperty(exports$72, \\"__esModule\\", {
    value: true
  });
  function setTimeoutUnref(callback, time, args) {
    var ref = setTimeout.apply(typeof globalThis !== \\"undefined\\" ? globalThis : _global$12, arguments);
    if (ref && typeof ref === \\"object\\" && typeof ref.unref === \\"function\\")
      ref.unref();
    return ref;
  }
  exports$72.default = setTimeoutUnref;
  return exports$72;
}
var exports$62 = {};
var _dewExec$42 = false;
function dew$42() {
  if (_dewExec$42)
    return exports$62;
  _dewExec$42 = true;
  var __spreadArray = exports$62 && exports$62.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i7 = 0, l7 = from.length, ar; i7 < l7; i7++) {
        if (ar || !(i7 in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i7);
          ar[i7] = from[i7];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports$62, \\"__esModule\\", {
    value: true
  });
  exports$62.FileHandle = void 0;
  function promisify3(vol2, fn, getResult) {
    if (getResult === void 0) {
      getResult = function(input) {
        return input;
      };
    }
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new Promise(function(resolve3, reject) {
        vol2[fn].bind(vol2).apply(void 0, __spreadArray(__spreadArray([], args, false), [function(error, result) {
          if (error)
            return reject(error);
          return resolve3(getResult(result));
        }], false));
      });
    };
  }
  var FileHandle = function() {
    function FileHandle2(vol2, fd) {
      this.vol = vol2;
      this.fd = fd;
    }
    FileHandle2.prototype.appendFile = function(data, options) {
      return promisify3(this.vol, \\"appendFile\\")(this.fd, data, options);
    };
    FileHandle2.prototype.chmod = function(mode) {
      return promisify3(this.vol, \\"fchmod\\")(this.fd, mode);
    };
    FileHandle2.prototype.chown = function(uid, gid) {
      return promisify3(this.vol, \\"fchown\\")(this.fd, uid, gid);
    };
    FileHandle2.prototype.close = function() {
      return promisify3(this.vol, \\"close\\")(this.fd);
    };
    FileHandle2.prototype.datasync = function() {
      return promisify3(this.vol, \\"fdatasync\\")(this.fd);
    };
    FileHandle2.prototype.read = function(buffer2, offset, length, position) {
      return promisify3(this.vol, \\"read\\", function(bytesRead) {
        return {
          bytesRead,
          buffer: buffer2
        };
      })(this.fd, buffer2, offset, length, position);
    };
    FileHandle2.prototype.readFile = function(options) {
      return promisify3(this.vol, \\"readFile\\")(this.fd, options);
    };
    FileHandle2.prototype.stat = function(options) {
      return promisify3(this.vol, \\"fstat\\")(this.fd, options);
    };
    FileHandle2.prototype.sync = function() {
      return promisify3(this.vol, \\"fsync\\")(this.fd);
    };
    FileHandle2.prototype.truncate = function(len) {
      return promisify3(this.vol, \\"ftruncate\\")(this.fd, len);
    };
    FileHandle2.prototype.utimes = function(atime, mtime) {
      return promisify3(this.vol, \\"futimes\\")(this.fd, atime, mtime);
    };
    FileHandle2.prototype.write = function(buffer2, offset, length, position) {
      return promisify3(this.vol, \\"write\\", function(bytesWritten) {
        return {
          bytesWritten,
          buffer: buffer2
        };
      })(this.fd, buffer2, offset, length, position);
    };
    FileHandle2.prototype.writeFile = function(data, options) {
      return promisify3(this.vol, \\"writeFile\\")(this.fd, data, options);
    };
    return FileHandle2;
  }();
  exports$62.FileHandle = FileHandle;
  function createPromisesApi(vol2) {
    if (typeof Promise === \\"undefined\\")
      return null;
    return {
      FileHandle,
      access: function(path2, mode) {
        return promisify3(vol2, \\"access\\")(path2, mode);
      },
      appendFile: function(path2, data, options) {
        return promisify3(vol2, \\"appendFile\\")(path2 instanceof FileHandle ? path2.fd : path2, data, options);
      },
      chmod: function(path2, mode) {
        return promisify3(vol2, \\"chmod\\")(path2, mode);
      },
      chown: function(path2, uid, gid) {
        return promisify3(vol2, \\"chown\\")(path2, uid, gid);
      },
      copyFile: function(src, dest, flags) {
        return promisify3(vol2, \\"copyFile\\")(src, dest, flags);
      },
      lchmod: function(path2, mode) {
        return promisify3(vol2, \\"lchmod\\")(path2, mode);
      },
      lchown: function(path2, uid, gid) {
        return promisify3(vol2, \\"lchown\\")(path2, uid, gid);
      },
      link: function(existingPath, newPath) {
        return promisify3(vol2, \\"link\\")(existingPath, newPath);
      },
      lstat: function(path2, options) {
        return promisify3(vol2, \\"lstat\\")(path2, options);
      },
      mkdir: function(path2, options) {
        return promisify3(vol2, \\"mkdir\\")(path2, options);
      },
      mkdtemp: function(prefix, options) {
        return promisify3(vol2, \\"mkdtemp\\")(prefix, options);
      },
      open: function(path2, flags, mode) {
        return promisify3(vol2, \\"open\\", function(fd) {
          return new FileHandle(vol2, fd);
        })(path2, flags, mode);
      },
      readdir: function(path2, options) {
        return promisify3(vol2, \\"readdir\\")(path2, options);
      },
      readFile: function(id, options) {
        return promisify3(vol2, \\"readFile\\")(id instanceof FileHandle ? id.fd : id, options);
      },
      readlink: function(path2, options) {
        return promisify3(vol2, \\"readlink\\")(path2, options);
      },
      realpath: function(path2, options) {
        return promisify3(vol2, \\"realpath\\")(path2, options);
      },
      rename: function(oldPath, newPath) {
        return promisify3(vol2, \\"rename\\")(oldPath, newPath);
      },
      rmdir: function(path2) {
        return promisify3(vol2, \\"rmdir\\")(path2);
      },
      stat: function(path2, options) {
        return promisify3(vol2, \\"stat\\")(path2, options);
      },
      symlink: function(target, path2, type) {
        return promisify3(vol2, \\"symlink\\")(target, path2, type);
      },
      truncate: function(path2, len) {
        return promisify3(vol2, \\"truncate\\")(path2, len);
      },
      unlink: function(path2) {
        return promisify3(vol2, \\"unlink\\")(path2);
      },
      utimes: function(path2, atime, mtime) {
        return promisify3(vol2, \\"utimes\\")(path2, atime, mtime);
      },
      writeFile: function(id, data, options) {
        return promisify3(vol2, \\"writeFile\\")(id instanceof FileHandle ? id.fd : id, data, options);
      }
    };
  }
  exports$62.default = createPromisesApi;
  return exports$62;
}
var exports$52 = {};
var _dewExec$32 = false;
function dew$32() {
  if (_dewExec$32)
    return exports$52;
  _dewExec$32 = true;
  var process$1 = process;
  Object.defineProperty(exports$52, \\"__esModule\\", {
    value: true
  });
  exports$52.unixify = unixify;
  exports$52.correctPath = correctPath;
  var isWin = process$1.platform === \\"win32\\";
  function removeTrailingSeparator(str) {
    var i7 = str.length - 1;
    if (i7 < 2) {
      return str;
    }
    while (isSeparator(str, i7)) {
      i7--;
    }
    return str.substr(0, i7 + 1);
  }
  function isSeparator(str, i7) {
    var _char = str[i7];
    return i7 > 0 && (_char === \\"/\\" || isWin && _char === \\"\\\\\\\\\\");
  }
  function normalizePath(str, stripTrailing) {
    if (typeof str !== \\"string\\") {
      throw new TypeError(\\"expected a string\\");
    }
    str = str.replace(/[\\\\\\\\\\\\/]+/g, \\"/\\");
    if (stripTrailing !== false) {
      str = removeTrailingSeparator(str);
    }
    return str;
  }
  function unixify(filepath) {
    var stripTrailing = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (isWin) {
      filepath = normalizePath(filepath, stripTrailing);
      return filepath.replace(/^([a-zA-Z]+:|\\\\.\\\\/)/, \\"\\");
    }
    return filepath;
  }
  function correctPath(filepath) {
    return unixify(filepath.replace(/^\\\\\\\\\\\\\\\\\\\\?\\\\\\\\.:\\\\\\\\/, \\"\\\\\\\\\\"));
  }
  return exports$52;
}
var exports$42 = {};
var _dewExec$23 = false;
var _global4 = typeof globalThis !== \\"undefined\\" ? globalThis : typeof self !== \\"undefined\\" ? self : global;
function dew$23() {
  if (_dewExec$23)
    return exports$42;
  _dewExec$23 = true;
  var __extends = exports$42 && exports$42.__extends || function() {
    var extendStatics = function(d6, b5) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d7, b6) {
        d7.__proto__ = b6;
      } || function(d7, b6) {
        for (var p7 in b6)
          if (Object.prototype.hasOwnProperty.call(b6, p7))
            d7[p7] = b6[p7];
      };
      return extendStatics(d6, b5);
    };
    return function(d6, b5) {
      if (typeof b5 !== \\"function\\" && b5 !== null)
        throw new TypeError(\\"Class extends value \\" + String(b5) + \\" is not a constructor or null\\");
      extendStatics(d6, b5);
      function __() {
        this.constructor = d6;
      }
      d6.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
    };
  }();
  var __spreadArray = exports$42 && exports$42.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i7 = 0, l7 = from.length, ar; i7 < l7; i7++) {
        if (ar || !(i7 in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i7);
          ar[i7] = from[i7];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports$42, \\"__esModule\\", {
    value: true
  });
  exports$42.FSWatcher = exports$42.StatWatcher = exports$42.Volume = exports$42.toUnixTimestamp = exports$42.bufferToEncoding = exports$42.dataToBuffer = exports$42.dataToStr = exports$42.pathToSteps = exports$42.filenameToSteps = exports$42.pathToFilename = exports$42.flagsToNumber = exports$42.FLAGS = void 0;
  var pathModule = exports3;
  var node_1 = dew$62();
  var Stats_1 = dew$d2();
  var Dirent_1 = dew$92();
  var buffer_1 = dew$c2();
  var setImmediate_1 = dew$82();
  var process_1 = dew$72();
  var setTimeoutUnref_1 = dew$52();
  var stream_1 = exports4;
  var constants_1 = dew$f2();
  var events_1 = y;
  var encoding_1 = dew$a2();
  var errors = dew$b2();
  var util = X;
  var promises_1 = dew$42();
  var resolveCrossPlatform = pathModule.resolve;
  var O_RDONLY = constants_1.constants.O_RDONLY, O_WRONLY = constants_1.constants.O_WRONLY, O_RDWR = constants_1.constants.O_RDWR, O_CREAT = constants_1.constants.O_CREAT, O_EXCL = constants_1.constants.O_EXCL, O_TRUNC = constants_1.constants.O_TRUNC, O_APPEND = constants_1.constants.O_APPEND, O_SYNC = constants_1.constants.O_SYNC, O_DIRECTORY = constants_1.constants.O_DIRECTORY, F_OK2 = constants_1.constants.F_OK, COPYFILE_EXCL = constants_1.constants.COPYFILE_EXCL, COPYFILE_FICLONE_FORCE = constants_1.constants.COPYFILE_FICLONE_FORCE;
  var _a = pathModule.posix ? pathModule.posix : pathModule, sep2 = _a.sep, relative2 = _a.relative, join2 = _a.join, dirname2 = _a.dirname;
  var isWin = process_1.default.platform === \\"win32\\";
  var kMinPoolSpace = 128;
  var ERRSTR = {
    PATH_STR: \\"path must be a string or Buffer\\",
    FD: \\"fd must be a file descriptor\\",
    MODE_INT: \\"mode must be an int\\",
    CB: \\"callback must be a function\\",
    UID: \\"uid must be an unsigned int\\",
    GID: \\"gid must be an unsigned int\\",
    LEN: \\"len must be an integer\\",
    ATIME: \\"atime must be an integer\\",
    MTIME: \\"mtime must be an integer\\",
    PREFIX: \\"filename prefix is required\\",
    BUFFER: \\"buffer must be an instance of Buffer or StaticBuffer\\",
    OFFSET: \\"offset must be an integer\\",
    LENGTH: \\"length must be an integer\\",
    POSITION: \\"position must be an integer\\"
  };
  var ERRSTR_OPTS = function(tipeof) {
    return \\"Expected options to be either an object or a string, but got \\" + tipeof + \\" instead\\";
  };
  var ENOENT = \\"ENOENT\\";
  var EBADF = \\"EBADF\\";
  var EINVAL = \\"EINVAL\\";
  var EPERM = \\"EPERM\\";
  var EPROTO = \\"EPROTO\\";
  var EEXIST = \\"EEXIST\\";
  var ENOTDIR = \\"ENOTDIR\\";
  var EMFILE = \\"EMFILE\\";
  var EACCES = \\"EACCES\\";
  var EISDIR = \\"EISDIR\\";
  var ENOTEMPTY = \\"ENOTEMPTY\\";
  var ENOSYS = \\"ENOSYS\\";
  function formatError(errorCode, func, path2, path22) {
    if (func === void 0) {
      func = \\"\\";
    }
    if (path2 === void 0) {
      path2 = \\"\\";
    }
    if (path22 === void 0) {
      path22 = \\"\\";
    }
    var pathFormatted = \\"\\";
    if (path2)
      pathFormatted = \\" '\\" + path2 + \\"'\\";
    if (path22)
      pathFormatted += \\" -> '\\" + path22 + \\"'\\";
    switch (errorCode) {
      case ENOENT:
        return \\"ENOENT: no such file or directory, \\" + func + pathFormatted;
      case EBADF:
        return \\"EBADF: bad file descriptor, \\" + func + pathFormatted;
      case EINVAL:
        return \\"EINVAL: invalid argument, \\" + func + pathFormatted;
      case EPERM:
        return \\"EPERM: operation not permitted, \\" + func + pathFormatted;
      case EPROTO:
        return \\"EPROTO: protocol error, \\" + func + pathFormatted;
      case EEXIST:
        return \\"EEXIST: file already exists, \\" + func + pathFormatted;
      case ENOTDIR:
        return \\"ENOTDIR: not a directory, \\" + func + pathFormatted;
      case EISDIR:
        return \\"EISDIR: illegal operation on a directory, \\" + func + pathFormatted;
      case EACCES:
        return \\"EACCES: permission denied, \\" + func + pathFormatted;
      case ENOTEMPTY:
        return \\"ENOTEMPTY: directory not empty, \\" + func + pathFormatted;
      case EMFILE:
        return \\"EMFILE: too many open files, \\" + func + pathFormatted;
      case ENOSYS:
        return \\"ENOSYS: function not implemented, \\" + func + pathFormatted;
      default:
        return errorCode + \\": error occurred, \\" + func + pathFormatted;
    }
  }
  function createError(errorCode, func, path2, path22, Constructor) {
    if (func === void 0) {
      func = \\"\\";
    }
    if (path2 === void 0) {
      path2 = \\"\\";
    }
    if (path22 === void 0) {
      path22 = \\"\\";
    }
    if (Constructor === void 0) {
      Constructor = Error;
    }
    var error = new Constructor(formatError(errorCode, func, path2, path22));
    error.code = errorCode;
    return error;
  }
  var FLAGS;
  (function(FLAGS2) {
    FLAGS2[FLAGS2[\\"r\\"] = O_RDONLY] = \\"r\\";
    FLAGS2[FLAGS2[\\"r+\\"] = O_RDWR] = \\"r+\\";
    FLAGS2[FLAGS2[\\"rs\\"] = O_RDONLY | O_SYNC] = \\"rs\\";
    FLAGS2[FLAGS2[\\"sr\\"] = FLAGS2.rs] = \\"sr\\";
    FLAGS2[FLAGS2[\\"rs+\\"] = O_RDWR | O_SYNC] = \\"rs+\\";
    FLAGS2[FLAGS2[\\"sr+\\"] = FLAGS2[\\"rs+\\"]] = \\"sr+\\";
    FLAGS2[FLAGS2[\\"w\\"] = O_WRONLY | O_CREAT | O_TRUNC] = \\"w\\";
    FLAGS2[FLAGS2[\\"wx\\"] = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL] = \\"wx\\";
    FLAGS2[FLAGS2[\\"xw\\"] = FLAGS2.wx] = \\"xw\\";
    FLAGS2[FLAGS2[\\"w+\\"] = O_RDWR | O_CREAT | O_TRUNC] = \\"w+\\";
    FLAGS2[FLAGS2[\\"wx+\\"] = O_RDWR | O_CREAT | O_TRUNC | O_EXCL] = \\"wx+\\";
    FLAGS2[FLAGS2[\\"xw+\\"] = FLAGS2[\\"wx+\\"]] = \\"xw+\\";
    FLAGS2[FLAGS2[\\"a\\"] = O_WRONLY | O_APPEND | O_CREAT] = \\"a\\";
    FLAGS2[FLAGS2[\\"ax\\"] = O_WRONLY | O_APPEND | O_CREAT | O_EXCL] = \\"ax\\";
    FLAGS2[FLAGS2[\\"xa\\"] = FLAGS2.ax] = \\"xa\\";
    FLAGS2[FLAGS2[\\"a+\\"] = O_RDWR | O_APPEND | O_CREAT] = \\"a+\\";
    FLAGS2[FLAGS2[\\"ax+\\"] = O_RDWR | O_APPEND | O_CREAT | O_EXCL] = \\"ax+\\";
    FLAGS2[FLAGS2[\\"xa+\\"] = FLAGS2[\\"ax+\\"]] = \\"xa+\\";
  })(FLAGS = exports$42.FLAGS || (exports$42.FLAGS = {}));
  function flagsToNumber(flags) {
    if (typeof flags === \\"number\\")
      return flags;
    if (typeof flags === \\"string\\") {
      var flagsNum = FLAGS[flags];
      if (typeof flagsNum !== \\"undefined\\")
        return flagsNum;
    }
    throw new errors.TypeError(\\"ERR_INVALID_OPT_VALUE\\", \\"flags\\", flags);
  }
  exports$42.flagsToNumber = flagsToNumber;
  function getOptions(defaults, options) {
    var opts;
    if (!options)
      return defaults;
    else {
      var tipeof = typeof options;
      switch (tipeof) {
        case \\"string\\":
          opts = Object.assign({}, defaults, {
            encoding: options
          });
          break;
        case \\"object\\":
          opts = Object.assign({}, defaults, options);
          break;
        default:
          throw TypeError(ERRSTR_OPTS(tipeof));
      }
    }
    if (opts.encoding !== \\"buffer\\")
      (0, encoding_1.assertEncoding)(opts.encoding);
    return opts;
  }
  function optsGenerator(defaults) {
    return function(options) {
      return getOptions(defaults, options);
    };
  }
  function validateCallback(callback) {
    if (typeof callback !== \\"function\\")
      throw TypeError(ERRSTR.CB);
    return callback;
  }
  function optsAndCbGenerator(getOpts) {
    return function(options, callback) {
      return typeof options === \\"function\\" ? [getOpts(), options] : [getOpts(options), validateCallback(callback)];
    };
  }
  var optsDefaults = {
    encoding: \\"utf8\\"
  };
  var getDefaultOpts = optsGenerator(optsDefaults);
  var getDefaultOptsAndCb = optsAndCbGenerator(getDefaultOpts);
  var readFileOptsDefaults = {
    flag: \\"r\\"
  };
  var getReadFileOptions = optsGenerator(readFileOptsDefaults);
  var writeFileDefaults = {
    encoding: \\"utf8\\",
    mode: 438,
    flag: FLAGS[FLAGS.w]
  };
  var getWriteFileOptions = optsGenerator(writeFileDefaults);
  var appendFileDefaults = {
    encoding: \\"utf8\\",
    mode: 438,
    flag: FLAGS[FLAGS.a]
  };
  var getAppendFileOpts = optsGenerator(appendFileDefaults);
  var getAppendFileOptsAndCb = optsAndCbGenerator(getAppendFileOpts);
  var realpathDefaults = optsDefaults;
  var getRealpathOptions = optsGenerator(realpathDefaults);
  var getRealpathOptsAndCb = optsAndCbGenerator(getRealpathOptions);
  var mkdirDefaults = {
    mode: 511,
    recursive: false
  };
  var getMkdirOptions = function(options) {
    if (typeof options === \\"number\\")
      return Object.assign({}, mkdirDefaults, {
        mode: options
      });
    return Object.assign({}, mkdirDefaults, options);
  };
  var rmdirDefaults = {
    recursive: false
  };
  var getRmdirOptions = function(options) {
    return Object.assign({}, rmdirDefaults, options);
  };
  var readdirDefaults = {
    encoding: \\"utf8\\",
    withFileTypes: false
  };
  var getReaddirOptions = optsGenerator(readdirDefaults);
  var getReaddirOptsAndCb = optsAndCbGenerator(getReaddirOptions);
  var statDefaults = {
    bigint: false
  };
  var getStatOptions = function(options) {
    if (options === void 0) {
      options = {};
    }
    return Object.assign({}, statDefaults, options);
  };
  var getStatOptsAndCb = function(options, callback) {
    return typeof options === \\"function\\" ? [getStatOptions(), options] : [getStatOptions(options), validateCallback(callback)];
  };
  function getPathFromURLPosix2(url) {
    if (url.hostname !== \\"\\") {
      throw new errors.TypeError(\\"ERR_INVALID_FILE_URL_HOST\\", process_1.default.platform);
    }
    var pathname = url.pathname;
    for (var n8 = 0; n8 < pathname.length; n8++) {
      if (pathname[n8] === \\"%\\") {
        var third = pathname.codePointAt(n8 + 2) | 32;
        if (pathname[n8 + 1] === \\"2\\" && third === 102) {
          throw new errors.TypeError(\\"ERR_INVALID_FILE_URL_PATH\\", \\"must not include encoded / characters\\");
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  function pathToFilename(path2) {
    if (typeof path2 !== \\"string\\" && !buffer_1.Buffer.isBuffer(path2)) {
      try {
        if (!(path2 instanceof h7.URL))
          throw new TypeError(ERRSTR.PATH_STR);
      } catch (err) {
        throw new TypeError(ERRSTR.PATH_STR);
      }
      path2 = getPathFromURLPosix2(path2);
    }
    var pathString = String(path2);
    nullCheck(pathString);
    return pathString;
  }
  exports$42.pathToFilename = pathToFilename;
  var resolve3 = function(filename, base) {
    if (base === void 0) {
      base = process_1.default.cwd();
    }
    return resolveCrossPlatform(base, filename);
  };
  if (isWin) {
    var _resolve_1 = resolve3;
    var unixify_1 = dew$32().unixify;
    resolve3 = function(filename, base) {
      return unixify_1(_resolve_1(filename, base));
    };
  }
  function filenameToSteps(filename, base) {
    var fullPath = resolve3(filename, base);
    var fullPathSansSlash = fullPath.substr(1);
    if (!fullPathSansSlash)
      return [];
    return fullPathSansSlash.split(sep2);
  }
  exports$42.filenameToSteps = filenameToSteps;
  function pathToSteps(path2) {
    return filenameToSteps(pathToFilename(path2));
  }
  exports$42.pathToSteps = pathToSteps;
  function dataToStr(data, encoding) {
    if (encoding === void 0) {
      encoding = encoding_1.ENCODING_UTF8;
    }
    if (buffer_1.Buffer.isBuffer(data))
      return data.toString(encoding);
    else if (data instanceof Uint8Array)
      return (0, buffer_1.bufferFrom)(data).toString(encoding);
    else
      return String(data);
  }
  exports$42.dataToStr = dataToStr;
  function dataToBuffer(data, encoding) {
    if (encoding === void 0) {
      encoding = encoding_1.ENCODING_UTF8;
    }
    if (buffer_1.Buffer.isBuffer(data))
      return data;
    else if (data instanceof Uint8Array)
      return (0, buffer_1.bufferFrom)(data);
    else
      return (0, buffer_1.bufferFrom)(String(data), encoding);
  }
  exports$42.dataToBuffer = dataToBuffer;
  function bufferToEncoding(buffer2, encoding) {
    if (!encoding || encoding === \\"buffer\\")
      return buffer2;
    else
      return buffer2.toString(encoding);
  }
  exports$42.bufferToEncoding = bufferToEncoding;
  function nullCheck(path2, callback) {
    if ((\\"\\" + path2).indexOf(\\"\\\\0\\") !== -1) {
      var er = new Error(\\"Path must be a string without null bytes\\");
      er.code = ENOENT;
      if (typeof callback !== \\"function\\")
        throw er;
      process_1.default.nextTick(callback, er);
      return false;
    }
    return true;
  }
  function _modeToNumber(mode, def) {
    if (typeof mode === \\"number\\")
      return mode;
    if (typeof mode === \\"string\\")
      return parseInt(mode, 8);
    if (def)
      return modeToNumber(def);
    return void 0;
  }
  function modeToNumber(mode, def) {
    var result = _modeToNumber(mode, def);
    if (typeof result !== \\"number\\" || isNaN(result))
      throw new TypeError(ERRSTR.MODE_INT);
    return result;
  }
  function isFd(path2) {
    return path2 >>> 0 === path2;
  }
  function validateFd(fd) {
    if (!isFd(fd))
      throw TypeError(ERRSTR.FD);
  }
  function toUnixTimestamp(time) {
    if (typeof time === \\"string\\" && +time == time) {
      return +time;
    }
    if (time instanceof Date) {
      return time.getTime() / 1e3;
    }
    if (isFinite(time)) {
      if (time < 0) {
        return Date.now() / 1e3;
      }
      return time;
    }
    throw new Error(\\"Cannot parse time: \\" + time);
  }
  exports$42.toUnixTimestamp = toUnixTimestamp;
  function validateUid(uid) {
    if (typeof uid !== \\"number\\")
      throw TypeError(ERRSTR.UID);
  }
  function validateGid(gid) {
    if (typeof gid !== \\"number\\")
      throw TypeError(ERRSTR.GID);
  }
  function flattenJSON(nestedJSON) {
    var flatJSON = {};
    function flatten(pathPrefix, node) {
      for (var path2 in node) {
        var contentOrNode = node[path2];
        var joinedPath = join2(pathPrefix, path2);
        if (typeof contentOrNode === \\"string\\") {
          flatJSON[joinedPath] = contentOrNode;
        } else if (typeof contentOrNode === \\"object\\" && contentOrNode !== null && Object.keys(contentOrNode).length > 0) {
          flatten(joinedPath, contentOrNode);
        } else {
          flatJSON[joinedPath] = null;
        }
      }
    }
    flatten(\\"\\", nestedJSON);
    return flatJSON;
  }
  var Volume = function() {
    function Volume2(props) {
      if (props === void 0) {
        props = {};
      }
      this.ino = 0;
      this.inodes = {};
      this.releasedInos = [];
      this.fds = {};
      this.releasedFds = [];
      this.maxFiles = 1e4;
      this.openFiles = 0;
      this.promisesApi = (0, promises_1.default)(this);
      this.statWatchers = {};
      this.props = Object.assign({
        Node: node_1.Node,
        Link: node_1.Link,
        File: node_1.File
      }, props);
      var root = this.createLink();
      root.setNode(this.createNode(true));
      var self2 = this;
      this.StatWatcher = function(_super) {
        __extends(StatWatcher2, _super);
        function StatWatcher2() {
          return _super.call(this, self2) || this;
        }
        return StatWatcher2;
      }(StatWatcher);
      var _ReadStream = FsReadStream;
      this.ReadStream = function(_super) {
        __extends(class_1, _super);
        function class_1() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return _super.apply(this, __spreadArray([self2], args, false)) || this;
        }
        return class_1;
      }(_ReadStream);
      var _WriteStream = FsWriteStream;
      this.WriteStream = function(_super) {
        __extends(class_2, _super);
        function class_2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return _super.apply(this, __spreadArray([self2], args, false)) || this;
        }
        return class_2;
      }(_WriteStream);
      this.FSWatcher = function(_super) {
        __extends(FSWatcher2, _super);
        function FSWatcher2() {
          return _super.call(this, self2) || this;
        }
        return FSWatcher2;
      }(FSWatcher);
      this.root = root;
    }
    Volume2.fromJSON = function(json, cwd) {
      var vol2 = new Volume2();
      vol2.fromJSON(json, cwd);
      return vol2;
    };
    Volume2.fromNestedJSON = function(json, cwd) {
      var vol2 = new Volume2();
      vol2.fromNestedJSON(json, cwd);
      return vol2;
    };
    Object.defineProperty(Volume2.prototype, \\"promises\\", {
      get: function() {
        if (this.promisesApi === null)
          throw new Error(\\"Promise is not supported in this environment.\\");
        return this.promisesApi;
      },
      enumerable: false,
      configurable: true
    });
    Volume2.prototype.createLink = function(parent, name2, isDirectory, perm) {
      if (isDirectory === void 0) {
        isDirectory = false;
      }
      if (!parent) {
        return new this.props.Link(this, null, \\"\\");
      }
      if (!name2) {
        throw new Error(\\"createLink: name cannot be empty\\");
      }
      return parent.createChild(name2, this.createNode(isDirectory, perm));
    };
    Volume2.prototype.deleteLink = function(link2) {
      var parent = link2.parent;
      if (parent) {
        parent.deleteChild(link2);
        return true;
      }
      return false;
    };
    Volume2.prototype.newInoNumber = function() {
      var releasedFd = this.releasedInos.pop();
      if (releasedFd)
        return releasedFd;
      else {
        this.ino = (this.ino + 1) % 4294967295;
        return this.ino;
      }
    };
    Volume2.prototype.newFdNumber = function() {
      var releasedFd = this.releasedFds.pop();
      return typeof releasedFd === \\"number\\" ? releasedFd : Volume2.fd--;
    };
    Volume2.prototype.createNode = function(isDirectory, perm) {
      if (isDirectory === void 0) {
        isDirectory = false;
      }
      var node = new this.props.Node(this.newInoNumber(), perm);
      if (isDirectory)
        node.setIsDirectory();
      this.inodes[node.ino] = node;
      return node;
    };
    Volume2.prototype.getNode = function(ino) {
      return this.inodes[ino];
    };
    Volume2.prototype.deleteNode = function(node) {
      node.del();
      delete this.inodes[node.ino];
      this.releasedInos.push(node.ino);
    };
    Volume2.prototype.genRndStr = function() {
      var str = (Math.random() + 1).toString(36).substr(2, 6);
      if (str.length === 6)
        return str;
      else
        return this.genRndStr();
    };
    Volume2.prototype.getLink = function(steps) {
      return this.root.walk(steps);
    };
    Volume2.prototype.getLinkOrThrow = function(filename, funcName) {
      var steps = filenameToSteps(filename);
      var link2 = this.getLink(steps);
      if (!link2)
        throw createError(ENOENT, funcName, filename);
      return link2;
    };
    Volume2.prototype.getResolvedLink = function(filenameOrSteps) {
      var steps = typeof filenameOrSteps === \\"string\\" ? filenameToSteps(filenameOrSteps) : filenameOrSteps;
      var link2 = this.root;
      var i7 = 0;
      while (i7 < steps.length) {
        var step = steps[i7];
        link2 = link2.getChild(step);
        if (!link2)
          return null;
        var node = link2.getNode();
        if (node.isSymlink()) {
          steps = node.symlink.concat(steps.slice(i7 + 1));
          link2 = this.root;
          i7 = 0;
          continue;
        }
        i7++;
      }
      return link2;
    };
    Volume2.prototype.getResolvedLinkOrThrow = function(filename, funcName) {
      var link2 = this.getResolvedLink(filename);
      if (!link2)
        throw createError(ENOENT, funcName, filename);
      return link2;
    };
    Volume2.prototype.resolveSymlinks = function(link2) {
      return this.getResolvedLink(link2.steps.slice(1));
    };
    Volume2.prototype.getLinkAsDirOrThrow = function(filename, funcName) {
      var link2 = this.getLinkOrThrow(filename, funcName);
      if (!link2.getNode().isDirectory())
        throw createError(ENOTDIR, funcName, filename);
      return link2;
    };
    Volume2.prototype.getLinkParent = function(steps) {
      return this.root.walk(steps, steps.length - 1);
    };
    Volume2.prototype.getLinkParentAsDirOrThrow = function(filenameOrSteps, funcName) {
      var steps = filenameOrSteps instanceof Array ? filenameOrSteps : filenameToSteps(filenameOrSteps);
      var link2 = this.getLinkParent(steps);
      if (!link2)
        throw createError(ENOENT, funcName, sep2 + steps.join(sep2));
      if (!link2.getNode().isDirectory())
        throw createError(ENOTDIR, funcName, sep2 + steps.join(sep2));
      return link2;
    };
    Volume2.prototype.getFileByFd = function(fd) {
      return this.fds[String(fd)];
    };
    Volume2.prototype.getFileByFdOrThrow = function(fd, funcName) {
      if (!isFd(fd))
        throw TypeError(ERRSTR.FD);
      var file = this.getFileByFd(fd);
      if (!file)
        throw createError(EBADF, funcName);
      return file;
    };
    Volume2.prototype.getNodeByIdOrCreate = function(id, flags, perm) {
      if (typeof id === \\"number\\") {
        var file = this.getFileByFd(id);
        if (!file)
          throw Error(\\"File nto found\\");
        return file.node;
      } else {
        var steps = pathToSteps(id);
        var link2 = this.getLink(steps);
        if (link2)
          return link2.getNode();
        if (flags & O_CREAT) {
          var dirLink = this.getLinkParent(steps);
          if (dirLink) {
            var name_1 = steps[steps.length - 1];
            link2 = this.createLink(dirLink, name_1, false, perm);
            return link2.getNode();
          }
        }
        throw createError(ENOENT, \\"getNodeByIdOrCreate\\", pathToFilename(id));
      }
    };
    Volume2.prototype.wrapAsync = function(method, args, callback) {
      var _this = this;
      validateCallback(callback);
      (0, setImmediate_1.default)(function() {
        var result;
        try {
          result = method.apply(_this, args);
        } catch (err) {
          callback(err);
          return;
        }
        callback(null, result);
      });
    };
    Volume2.prototype._toJSON = function(link2, json, path2) {
      var _a2;
      if (link2 === void 0) {
        link2 = this.root;
      }
      if (json === void 0) {
        json = {};
      }
      var isEmpty = true;
      var children = link2.children;
      if (link2.getNode().isFile()) {
        children = (_a2 = {}, _a2[link2.getName()] = link2.parent.getChild(link2.getName()), _a2);
        link2 = link2.parent;
      }
      for (var name_2 in children) {
        isEmpty = false;
        var child = link2.getChild(name_2);
        if (!child) {
          throw new Error(\\"_toJSON: unexpected undefined\\");
        }
        var node = child.getNode();
        if (node.isFile()) {
          var filename = child.getPath();
          if (path2)
            filename = relative2(path2, filename);
          json[filename] = node.getString();
        } else if (node.isDirectory()) {
          this._toJSON(child, json, path2);
        }
      }
      var dirPath = link2.getPath();
      if (path2)
        dirPath = relative2(path2, dirPath);
      if (dirPath && isEmpty) {
        json[dirPath] = null;
      }
      return json;
    };
    Volume2.prototype.toJSON = function(paths, json, isRelative) {
      if (json === void 0) {
        json = {};
      }
      if (isRelative === void 0) {
        isRelative = false;
      }
      var links = [];
      if (paths) {
        if (!(paths instanceof Array))
          paths = [paths];
        for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
          var path2 = paths_1[_i];
          var filename = pathToFilename(path2);
          var link2 = this.getResolvedLink(filename);
          if (!link2)
            continue;
          links.push(link2);
        }
      } else {
        links.push(this.root);
      }
      if (!links.length)
        return json;
      for (var _a2 = 0, links_1 = links; _a2 < links_1.length; _a2++) {
        var link2 = links_1[_a2];
        this._toJSON(link2, json, isRelative ? link2.getPath() : \\"\\");
      }
      return json;
    };
    Volume2.prototype.fromJSON = function(json, cwd) {
      if (cwd === void 0) {
        cwd = process_1.default.cwd();
      }
      for (var filename in json) {
        var data = json[filename];
        filename = resolve3(filename, cwd);
        if (typeof data === \\"string\\") {
          var dir = dirname2(filename);
          this.mkdirpBase(dir, 511);
          this.writeFileSync(filename, data);
        } else {
          this.mkdirpBase(filename, 511);
        }
      }
    };
    Volume2.prototype.fromNestedJSON = function(json, cwd) {
      this.fromJSON(flattenJSON(json), cwd);
    };
    Volume2.prototype.reset = function() {
      this.ino = 0;
      this.inodes = {};
      this.releasedInos = [];
      this.fds = {};
      this.releasedFds = [];
      this.openFiles = 0;
      this.root = this.createLink();
      this.root.setNode(this.createNode(true));
    };
    Volume2.prototype.mountSync = function(mountpoint, json) {
      this.fromJSON(json, mountpoint);
    };
    Volume2.prototype.openLink = function(link2, flagsNum, resolveSymlinks) {
      if (resolveSymlinks === void 0) {
        resolveSymlinks = true;
      }
      if (this.openFiles >= this.maxFiles) {
        throw createError(EMFILE, \\"open\\", link2.getPath());
      }
      var realLink = link2;
      if (resolveSymlinks)
        realLink = this.resolveSymlinks(link2);
      if (!realLink)
        throw createError(ENOENT, \\"open\\", link2.getPath());
      var node = realLink.getNode();
      if (node.isDirectory()) {
        if ((flagsNum & (O_RDONLY | O_RDWR | O_WRONLY)) !== O_RDONLY)
          throw createError(EISDIR, \\"open\\", link2.getPath());
      } else {
        if (flagsNum & O_DIRECTORY)
          throw createError(ENOTDIR, \\"open\\", link2.getPath());
      }
      if (!(flagsNum & O_WRONLY)) {
        if (!node.canRead()) {
          throw createError(EACCES, \\"open\\", link2.getPath());
        }
      }
      var file = new this.props.File(link2, node, flagsNum, this.newFdNumber());
      this.fds[file.fd] = file;
      this.openFiles++;
      if (flagsNum & O_TRUNC)
        file.truncate();
      return file;
    };
    Volume2.prototype.openFile = function(filename, flagsNum, modeNum, resolveSymlinks) {
      if (resolveSymlinks === void 0) {
        resolveSymlinks = true;
      }
      var steps = filenameToSteps(filename);
      var link2 = resolveSymlinks ? this.getResolvedLink(steps) : this.getLink(steps);
      if (!link2 && flagsNum & O_CREAT) {
        var dirLink = this.getResolvedLink(steps.slice(0, steps.length - 1));
        if (!dirLink)
          throw createError(ENOENT, \\"open\\", sep2 + steps.join(sep2));
        if (flagsNum & O_CREAT && typeof modeNum === \\"number\\") {
          link2 = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);
        }
      }
      if (link2)
        return this.openLink(link2, flagsNum, resolveSymlinks);
      throw createError(ENOENT, \\"open\\", filename);
    };
    Volume2.prototype.openBase = function(filename, flagsNum, modeNum, resolveSymlinks) {
      if (resolveSymlinks === void 0) {
        resolveSymlinks = true;
      }
      var file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);
      if (!file)
        throw createError(ENOENT, \\"open\\", filename);
      return file.fd;
    };
    Volume2.prototype.openSync = function(path2, flags, mode) {
      if (mode === void 0) {
        mode = 438;
      }
      var modeNum = modeToNumber(mode);
      var fileName = pathToFilename(path2);
      var flagsNum = flagsToNumber(flags);
      return this.openBase(fileName, flagsNum, modeNum);
    };
    Volume2.prototype.open = function(path2, flags, a7, b5) {
      var mode = a7;
      var callback = b5;
      if (typeof a7 === \\"function\\") {
        mode = 438;
        callback = a7;
      }
      mode = mode || 438;
      var modeNum = modeToNumber(mode);
      var fileName = pathToFilename(path2);
      var flagsNum = flagsToNumber(flags);
      this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum], callback);
    };
    Volume2.prototype.closeFile = function(file) {
      if (!this.fds[file.fd])
        return;
      this.openFiles--;
      delete this.fds[file.fd];
      this.releasedFds.push(file.fd);
    };
    Volume2.prototype.closeSync = function(fd) {
      validateFd(fd);
      var file = this.getFileByFdOrThrow(fd, \\"close\\");
      this.closeFile(file);
    };
    Volume2.prototype.close = function(fd, callback) {
      validateFd(fd);
      this.wrapAsync(this.closeSync, [fd], callback);
    };
    Volume2.prototype.openFileOrGetById = function(id, flagsNum, modeNum) {
      if (typeof id === \\"number\\") {
        var file = this.fds[id];
        if (!file)
          throw createError(ENOENT);
        return file;
      } else {
        return this.openFile(pathToFilename(id), flagsNum, modeNum);
      }
    };
    Volume2.prototype.readBase = function(fd, buffer2, offset, length, position) {
      var file = this.getFileByFdOrThrow(fd);
      return file.read(buffer2, Number(offset), Number(length), position);
    };
    Volume2.prototype.readSync = function(fd, buffer2, offset, length, position) {
      validateFd(fd);
      return this.readBase(fd, buffer2, offset, length, position);
    };
    Volume2.prototype.read = function(fd, buffer2, offset, length, position, callback) {
      var _this = this;
      validateCallback(callback);
      if (length === 0) {
        return process_1.default.nextTick(function() {
          if (callback)
            callback(null, 0, buffer2);
        });
      }
      (0, setImmediate_1.default)(function() {
        try {
          var bytes = _this.readBase(fd, buffer2, offset, length, position);
          callback(null, bytes, buffer2);
        } catch (err) {
          callback(err);
        }
      });
    };
    Volume2.prototype.readFileBase = function(id, flagsNum, encoding) {
      var result;
      var isUserFd = typeof id === \\"number\\";
      var userOwnsFd = isUserFd && isFd(id);
      var fd;
      if (userOwnsFd)
        fd = id;
      else {
        var filename = pathToFilename(id);
        var steps = filenameToSteps(filename);
        var link2 = this.getResolvedLink(steps);
        if (link2) {
          var node = link2.getNode();
          if (node.isDirectory())
            throw createError(EISDIR, \\"open\\", link2.getPath());
        }
        fd = this.openSync(id, flagsNum);
      }
      try {
        result = bufferToEncoding(this.getFileByFdOrThrow(fd).getBuffer(), encoding);
      } finally {
        if (!userOwnsFd) {
          this.closeSync(fd);
        }
      }
      return result;
    };
    Volume2.prototype.readFileSync = function(file, options) {
      var opts = getReadFileOptions(options);
      var flagsNum = flagsToNumber(opts.flag);
      return this.readFileBase(file, flagsNum, opts.encoding);
    };
    Volume2.prototype.readFile = function(id, a7, b5) {
      var _a2 = optsAndCbGenerator(getReadFileOptions)(a7, b5), opts = _a2[0], callback = _a2[1];
      var flagsNum = flagsToNumber(opts.flag);
      this.wrapAsync(this.readFileBase, [id, flagsNum, opts.encoding], callback);
    };
    Volume2.prototype.writeBase = function(fd, buf, offset, length, position) {
      var file = this.getFileByFdOrThrow(fd, \\"write\\");
      return file.write(buf, offset, length, position);
    };
    Volume2.prototype.writeSync = function(fd, a7, b5, c7, d6) {
      validateFd(fd);
      var encoding;
      var offset;
      var length;
      var position;
      var isBuffer3 = typeof a7 !== \\"string\\";
      if (isBuffer3) {
        offset = (b5 || 0) | 0;
        length = c7;
        position = d6;
      } else {
        position = b5;
        encoding = c7;
      }
      var buf = dataToBuffer(a7, encoding);
      if (isBuffer3) {
        if (typeof length === \\"undefined\\") {
          length = buf.length;
        }
      } else {
        offset = 0;
        length = buf.length;
      }
      return this.writeBase(fd, buf, offset, length, position);
    };
    Volume2.prototype.write = function(fd, a7, b5, c7, d6, e9) {
      var _this = this;
      validateFd(fd);
      var offset;
      var length;
      var position;
      var encoding;
      var callback;
      var tipa = typeof a7;
      var tipb = typeof b5;
      var tipc = typeof c7;
      var tipd = typeof d6;
      if (tipa !== \\"string\\") {
        if (tipb === \\"function\\") {
          callback = b5;
        } else if (tipc === \\"function\\") {
          offset = b5 | 0;
          callback = c7;
        } else if (tipd === \\"function\\") {
          offset = b5 | 0;
          length = c7;
          callback = d6;
        } else {
          offset = b5 | 0;
          length = c7;
          position = d6;
          callback = e9;
        }
      } else {
        if (tipb === \\"function\\") {
          callback = b5;
        } else if (tipc === \\"function\\") {
          position = b5;
          callback = c7;
        } else if (tipd === \\"function\\") {
          position = b5;
          encoding = c7;
          callback = d6;
        }
      }
      var buf = dataToBuffer(a7, encoding);
      if (tipa !== \\"string\\") {
        if (typeof length === \\"undefined\\")
          length = buf.length;
      } else {
        offset = 0;
        length = buf.length;
      }
      var cb = validateCallback(callback);
      (0, setImmediate_1.default)(function() {
        try {
          var bytes = _this.writeBase(fd, buf, offset, length, position);
          if (tipa !== \\"string\\") {
            cb(null, bytes, buf);
          } else {
            cb(null, bytes, a7);
          }
        } catch (err) {
          cb(err);
        }
      });
    };
    Volume2.prototype.writeFileBase = function(id, buf, flagsNum, modeNum) {
      var isUserFd = typeof id === \\"number\\";
      var fd;
      if (isUserFd)
        fd = id;
      else {
        fd = this.openBase(pathToFilename(id), flagsNum, modeNum);
      }
      var offset = 0;
      var length = buf.length;
      var position = flagsNum & O_APPEND ? void 0 : 0;
      try {
        while (length > 0) {
          var written = this.writeSync(fd, buf, offset, length, position);
          offset += written;
          length -= written;
          if (position !== void 0)
            position += written;
        }
      } finally {
        if (!isUserFd)
          this.closeSync(fd);
      }
    };
    Volume2.prototype.writeFileSync = function(id, data, options) {
      var opts = getWriteFileOptions(options);
      var flagsNum = flagsToNumber(opts.flag);
      var modeNum = modeToNumber(opts.mode);
      var buf = dataToBuffer(data, opts.encoding);
      this.writeFileBase(id, buf, flagsNum, modeNum);
    };
    Volume2.prototype.writeFile = function(id, data, a7, b5) {
      var options = a7;
      var callback = b5;
      if (typeof a7 === \\"function\\") {
        options = writeFileDefaults;
        callback = a7;
      }
      var cb = validateCallback(callback);
      var opts = getWriteFileOptions(options);
      var flagsNum = flagsToNumber(opts.flag);
      var modeNum = modeToNumber(opts.mode);
      var buf = dataToBuffer(data, opts.encoding);
      this.wrapAsync(this.writeFileBase, [id, buf, flagsNum, modeNum], cb);
    };
    Volume2.prototype.linkBase = function(filename1, filename2) {
      var steps1 = filenameToSteps(filename1);
      var link1 = this.getLink(steps1);
      if (!link1)
        throw createError(ENOENT, \\"link\\", filename1, filename2);
      var steps2 = filenameToSteps(filename2);
      var dir2 = this.getLinkParent(steps2);
      if (!dir2)
        throw createError(ENOENT, \\"link\\", filename1, filename2);
      var name2 = steps2[steps2.length - 1];
      if (dir2.getChild(name2))
        throw createError(EEXIST, \\"link\\", filename1, filename2);
      var node = link1.getNode();
      node.nlink++;
      dir2.createChild(name2, node);
    };
    Volume2.prototype.copyFileBase = function(src, dest, flags) {
      var buf = this.readFileSync(src);
      if (flags & COPYFILE_EXCL) {
        if (this.existsSync(dest)) {
          throw createError(EEXIST, \\"copyFile\\", src, dest);
        }
      }
      if (flags & COPYFILE_FICLONE_FORCE) {
        throw createError(ENOSYS, \\"copyFile\\", src, dest);
      }
      this.writeFileBase(dest, buf, FLAGS.w, 438);
    };
    Volume2.prototype.copyFileSync = function(src, dest, flags) {
      var srcFilename = pathToFilename(src);
      var destFilename = pathToFilename(dest);
      return this.copyFileBase(srcFilename, destFilename, (flags || 0) | 0);
    };
    Volume2.prototype.copyFile = function(src, dest, a7, b5) {
      var srcFilename = pathToFilename(src);
      var destFilename = pathToFilename(dest);
      var flags;
      var callback;
      if (typeof a7 === \\"function\\") {
        flags = 0;
        callback = a7;
      } else {
        flags = a7;
        callback = b5;
      }
      validateCallback(callback);
      this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);
    };
    Volume2.prototype.linkSync = function(existingPath, newPath) {
      var existingPathFilename = pathToFilename(existingPath);
      var newPathFilename = pathToFilename(newPath);
      this.linkBase(existingPathFilename, newPathFilename);
    };
    Volume2.prototype.link = function(existingPath, newPath, callback) {
      var existingPathFilename = pathToFilename(existingPath);
      var newPathFilename = pathToFilename(newPath);
      this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);
    };
    Volume2.prototype.unlinkBase = function(filename) {
      var steps = filenameToSteps(filename);
      var link2 = this.getLink(steps);
      if (!link2)
        throw createError(ENOENT, \\"unlink\\", filename);
      if (link2.length)
        throw Error(\\"Dir not empty...\\");
      this.deleteLink(link2);
      var node = link2.getNode();
      node.nlink--;
      if (node.nlink <= 0) {
        this.deleteNode(node);
      }
    };
    Volume2.prototype.unlinkSync = function(path2) {
      var filename = pathToFilename(path2);
      this.unlinkBase(filename);
    };
    Volume2.prototype.unlink = function(path2, callback) {
      var filename = pathToFilename(path2);
      this.wrapAsync(this.unlinkBase, [filename], callback);
    };
    Volume2.prototype.symlinkBase = function(targetFilename, pathFilename) {
      var pathSteps = filenameToSteps(pathFilename);
      var dirLink = this.getLinkParent(pathSteps);
      if (!dirLink)
        throw createError(ENOENT, \\"symlink\\", targetFilename, pathFilename);
      var name2 = pathSteps[pathSteps.length - 1];
      if (dirLink.getChild(name2))
        throw createError(EEXIST, \\"symlink\\", targetFilename, pathFilename);
      var symlink2 = dirLink.createChild(name2);
      symlink2.getNode().makeSymlink(filenameToSteps(targetFilename));
      return symlink2;
    };
    Volume2.prototype.symlinkSync = function(target, path2, type) {
      var targetFilename = pathToFilename(target);
      var pathFilename = pathToFilename(path2);
      this.symlinkBase(targetFilename, pathFilename);
    };
    Volume2.prototype.symlink = function(target, path2, a7, b5) {
      var callback = validateCallback(typeof a7 === \\"function\\" ? a7 : b5);
      var targetFilename = pathToFilename(target);
      var pathFilename = pathToFilename(path2);
      this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);
    };
    Volume2.prototype.realpathBase = function(filename, encoding) {
      var steps = filenameToSteps(filename);
      var realLink = this.getResolvedLink(steps);
      if (!realLink)
        throw createError(ENOENT, \\"realpath\\", filename);
      return (0, encoding_1.strToEncoding)(realLink.getPath(), encoding);
    };
    Volume2.prototype.realpathSync = function(path2, options) {
      return this.realpathBase(pathToFilename(path2), getRealpathOptions(options).encoding);
    };
    Volume2.prototype.realpath = function(path2, a7, b5) {
      var _a2 = getRealpathOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
      var pathFilename = pathToFilename(path2);
      this.wrapAsync(this.realpathBase, [pathFilename, opts.encoding], callback);
    };
    Volume2.prototype.lstatBase = function(filename, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }
      var link2 = this.getLink(filenameToSteps(filename));
      if (!link2)
        throw createError(ENOENT, \\"lstat\\", filename);
      return Stats_1.default.build(link2.getNode(), bigint);
    };
    Volume2.prototype.lstatSync = function(path2, options) {
      return this.lstatBase(pathToFilename(path2), getStatOptions(options).bigint);
    };
    Volume2.prototype.lstat = function(path2, a7, b5) {
      var _a2 = getStatOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
      this.wrapAsync(this.lstatBase, [pathToFilename(path2), opts.bigint], callback);
    };
    Volume2.prototype.statBase = function(filename, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }
      var link2 = this.getResolvedLink(filenameToSteps(filename));
      if (!link2)
        throw createError(ENOENT, \\"stat\\", filename);
      return Stats_1.default.build(link2.getNode(), bigint);
    };
    Volume2.prototype.statSync = function(path2, options) {
      return this.statBase(pathToFilename(path2), getStatOptions(options).bigint);
    };
    Volume2.prototype.stat = function(path2, a7, b5) {
      var _a2 = getStatOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
      this.wrapAsync(this.statBase, [pathToFilename(path2), opts.bigint], callback);
    };
    Volume2.prototype.fstatBase = function(fd, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }
      var file = this.getFileByFd(fd);
      if (!file)
        throw createError(EBADF, \\"fstat\\");
      return Stats_1.default.build(file.node, bigint);
    };
    Volume2.prototype.fstatSync = function(fd, options) {
      return this.fstatBase(fd, getStatOptions(options).bigint);
    };
    Volume2.prototype.fstat = function(fd, a7, b5) {
      var _a2 = getStatOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
      this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);
    };
    Volume2.prototype.renameBase = function(oldPathFilename, newPathFilename) {
      var link2 = this.getLink(filenameToSteps(oldPathFilename));
      if (!link2)
        throw createError(ENOENT, \\"rename\\", oldPathFilename, newPathFilename);
      var newPathSteps = filenameToSteps(newPathFilename);
      var newPathDirLink = this.getLinkParent(newPathSteps);
      if (!newPathDirLink)
        throw createError(ENOENT, \\"rename\\", oldPathFilename, newPathFilename);
      var oldLinkParent = link2.parent;
      if (oldLinkParent) {
        oldLinkParent.deleteChild(link2);
      }
      var name2 = newPathSteps[newPathSteps.length - 1];
      link2.steps = __spreadArray(__spreadArray([], newPathDirLink.steps, true), [name2], false);
      newPathDirLink.setChild(link2.getName(), link2);
    };
    Volume2.prototype.renameSync = function(oldPath, newPath) {
      var oldPathFilename = pathToFilename(oldPath);
      var newPathFilename = pathToFilename(newPath);
      this.renameBase(oldPathFilename, newPathFilename);
    };
    Volume2.prototype.rename = function(oldPath, newPath, callback) {
      var oldPathFilename = pathToFilename(oldPath);
      var newPathFilename = pathToFilename(newPath);
      this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);
    };
    Volume2.prototype.existsBase = function(filename) {
      return !!this.statBase(filename);
    };
    Volume2.prototype.existsSync = function(path2) {
      try {
        return this.existsBase(pathToFilename(path2));
      } catch (err) {
        return false;
      }
    };
    Volume2.prototype.exists = function(path2, callback) {
      var _this = this;
      var filename = pathToFilename(path2);
      if (typeof callback !== \\"function\\")
        throw Error(ERRSTR.CB);
      (0, setImmediate_1.default)(function() {
        try {
          callback(_this.existsBase(filename));
        } catch (err) {
          callback(false);
        }
      });
    };
    Volume2.prototype.accessBase = function(filename, mode) {
      this.getLinkOrThrow(filename, \\"access\\");
    };
    Volume2.prototype.accessSync = function(path2, mode) {
      if (mode === void 0) {
        mode = F_OK2;
      }
      var filename = pathToFilename(path2);
      mode = mode | 0;
      this.accessBase(filename, mode);
    };
    Volume2.prototype.access = function(path2, a7, b5) {
      var mode = F_OK2;
      var callback;
      if (typeof a7 !== \\"function\\") {
        mode = a7 | 0;
        callback = validateCallback(b5);
      } else {
        callback = a7;
      }
      var filename = pathToFilename(path2);
      this.wrapAsync(this.accessBase, [filename, mode], callback);
    };
    Volume2.prototype.appendFileSync = function(id, data, options) {
      if (options === void 0) {
        options = appendFileDefaults;
      }
      var opts = getAppendFileOpts(options);
      if (!opts.flag || isFd(id))
        opts.flag = \\"a\\";
      this.writeFileSync(id, data, opts);
    };
    Volume2.prototype.appendFile = function(id, data, a7, b5) {
      var _a2 = getAppendFileOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
      if (!opts.flag || isFd(id))
        opts.flag = \\"a\\";
      this.writeFile(id, data, opts, callback);
    };
    Volume2.prototype.readdirBase = function(filename, options) {
      var steps = filenameToSteps(filename);
      var link2 = this.getResolvedLink(steps);
      if (!link2)
        throw createError(ENOENT, \\"readdir\\", filename);
      var node = link2.getNode();
      if (!node.isDirectory())
        throw createError(ENOTDIR, \\"scandir\\", filename);
      if (options.withFileTypes) {
        var list_1 = [];
        for (var name_3 in link2.children) {
          var child = link2.getChild(name_3);
          if (!child) {
            continue;
          }
          list_1.push(Dirent_1.default.build(child, options.encoding));
        }
        if (!isWin && options.encoding !== \\"buffer\\")
          list_1.sort(function(a7, b5) {
            if (a7.name < b5.name)
              return -1;
            if (a7.name > b5.name)
              return 1;
            return 0;
          });
        return list_1;
      }
      var list = [];
      for (var name_4 in link2.children) {
        list.push((0, encoding_1.strToEncoding)(name_4, options.encoding));
      }
      if (!isWin && options.encoding !== \\"buffer\\")
        list.sort();
      return list;
    };
    Volume2.prototype.readdirSync = function(path2, options) {
      var opts = getReaddirOptions(options);
      var filename = pathToFilename(path2);
      return this.readdirBase(filename, opts);
    };
    Volume2.prototype.readdir = function(path2, a7, b5) {
      var _a2 = getReaddirOptsAndCb(a7, b5), options = _a2[0], callback = _a2[1];
      var filename = pathToFilename(path2);
      this.wrapAsync(this.readdirBase, [filename, options], callback);
    };
    Volume2.prototype.readlinkBase = function(filename, encoding) {
      var link2 = this.getLinkOrThrow(filename, \\"readlink\\");
      var node = link2.getNode();
      if (!node.isSymlink())
        throw createError(EINVAL, \\"readlink\\", filename);
      var str = sep2 + node.symlink.join(sep2);
      return (0, encoding_1.strToEncoding)(str, encoding);
    };
    Volume2.prototype.readlinkSync = function(path2, options) {
      var opts = getDefaultOpts(options);
      var filename = pathToFilename(path2);
      return this.readlinkBase(filename, opts.encoding);
    };
    Volume2.prototype.readlink = function(path2, a7, b5) {
      var _a2 = getDefaultOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
      var filename = pathToFilename(path2);
      this.wrapAsync(this.readlinkBase, [filename, opts.encoding], callback);
    };
    Volume2.prototype.fsyncBase = function(fd) {
      this.getFileByFdOrThrow(fd, \\"fsync\\");
    };
    Volume2.prototype.fsyncSync = function(fd) {
      this.fsyncBase(fd);
    };
    Volume2.prototype.fsync = function(fd, callback) {
      this.wrapAsync(this.fsyncBase, [fd], callback);
    };
    Volume2.prototype.fdatasyncBase = function(fd) {
      this.getFileByFdOrThrow(fd, \\"fdatasync\\");
    };
    Volume2.prototype.fdatasyncSync = function(fd) {
      this.fdatasyncBase(fd);
    };
    Volume2.prototype.fdatasync = function(fd, callback) {
      this.wrapAsync(this.fdatasyncBase, [fd], callback);
    };
    Volume2.prototype.ftruncateBase = function(fd, len) {
      var file = this.getFileByFdOrThrow(fd, \\"ftruncate\\");
      file.truncate(len);
    };
    Volume2.prototype.ftruncateSync = function(fd, len) {
      this.ftruncateBase(fd, len);
    };
    Volume2.prototype.ftruncate = function(fd, a7, b5) {
      var len = typeof a7 === \\"number\\" ? a7 : 0;
      var callback = validateCallback(typeof a7 === \\"number\\" ? b5 : a7);
      this.wrapAsync(this.ftruncateBase, [fd, len], callback);
    };
    Volume2.prototype.truncateBase = function(path2, len) {
      var fd = this.openSync(path2, \\"r+\\");
      try {
        this.ftruncateSync(fd, len);
      } finally {
        this.closeSync(fd);
      }
    };
    Volume2.prototype.truncateSync = function(id, len) {
      if (isFd(id))
        return this.ftruncateSync(id, len);
      this.truncateBase(id, len);
    };
    Volume2.prototype.truncate = function(id, a7, b5) {
      var len = typeof a7 === \\"number\\" ? a7 : 0;
      var callback = validateCallback(typeof a7 === \\"number\\" ? b5 : a7);
      if (isFd(id))
        return this.ftruncate(id, len, callback);
      this.wrapAsync(this.truncateBase, [id, len], callback);
    };
    Volume2.prototype.futimesBase = function(fd, atime, mtime) {
      var file = this.getFileByFdOrThrow(fd, \\"futimes\\");
      var node = file.node;
      node.atime = new Date(atime * 1e3);
      node.mtime = new Date(mtime * 1e3);
    };
    Volume2.prototype.futimesSync = function(fd, atime, mtime) {
      this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));
    };
    Volume2.prototype.futimes = function(fd, atime, mtime, callback) {
      this.wrapAsync(this.futimesBase, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
    };
    Volume2.prototype.utimesBase = function(filename, atime, mtime) {
      var fd = this.openSync(filename, \\"r+\\");
      try {
        this.futimesBase(fd, atime, mtime);
      } finally {
        this.closeSync(fd);
      }
    };
    Volume2.prototype.utimesSync = function(path2, atime, mtime) {
      this.utimesBase(pathToFilename(path2), toUnixTimestamp(atime), toUnixTimestamp(mtime));
    };
    Volume2.prototype.utimes = function(path2, atime, mtime, callback) {
      this.wrapAsync(this.utimesBase, [pathToFilename(path2), toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
    };
    Volume2.prototype.mkdirBase = function(filename, modeNum) {
      var steps = filenameToSteps(filename);
      if (!steps.length) {
        throw createError(EEXIST, \\"mkdir\\", filename);
      }
      var dir = this.getLinkParentAsDirOrThrow(filename, \\"mkdir\\");
      var name2 = steps[steps.length - 1];
      if (dir.getChild(name2))
        throw createError(EEXIST, \\"mkdir\\", filename);
      dir.createChild(name2, this.createNode(true, modeNum));
    };
    Volume2.prototype.mkdirpBase = function(filename, modeNum) {
      var steps = filenameToSteps(filename);
      var link2 = this.root;
      for (var i7 = 0; i7 < steps.length; i7++) {
        var step = steps[i7];
        if (!link2.getNode().isDirectory())
          throw createError(ENOTDIR, \\"mkdir\\", link2.getPath());
        var child = link2.getChild(step);
        if (child) {
          if (child.getNode().isDirectory())
            link2 = child;
          else
            throw createError(ENOTDIR, \\"mkdir\\", child.getPath());
        } else {
          link2 = link2.createChild(step, this.createNode(true, modeNum));
        }
      }
    };
    Volume2.prototype.mkdirSync = function(path2, options) {
      var opts = getMkdirOptions(options);
      var modeNum = modeToNumber(opts.mode, 511);
      var filename = pathToFilename(path2);
      if (opts.recursive)
        this.mkdirpBase(filename, modeNum);
      else
        this.mkdirBase(filename, modeNum);
    };
    Volume2.prototype.mkdir = function(path2, a7, b5) {
      var opts = getMkdirOptions(a7);
      var callback = validateCallback(typeof a7 === \\"function\\" ? a7 : b5);
      var modeNum = modeToNumber(opts.mode, 511);
      var filename = pathToFilename(path2);
      if (opts.recursive)
        this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);
      else
        this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);
    };
    Volume2.prototype.mkdirpSync = function(path2, mode) {
      this.mkdirSync(path2, {
        mode,
        recursive: true
      });
    };
    Volume2.prototype.mkdirp = function(path2, a7, b5) {
      var mode = typeof a7 === \\"function\\" ? void 0 : a7;
      var callback = validateCallback(typeof a7 === \\"function\\" ? a7 : b5);
      this.mkdir(path2, {
        mode,
        recursive: true
      }, callback);
    };
    Volume2.prototype.mkdtempBase = function(prefix, encoding, retry) {
      if (retry === void 0) {
        retry = 5;
      }
      var filename = prefix + this.genRndStr();
      try {
        this.mkdirBase(filename, 511);
        return (0, encoding_1.strToEncoding)(filename, encoding);
      } catch (err) {
        if (err.code === EEXIST) {
          if (retry > 1)
            return this.mkdtempBase(prefix, encoding, retry - 1);
          else
            throw Error(\\"Could not create temp dir.\\");
        } else
          throw err;
      }
    };
    Volume2.prototype.mkdtempSync = function(prefix, options) {
      var encoding = getDefaultOpts(options).encoding;
      if (!prefix || typeof prefix !== \\"string\\")
        throw new TypeError(\\"filename prefix is required\\");
      nullCheck(prefix);
      return this.mkdtempBase(prefix, encoding);
    };
    Volume2.prototype.mkdtemp = function(prefix, a7, b5) {
      var _a2 = getDefaultOptsAndCb(a7, b5), encoding = _a2[0].encoding, callback = _a2[1];
      if (!prefix || typeof prefix !== \\"string\\")
        throw new TypeError(\\"filename prefix is required\\");
      if (!nullCheck(prefix))
        return;
      this.wrapAsync(this.mkdtempBase, [prefix, encoding], callback);
    };
    Volume2.prototype.rmdirBase = function(filename, options) {
      var opts = getRmdirOptions(options);
      var link2 = this.getLinkAsDirOrThrow(filename, \\"rmdir\\");
      if (link2.length && !opts.recursive)
        throw createError(ENOTEMPTY, \\"rmdir\\", filename);
      this.deleteLink(link2);
    };
    Volume2.prototype.rmdirSync = function(path2, options) {
      this.rmdirBase(pathToFilename(path2), options);
    };
    Volume2.prototype.rmdir = function(path2, a7, b5) {
      var opts = getRmdirOptions(a7);
      var callback = validateCallback(typeof a7 === \\"function\\" ? a7 : b5);
      this.wrapAsync(this.rmdirBase, [pathToFilename(path2), opts], callback);
    };
    Volume2.prototype.fchmodBase = function(fd, modeNum) {
      var file = this.getFileByFdOrThrow(fd, \\"fchmod\\");
      file.chmod(modeNum);
    };
    Volume2.prototype.fchmodSync = function(fd, mode) {
      this.fchmodBase(fd, modeToNumber(mode));
    };
    Volume2.prototype.fchmod = function(fd, mode, callback) {
      this.wrapAsync(this.fchmodBase, [fd, modeToNumber(mode)], callback);
    };
    Volume2.prototype.chmodBase = function(filename, modeNum) {
      var fd = this.openSync(filename, \\"r+\\");
      try {
        this.fchmodBase(fd, modeNum);
      } finally {
        this.closeSync(fd);
      }
    };
    Volume2.prototype.chmodSync = function(path2, mode) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path2);
      this.chmodBase(filename, modeNum);
    };
    Volume2.prototype.chmod = function(path2, mode, callback) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path2);
      this.wrapAsync(this.chmodBase, [filename, modeNum], callback);
    };
    Volume2.prototype.lchmodBase = function(filename, modeNum) {
      var fd = this.openBase(filename, O_RDWR, 0, false);
      try {
        this.fchmodBase(fd, modeNum);
      } finally {
        this.closeSync(fd);
      }
    };
    Volume2.prototype.lchmodSync = function(path2, mode) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path2);
      this.lchmodBase(filename, modeNum);
    };
    Volume2.prototype.lchmod = function(path2, mode, callback) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path2);
      this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);
    };
    Volume2.prototype.fchownBase = function(fd, uid, gid) {
      this.getFileByFdOrThrow(fd, \\"fchown\\").chown(uid, gid);
    };
    Volume2.prototype.fchownSync = function(fd, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.fchownBase(fd, uid, gid);
    };
    Volume2.prototype.fchown = function(fd, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);
    };
    Volume2.prototype.chownBase = function(filename, uid, gid) {
      var link2 = this.getResolvedLinkOrThrow(filename, \\"chown\\");
      var node = link2.getNode();
      node.chown(uid, gid);
    };
    Volume2.prototype.chownSync = function(path2, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.chownBase(pathToFilename(path2), uid, gid);
    };
    Volume2.prototype.chown = function(path2, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.chownBase, [pathToFilename(path2), uid, gid], callback);
    };
    Volume2.prototype.lchownBase = function(filename, uid, gid) {
      this.getLinkOrThrow(filename, \\"lchown\\").getNode().chown(uid, gid);
    };
    Volume2.prototype.lchownSync = function(path2, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.lchownBase(pathToFilename(path2), uid, gid);
    };
    Volume2.prototype.lchown = function(path2, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.lchownBase, [pathToFilename(path2), uid, gid], callback);
    };
    Volume2.prototype.watchFile = function(path2, a7, b5) {
      var filename = pathToFilename(path2);
      var options = a7;
      var listener = b5;
      if (typeof options === \\"function\\") {
        listener = a7;
        options = null;
      }
      if (typeof listener !== \\"function\\") {
        throw Error('\\"watchFile()\\" requires a listener function');
      }
      var interval = 5007;
      var persistent = true;
      if (options && typeof options === \\"object\\") {
        if (typeof options.interval === \\"number\\")
          interval = options.interval;
        if (typeof options.persistent === \\"boolean\\")
          persistent = options.persistent;
      }
      var watcher = this.statWatchers[filename];
      if (!watcher) {
        watcher = new this.StatWatcher();
        watcher.start(filename, persistent, interval);
        this.statWatchers[filename] = watcher;
      }
      watcher.addListener(\\"change\\", listener);
      return watcher;
    };
    Volume2.prototype.unwatchFile = function(path2, listener) {
      var filename = pathToFilename(path2);
      var watcher = this.statWatchers[filename];
      if (!watcher)
        return;
      if (typeof listener === \\"function\\") {
        watcher.removeListener(\\"change\\", listener);
      } else {
        watcher.removeAllListeners(\\"change\\");
      }
      if (watcher.listenerCount(\\"change\\") === 0) {
        watcher.stop();
        delete this.statWatchers[filename];
      }
    };
    Volume2.prototype.createReadStream = function(path2, options) {
      return new this.ReadStream(path2, options);
    };
    Volume2.prototype.createWriteStream = function(path2, options) {
      return new this.WriteStream(path2, options);
    };
    Volume2.prototype.watch = function(path2, options, listener) {
      var filename = pathToFilename(path2);
      var givenOptions = options;
      if (typeof options === \\"function\\") {
        listener = options;
        givenOptions = null;
      }
      var _a2 = getDefaultOpts(givenOptions), persistent = _a2.persistent, recursive = _a2.recursive, encoding = _a2.encoding;
      if (persistent === void 0)
        persistent = true;
      if (recursive === void 0)
        recursive = false;
      var watcher = new this.FSWatcher();
      watcher.start(filename, persistent, recursive, encoding);
      if (listener) {
        watcher.addListener(\\"change\\", listener);
      }
      return watcher;
    };
    Volume2.fd = 2147483647;
    return Volume2;
  }();
  exports$42.Volume = Volume;
  function emitStop(self2) {
    self2.emit(\\"stop\\");
  }
  var StatWatcher = function(_super) {
    __extends(StatWatcher2, _super);
    function StatWatcher2(vol2) {
      var _this = _super.call(this) || this;
      _this.onInterval = function() {
        try {
          var stats = _this.vol.statSync(_this.filename);
          if (_this.hasChanged(stats)) {
            _this.emit(\\"change\\", stats, _this.prev);
            _this.prev = stats;
          }
        } finally {
          _this.loop();
        }
      };
      _this.vol = vol2;
      return _this;
    }
    StatWatcher2.prototype.loop = function() {
      this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
    };
    StatWatcher2.prototype.hasChanged = function(stats) {
      if (stats.mtimeMs > this.prev.mtimeMs)
        return true;
      if (stats.nlink !== this.prev.nlink)
        return true;
      return false;
    };
    StatWatcher2.prototype.start = function(path2, persistent, interval) {
      if (persistent === void 0) {
        persistent = true;
      }
      if (interval === void 0) {
        interval = 5007;
      }
      this.filename = pathToFilename(path2);
      this.setTimeout = persistent ? setTimeout.bind(typeof globalThis !== \\"undefined\\" ? globalThis : _global4) : setTimeoutUnref_1.default;
      this.interval = interval;
      this.prev = this.vol.statSync(this.filename);
      this.loop();
    };
    StatWatcher2.prototype.stop = function() {
      clearTimeout(this.timeoutRef);
      process_1.default.nextTick(emitStop, this);
    };
    return StatWatcher2;
  }(events_1.EventEmitter);
  exports$42.StatWatcher = StatWatcher;
  var pool;
  function allocNewPool(poolSize) {
    pool = (0, buffer_1.bufferAllocUnsafe)(poolSize);
    pool.used = 0;
  }
  util.inherits(FsReadStream, stream_1.Readable);
  exports$42.ReadStream = FsReadStream;
  function FsReadStream(vol2, path2, options) {
    if (!(this instanceof FsReadStream))
      return new FsReadStream(vol2, path2, options);
    this._vol = vol2;
    options = Object.assign({}, getOptions(options, {}));
    if (options.highWaterMark === void 0)
      options.highWaterMark = 64 * 1024;
    stream_1.Readable.call(this, options);
    this.path = pathToFilename(path2);
    this.fd = options.fd === void 0 ? null : options.fd;
    this.flags = options.flags === void 0 ? \\"r\\" : options.flags;
    this.mode = options.mode === void 0 ? 438 : options.mode;
    this.start = options.start;
    this.end = options.end;
    this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
    this.pos = void 0;
    this.bytesRead = 0;
    if (this.start !== void 0) {
      if (typeof this.start !== \\"number\\") {
        throw new TypeError('\\"start\\" option must be a Number');
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if (typeof this.end !== \\"number\\") {
        throw new TypeError('\\"end\\" option must be a Number');
      }
      if (this.start > this.end) {
        throw new Error('\\"start\\" option must be <= \\"end\\" option');
      }
      this.pos = this.start;
    }
    if (typeof this.fd !== \\"number\\")
      this.open();
    this.on(\\"end\\", function() {
      if (this.autoClose) {
        if (this.destroy)
          this.destroy();
      }
    });
  }
  FsReadStream.prototype.open = function() {
    var self2 = this;
    this._vol.open(this.path, this.flags, this.mode, function(er, fd) {
      if (er) {
        if (self2.autoClose) {
          if (self2.destroy)
            self2.destroy();
        }
        self2.emit(\\"error\\", er);
        return;
      }
      self2.fd = fd;
      self2.emit(\\"open\\", fd);
      self2.read();
    });
  };
  FsReadStream.prototype._read = function(n8) {
    if (typeof this.fd !== \\"number\\") {
      return this.once(\\"open\\", function() {
        this._read(n8);
      });
    }
    if (this.destroyed)
      return;
    if (!pool || pool.length - pool.used < kMinPoolSpace) {
      allocNewPool(this._readableState.highWaterMark);
    }
    var thisPool = pool;
    var toRead = Math.min(pool.length - pool.used, n8);
    var start = pool.used;
    if (this.pos !== void 0)
      toRead = Math.min(this.end - this.pos + 1, toRead);
    if (toRead <= 0)
      return this.push(null);
    var self2 = this;
    this._vol.read(this.fd, pool, pool.used, toRead, this.pos, onread);
    if (this.pos !== void 0)
      this.pos += toRead;
    pool.used += toRead;
    function onread(er, bytesRead) {
      if (er) {
        if (self2.autoClose && self2.destroy) {
          self2.destroy();
        }
        self2.emit(\\"error\\", er);
      } else {
        var b5 = null;
        if (bytesRead > 0) {
          self2.bytesRead += bytesRead;
          b5 = thisPool.slice(start, start + bytesRead);
        }
        self2.push(b5);
      }
    }
  };
  FsReadStream.prototype._destroy = function(err, cb) {
    this.close(function(err2) {
      cb(err || err2);
    });
  };
  FsReadStream.prototype.close = function(cb) {
    var _this = this;
    if (cb)
      this.once(\\"close\\", cb);
    if (this.closed || typeof this.fd !== \\"number\\") {
      if (typeof this.fd !== \\"number\\") {
        this.once(\\"open\\", closeOnOpen);
        return;
      }
      return process_1.default.nextTick(function() {
        return _this.emit(\\"close\\");
      });
    }
    this.closed = true;
    this._vol.close(this.fd, function(er) {
      if (er)
        _this.emit(\\"error\\", er);
      else
        _this.emit(\\"close\\");
    });
    this.fd = null;
  };
  function closeOnOpen(fd) {
    this.close();
  }
  util.inherits(FsWriteStream, stream_1.Writable);
  exports$42.WriteStream = FsWriteStream;
  function FsWriteStream(vol2, path2, options) {
    if (!(this instanceof FsWriteStream))
      return new FsWriteStream(vol2, path2, options);
    this._vol = vol2;
    options = Object.assign({}, getOptions(options, {}));
    stream_1.Writable.call(this, options);
    this.path = pathToFilename(path2);
    this.fd = options.fd === void 0 ? null : options.fd;
    this.flags = options.flags === void 0 ? \\"w\\" : options.flags;
    this.mode = options.mode === void 0 ? 438 : options.mode;
    this.start = options.start;
    this.autoClose = options.autoClose === void 0 ? true : !!options.autoClose;
    this.pos = void 0;
    this.bytesWritten = 0;
    if (this.start !== void 0) {
      if (typeof this.start !== \\"number\\") {
        throw new TypeError('\\"start\\" option must be a Number');
      }
      if (this.start < 0) {
        throw new Error('\\"start\\" must be >= zero');
      }
      this.pos = this.start;
    }
    if (options.encoding)
      this.setDefaultEncoding(options.encoding);
    if (typeof this.fd !== \\"number\\")
      this.open();
    this.once(\\"finish\\", function() {
      if (this.autoClose) {
        this.close();
      }
    });
  }
  FsWriteStream.prototype.open = function() {
    this._vol.open(this.path, this.flags, this.mode, function(er, fd) {
      if (er) {
        if (this.autoClose && this.destroy) {
          this.destroy();
        }
        this.emit(\\"error\\", er);
        return;
      }
      this.fd = fd;
      this.emit(\\"open\\", fd);
    }.bind(this));
  };
  FsWriteStream.prototype._write = function(data, encoding, cb) {
    if (!(data instanceof buffer_1.Buffer))
      return this.emit(\\"error\\", new Error(\\"Invalid data\\"));
    if (typeof this.fd !== \\"number\\") {
      return this.once(\\"open\\", function() {
        this._write(data, encoding, cb);
      });
    }
    var self2 = this;
    this._vol.write(this.fd, data, 0, data.length, this.pos, function(er, bytes) {
      if (er) {
        if (self2.autoClose && self2.destroy) {
          self2.destroy();
        }
        return cb(er);
      }
      self2.bytesWritten += bytes;
      cb();
    });
    if (this.pos !== void 0)
      this.pos += data.length;
  };
  FsWriteStream.prototype._writev = function(data, cb) {
    if (typeof this.fd !== \\"number\\") {
      return this.once(\\"open\\", function() {
        this._writev(data, cb);
      });
    }
    var self2 = this;
    var len = data.length;
    var chunks = new Array(len);
    var size = 0;
    for (var i7 = 0; i7 < len; i7++) {
      var chunk = data[i7].chunk;
      chunks[i7] = chunk;
      size += chunk.length;
    }
    var buf = buffer_1.Buffer.concat(chunks);
    this._vol.write(this.fd, buf, 0, buf.length, this.pos, function(er, bytes) {
      if (er) {
        if (self2.destroy)
          self2.destroy();
        return cb(er);
      }
      self2.bytesWritten += bytes;
      cb();
    });
    if (this.pos !== void 0)
      this.pos += size;
  };
  FsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;
  FsWriteStream.prototype.close = FsReadStream.prototype.close;
  FsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end;
  var FSWatcher = function(_super) {
    __extends(FSWatcher2, _super);
    function FSWatcher2(vol2) {
      var _this = _super.call(this) || this;
      _this._filename = \\"\\";
      _this._filenameEncoded = \\"\\";
      _this._recursive = false;
      _this._encoding = encoding_1.ENCODING_UTF8;
      _this._onNodeChange = function() {
        _this._emit(\\"change\\");
      };
      _this._onParentChild = function(link2) {
        if (link2.getName() === _this._getName()) {
          _this._emit(\\"rename\\");
        }
      };
      _this._emit = function(type) {
        _this.emit(\\"change\\", type, _this._filenameEncoded);
      };
      _this._persist = function() {
        _this._timer = setTimeout(_this._persist, 1e6);
      };
      _this._vol = vol2;
      return _this;
    }
    FSWatcher2.prototype._getName = function() {
      return this._steps[this._steps.length - 1];
    };
    FSWatcher2.prototype.start = function(path2, persistent, recursive, encoding) {
      if (persistent === void 0) {
        persistent = true;
      }
      if (recursive === void 0) {
        recursive = false;
      }
      if (encoding === void 0) {
        encoding = encoding_1.ENCODING_UTF8;
      }
      this._filename = pathToFilename(path2);
      this._steps = filenameToSteps(this._filename);
      this._filenameEncoded = (0, encoding_1.strToEncoding)(this._filename);
      this._recursive = recursive;
      this._encoding = encoding;
      try {
        this._link = this._vol.getLinkOrThrow(this._filename, \\"FSWatcher\\");
      } catch (err) {
        var error = new Error(\\"watch \\" + this._filename + \\" \\" + err.code);
        error.code = err.code;
        error.errno = err.code;
        throw error;
      }
      this._link.getNode().on(\\"change\\", this._onNodeChange);
      this._link.on(\\"child:add\\", this._onNodeChange);
      this._link.on(\\"child:delete\\", this._onNodeChange);
      var parent = this._link.parent;
      if (parent) {
        parent.setMaxListeners(parent.getMaxListeners() + 1);
        parent.on(\\"child:delete\\", this._onParentChild);
      }
      if (persistent)
        this._persist();
    };
    FSWatcher2.prototype.close = function() {
      clearTimeout(this._timer);
      this._link.getNode().removeListener(\\"change\\", this._onNodeChange);
      var parent = this._link.parent;
      if (parent) {
        parent.removeListener(\\"child:delete\\", this._onParentChild);
      }
    };
    return FSWatcher2;
  }(events_1.EventEmitter);
  exports$42.FSWatcher = FSWatcher;
  return exports$42;
}
var exports$33 = {};
var _dewExec$13 = false;
function dew$13() {
  if (_dewExec$13)
    return exports$33;
  _dewExec$13 = true;
  Object.defineProperty(exports$33, \\"__esModule\\", {
    value: true
  });
  exports$33.fsAsyncMethods = exports$33.fsSyncMethods = exports$33.fsProps = void 0;
  var fsProps = [\\"constants\\", \\"F_OK\\", \\"R_OK\\", \\"W_OK\\", \\"X_OK\\", \\"Stats\\"];
  exports$33.fsProps = fsProps;
  var fsSyncMethods = [\\"renameSync\\", \\"ftruncateSync\\", \\"truncateSync\\", \\"chownSync\\", \\"fchownSync\\", \\"lchownSync\\", \\"chmodSync\\", \\"fchmodSync\\", \\"lchmodSync\\", \\"statSync\\", \\"lstatSync\\", \\"fstatSync\\", \\"linkSync\\", \\"symlinkSync\\", \\"readlinkSync\\", \\"realpathSync\\", \\"unlinkSync\\", \\"rmdirSync\\", \\"mkdirSync\\", \\"mkdirpSync\\", \\"readdirSync\\", \\"closeSync\\", \\"openSync\\", \\"utimesSync\\", \\"futimesSync\\", \\"fsyncSync\\", \\"writeSync\\", \\"readSync\\", \\"readFileSync\\", \\"writeFileSync\\", \\"appendFileSync\\", \\"existsSync\\", \\"accessSync\\", \\"fdatasyncSync\\", \\"mkdtempSync\\", \\"copyFileSync\\", \\"createReadStream\\", \\"createWriteStream\\"];
  exports$33.fsSyncMethods = fsSyncMethods;
  var fsAsyncMethods = [\\"rename\\", \\"ftruncate\\", \\"truncate\\", \\"chown\\", \\"fchown\\", \\"lchown\\", \\"chmod\\", \\"fchmod\\", \\"lchmod\\", \\"stat\\", \\"lstat\\", \\"fstat\\", \\"link\\", \\"symlink\\", \\"readlink\\", \\"realpath\\", \\"unlink\\", \\"rmdir\\", \\"mkdir\\", \\"mkdirp\\", \\"readdir\\", \\"close\\", \\"open\\", \\"utimes\\", \\"futimes\\", \\"fsync\\", \\"write\\", \\"read\\", \\"readFile\\", \\"writeFile\\", \\"appendFile\\", \\"exists\\", \\"access\\", \\"fdatasync\\", \\"mkdtemp\\", \\"copyFile\\", \\"watchFile\\", \\"unwatchFile\\", \\"watch\\"];
  exports$33.fsAsyncMethods = fsAsyncMethods;
  return exports$33;
}
var exports$23 = {};
var _dewExec7 = false;
function dew7() {
  if (_dewExec7)
    return exports$23;
  _dewExec7 = true;
  var __assign = exports$23 && exports$23.__assign || function() {
    __assign = Object.assign || function(t8) {
      for (var s6, i7 = 1, n8 = arguments.length; i7 < n8; i7++) {
        s6 = arguments[i7];
        for (var p7 in s6)
          if (Object.prototype.hasOwnProperty.call(s6, p7))
            t8[p7] = s6[p7];
      }
      return t8;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(exports$23, \\"__esModule\\", {
    value: true
  });
  exports$23.fs = exports$23.createFsFromVolume = exports$23.vol = exports$23.Volume = void 0;
  var Stats_1 = dew$d2();
  var Dirent_1 = dew$92();
  var volume_1 = dew$23();
  var _a = dew$13(), fsSyncMethods = _a.fsSyncMethods, fsAsyncMethods = _a.fsAsyncMethods;
  var constants_1 = dew$f2();
  var F_OK2 = constants_1.constants.F_OK, R_OK2 = constants_1.constants.R_OK, W_OK2 = constants_1.constants.W_OK, X_OK2 = constants_1.constants.X_OK;
  exports$23.Volume = volume_1.Volume;
  exports$23.vol = new volume_1.Volume();
  function createFsFromVolume2(vol2) {
    var fs2 = {
      F_OK: F_OK2,
      R_OK: R_OK2,
      W_OK: W_OK2,
      X_OK: X_OK2,
      constants: constants_1.constants,
      Stats: Stats_1.default,
      Dirent: Dirent_1.default
    };
    for (var _i = 0, fsSyncMethods_1 = fsSyncMethods; _i < fsSyncMethods_1.length; _i++) {
      var method = fsSyncMethods_1[_i];
      if (typeof vol2[method] === \\"function\\")
        fs2[method] = vol2[method].bind(vol2);
    }
    for (var _a2 = 0, fsAsyncMethods_1 = fsAsyncMethods; _a2 < fsAsyncMethods_1.length; _a2++) {
      var method = fsAsyncMethods_1[_a2];
      if (typeof vol2[method] === \\"function\\")
        fs2[method] = vol2[method].bind(vol2);
    }
    fs2.StatWatcher = vol2.StatWatcher;
    fs2.FSWatcher = vol2.FSWatcher;
    fs2.WriteStream = vol2.WriteStream;
    fs2.ReadStream = vol2.ReadStream;
    fs2.promises = vol2.promises;
    fs2._toUnixTimestamp = volume_1.toUnixTimestamp;
    return fs2;
  }
  exports$23.createFsFromVolume = createFsFromVolume2;
  exports$23.fs = createFsFromVolume2(exports$23.vol);
  exports$23 = __assign(__assign({}, exports$23), exports$23.fs);
  exports$23.semantic = true;
  return exports$23;
}
var exports$15 = dew7();
exports$15[\\"__esModule\\"];
exports$15[\\"fs\\"];
exports$15[\\"createFsFromVolume\\"];
exports$15[\\"vol\\"];
exports$15[\\"Volume\\"];
exports$15[\\"semantic\\"];
var exports7 = dew$23();
exports7[\\"__esModule\\"];
exports7[\\"FSWatcher\\"];
exports7[\\"StatWatcher\\"];
exports7[\\"Volume\\"];
exports7[\\"toUnixTimestamp\\"];
exports7[\\"bufferToEncoding\\"];
exports7[\\"dataToBuffer\\"];
exports7[\\"dataToStr\\"];
exports7[\\"pathToSteps\\"];
exports7[\\"filenameToSteps\\"];
exports7[\\"pathToFilename\\"];
exports7[\\"flagsToNumber\\"];
exports7[\\"FLAGS\\"];
exports7[\\"ReadStream\\"];
exports7[\\"WriteStream\\"];
var { vol, createFsFromVolume } = exports$15;
function unimplemented(name2) {
  throw new Error(\`Node.js fs \${name2} is not supported by JSPM core in the browser\`);
}
vol.fromNestedJSON({
  \\"/dev\\": { stdin: \\"\\", stdout: \\"\\", stderr: \\"\\" },
  \\"/usr/bin\\": {},
  \\"/home\\": {},
  \\"/tmp\\": {}
});
vol.releasedFds = [2, 1, 0];
vol.openSync(\\"/dev/stdin\\", \\"w\\");
vol.openSync(\\"/dev/stdout\\", \\"r\\");
vol.openSync(\\"/dev/stderr\\", \\"r\\");
watchStdo(\\"/dev/stdout\\", 1, console.log);
watchStdo(\\"/dev/stderr\\", 2, console.error);
function watchStdo(path2, fd, listener) {
  let oldSize = 0;
  const decoder = new TextDecoder();
  vol.watch(path2, \\"utf8\\", () => {
    const { size } = vol.fstatSync(fd);
    const buf = Buffer.alloc(size - oldSize);
    vol.readSync(fd, buf, 0, buf.length, oldSize);
    oldSize = size;
    listener(decoder.decode(buf, { stream: true }));
  });
}
var fs = createFsFromVolume(vol);
fs.opendir = () => unimplemented(\\"opendir\\");
fs.opendirSync = () => unimplemented(\\"opendirSync\\");
fs.promises.opendir = () => unimplemented(\\"promises.opendir\\");
fs.cp = () => unimplemented(\\"cp\\");
fs.cpSync = () => unimplemented(\\"cpSync\\");
fs.promises.cp = () => unimplemented(\\"promises.cp\\");
fs.readv = () => unimplemented(\\"readv\\");
fs.readvSync = () => unimplemented(\\"readvSync\\");
fs.rm = () => unimplemented(\\"rm\\");
fs.rmSync = () => unimplemented(\\"rmSync\\");
fs.promises.rm = () => unimplemented(\\"promises.rm\\");
fs.Dir = () => unimplemented(\\"Dir\\");
fs.promises.watch = () => unimplemented(\\"promises.watch\\");
fs.FileReadStream = fs.ReadStream;
fs.FileWriteStream = fs.WriteStream;
function handleFsUrl(url, isSync) {
  if (url.protocol === \\"file:\\")
    return fileURLToPath(url);
  if (url.protocol === \\"https:\\" || url.protocol === \\"http:\\") {
    const path2 = \\"\\\\\\\\\\\\\\\\url\\\\\\\\\\" + url.href.replaceAll(/\\\\//g, \\"\\\\\\\\\\\\\\\\\\");
    if (existsSync(path2))
      return path2;
    if (isSync)
      throw new Error(\`Cannot sync request URL \${url} via FS. JSPM FS support for network URLs requires using async FS methods or priming the MemFS cache first with an async request before a sync request.\`);
    return (async () => {
      const res = await fetch(url);
      if (!res.ok)
        throw new Error(\`Unable to fetch \${url.href}, \${res.status}\`);
      const buf = await res.arrayBuffer();
      writeFileSync(path2, Buffer.from(buf));
      return path2;
    })();
  }
  throw new Error(\\"URL \\" + url + \\" not supported in JSPM FS implementation.\\");
}
function wrapFsSync(fn) {
  return function(path2, ...args) {
    if (path2 instanceof URL)
      return fn(handleFsUrl(path2, true), ...args);
    return fn(path2, ...args);
  };
}
function wrapFsPromise(fn) {
  return async function(path2, ...args) {
    if (path2 instanceof URL)
      return fn(await handleFsUrl(path2), ...args);
    return fn(path2, ...args);
  };
}
function wrapFsCallback(fn) {
  return function(path2, ...args) {
    const cb = args[args.length - 1];
    if (path2 instanceof URL && typeof cb === \\"function\\") {
      handleFsUrl(path2).then((path3) => {
        fn(path3, ...args);
      }, cb);
    } else {
      fn(path2, ...args);
    }
  };
}
fs.promises.readFile = wrapFsPromise(fs.promises.readFile);
fs.readFile = wrapFsCallback(fs.readFile);
fs.readFileSync = wrapFsSync(fs.readFileSync);
var {
  appendFile,
  appendFileSync,
  access,
  accessSync,
  chown,
  chownSync,
  chmod,
  chmodSync,
  close,
  closeSync,
  copyFile,
  copyFileSync,
  cp,
  cpSync,
  createReadStream,
  createWriteStream,
  exists,
  existsSync,
  fchown,
  fchownSync,
  fchmod,
  fchmodSync,
  fdatasync,
  fdatasyncSync,
  fstat,
  fstatSync,
  fsync,
  fsyncSync,
  ftruncate,
  ftruncateSync,
  futimes,
  futimesSync,
  lchown,
  lchownSync,
  lchmod,
  lchmodSync,
  link,
  linkSync,
  lstat,
  lstatSync,
  mkdir,
  mkdirSync,
  mkdtemp,
  mkdtempSync,
  open,
  openSync,
  opendir,
  opendirSync,
  readdir,
  readdirSync,
  read,
  readSync,
  readv,
  readvSync,
  readFile,
  readFileSync,
  readlink,
  readlinkSync,
  realpath,
  realpathSync,
  rename,
  renameSync,
  rm,
  rmSync,
  rmdir,
  rmdirSync,
  stat,
  statSync,
  symlink,
  symlinkSync,
  truncate,
  truncateSync,
  unwatchFile,
  unlink,
  unlinkSync,
  utimes,
  utimesSync,
  watch,
  watchFile,
  writeFile,
  writeFileSync,
  write,
  writeSync,
  writev,
  writevSync,
  Dir,
  Dirent,
  Stats,
  ReadStream,
  WriteStream,
  FileReadStream,
  FileWriteStream,
  _toUnixTimestamp,
  constants: { F_OK, R_OK, W_OK, X_OK },
  constants,
  promises: promises2
} = fs;
export {
  Dir,
  Dirent,
  F_OK,
  FileReadStream,
  FileWriteStream,
  R_OK,
  ReadStream,
  Stats,
  W_OK,
  WriteStream,
  X_OK,
  _toUnixTimestamp,
  access,
  accessSync,
  appendFile,
  appendFileSync,
  chmod,
  chmodSync,
  chown,
  chownSync,
  close,
  closeSync,
  constants,
  copyFile,
  copyFileSync,
  cp,
  cpSync,
  createReadStream,
  createWriteStream,
  fs as default,
  exists,
  existsSync,
  fchmod,
  fchmodSync,
  fchown,
  fchownSync,
  fdatasync,
  fdatasyncSync,
  fstat,
  fstatSync,
  fsync,
  fsyncSync,
  ftruncate,
  ftruncateSync,
  futimes,
  futimesSync,
  lchmod,
  lchmodSync,
  lchown,
  lchownSync,
  link,
  linkSync,
  lstat,
  lstatSync,
  mkdir,
  mkdirSync,
  mkdtemp,
  mkdtempSync,
  open,
  openSync,
  opendir,
  opendirSync,
  promises2 as promises,
  read,
  readFile,
  readFileSync,
  readSync,
  readdir,
  readdirSync,
  readlink,
  readlinkSync,
  readv,
  readvSync,
  realpath,
  realpathSync,
  rename,
  renameSync,
  rm,
  rmSync,
  rmdir,
  rmdirSync,
  stat,
  statSync,
  symlink,
  symlinkSync,
  truncate,
  truncateSync,
  unlink,
  unlinkSync,
  unwatchFile,
  utimes,
  utimesSync,
  watch,
  watchFile,
  write,
  writeFile,
  writeFileSync,
  writeSync,
  writev,
  writevSync
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
"
`;

exports[`polyfillPath 1`] = `
"import { b as buffer } from './chunk-44e51b61.js';
import et from './assert.js';
import './util.js';
import { X } from './chunk-b4205b57.js';
import './path.js';
import { p as process } from './chunk-2eac56ff.js';
import './events.js';
import { y } from './chunk-4bd36a8f.js';
import './stream.js';
import h, { fileURLToPath } from './url.js';
import { e as exports$i } from './chunk-23dbec7b.js';
import { e as exports$j } from './chunk-6c718bbe.js';
import { Buffer } from './buffer.js';
import './chunk-ce0fbc82.js';
import './chunk-5decc758.js';
import './chunk-4ccc3a29.js';
import './chunk-924bb2e1.js';
import './chunk-b04e620d.js';

var exports$h = {},
    _dewExec$f = false;
function dew$f() {
  if (_dewExec$f) return exports$h;
  _dewExec$f = true;
  Object.defineProperty(exports$h, \\"__esModule\\", {
    value: true
  });
  exports$h.constants = void 0;
  exports$h.constants = {
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 64,
    O_EXCL: 128,
    O_NOCTTY: 256,
    O_TRUNC: 512,
    O_APPEND: 1024,
    O_DIRECTORY: 65536,
    O_NOATIME: 262144,
    O_NOFOLLOW: 131072,
    O_SYNC: 1052672,
    O_DIRECT: 16384,
    O_NONBLOCK: 2048,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    UV_FS_COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_EXCL: 1,
    COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE_FORCE: 4
  };
  return exports$h;
}

var exports$g = {},
    _dewExec$e = false;
function dew$e() {
  if (_dewExec$e) return exports$g;
  _dewExec$e = true;
  if (typeof BigInt === \\"function\\") exports$g.default = BigInt;else exports$g.default = function BigIntNotSupported() {
    throw new Error(\\"BigInt is not supported in this environment.\\");
  };
  return exports$g;
}

var exports$f = {},
    _dewExec$d = false;
function dew$d() {
  if (_dewExec$d) return exports$f;
  _dewExec$d = true;
  Object.defineProperty(exports$f, \\"__esModule\\", {
    value: true
  });
  exports$f.Stats = void 0;

  var constants_1 = dew$f();

  var getBigInt_1 = dew$e();

  var S_IFMT = constants_1.constants.S_IFMT,
      S_IFDIR = constants_1.constants.S_IFDIR,
      S_IFREG = constants_1.constants.S_IFREG,
      S_IFBLK = constants_1.constants.S_IFBLK,
      S_IFCHR = constants_1.constants.S_IFCHR,
      S_IFLNK = constants_1.constants.S_IFLNK,
      S_IFIFO = constants_1.constants.S_IFIFO,
      S_IFSOCK = constants_1.constants.S_IFSOCK;
  /**
   * Statistics about a file/directory, like \`fs.Stats\`.
   */

  var Stats = function () {
    function Stats() {}

    Stats.build = function (node, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }

      var stats = new Stats();
      var uid = node.uid,
          gid = node.gid,
          atime = node.atime,
          mtime = node.mtime,
          ctime = node.ctime;
      var getStatNumber = !bigint ? function (number) {
        return number;
      } : getBigInt_1.default; // Copy all values on Stats from Node, so that if Node values
      // change, values on Stats would still be the old ones,
      // just like in Node fs.

      stats.uid = getStatNumber(uid);
      stats.gid = getStatNumber(gid);
      stats.rdev = getStatNumber(0);
      stats.blksize = getStatNumber(4096);
      stats.ino = getStatNumber(node.ino);
      stats.size = getStatNumber(node.getSize());
      stats.blocks = getStatNumber(1);
      stats.atime = atime;
      stats.mtime = mtime;
      stats.ctime = ctime;
      stats.birthtime = ctime;
      stats.atimeMs = getStatNumber(atime.getTime());
      stats.mtimeMs = getStatNumber(mtime.getTime());
      var ctimeMs = getStatNumber(ctime.getTime());
      stats.ctimeMs = ctimeMs;
      stats.birthtimeMs = ctimeMs;
      stats.dev = getStatNumber(0);
      stats.mode = getStatNumber(node.mode);
      stats.nlink = getStatNumber(node.nlink);
      return stats;
    };

    Stats.prototype._checkModeProperty = function (property) {
      return (Number(this.mode) & S_IFMT) === property;
    };

    Stats.prototype.isDirectory = function () {
      return this._checkModeProperty(S_IFDIR);
    };

    Stats.prototype.isFile = function () {
      return this._checkModeProperty(S_IFREG);
    };

    Stats.prototype.isBlockDevice = function () {
      return this._checkModeProperty(S_IFBLK);
    };

    Stats.prototype.isCharacterDevice = function () {
      return this._checkModeProperty(S_IFCHR);
    };

    Stats.prototype.isSymbolicLink = function () {
      return this._checkModeProperty(S_IFLNK);
    };

    Stats.prototype.isFIFO = function () {
      return this._checkModeProperty(S_IFIFO);
    };

    Stats.prototype.isSocket = function () {
      return this._checkModeProperty(S_IFSOCK);
    };

    return Stats;
  }();

  exports$f.Stats = Stats;
  exports$f.default = Stats;
  return exports$f;
}

var exports$e = {},
    _dewExec$c = false;
function dew$c() {
  if (_dewExec$c) return exports$e;
  _dewExec$c = true;

  var __spreadArray = exports$e && exports$e.__spreadArray || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };

  Object.defineProperty(exports$e, \\"__esModule\\", {
    value: true
  });
  exports$e.bufferFrom = exports$e.bufferAllocUnsafe = exports$e.Buffer = void 0;
  var buffer_1 = buffer;
  Object.defineProperty(exports$e, \\"Buffer\\", {
    enumerable: true,
    get: function () {
      return buffer_1.Buffer;
    }
  });

  function bufferV0P12Ponyfill(arg0) {
    var args = [];

    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }

    return new (buffer_1.Buffer.bind.apply(buffer_1.Buffer, __spreadArray([void 0, arg0], args, false)))();
  }

  var bufferAllocUnsafe = buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;
  exports$e.bufferAllocUnsafe = bufferAllocUnsafe;
  var bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;
  exports$e.bufferFrom = bufferFrom;
  return exports$e;
}

var exports$d = {},
    _dewExec$b = false;

var _global$3 = typeof globalThis !== \\"undefined\\" ? globalThis : typeof self !== \\"undefined\\" ? self : global;

function dew$b() {
  if (_dewExec$b) return exports$d;
  _dewExec$b = true;

  // The whole point behind this internal module is to allow Node.js to no
  // longer be forced to treat every error message change as a semver-major
  // change. The NodeError classes here all expose a \`code\` property whose
  // value statically and permanently identifies the error. While the error
  // message may change, the code should not.
  var __extends = exports$d && exports$d.__extends || function () {
    var extendStatics = function (d, b) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      };

      return extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== \\"function\\" && b !== null) throw new TypeError(\\"Class extends value \\" + String(b) + \\" is not a constructor or null\\");
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(exports$d, \\"__esModule\\", {
    value: true
  });
  exports$d.E = exports$d.AssertionError = exports$d.message = exports$d.RangeError = exports$d.TypeError = exports$d.Error = void 0;
  var assert = et;
  var util = X;
  var kCode = typeof Symbol === \\"undefined\\" ? \\"_kCode\\" : Symbol(\\"code\\");
  var messages = {}; // new Map();

  function makeNodeError(Base) {
    return function (_super) {
      __extends(NodeError, _super);

      function NodeError(key) {
        var args = [];

        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }

        var _this = _super.call(this, message(key, args)) || this;

        _this.code = key;
        _this[kCode] = key;
        _this.name = _super.prototype.name + \\" [\\" + _this[kCode] + \\"]\\";
        return _this;
      }

      return NodeError;
    }(Base);
  }

  var g = typeof globalThis !== \\"undefined\\" ? globalThis : _global$3;

  var AssertionError = function (_super) {
    __extends(AssertionError, _super);

    function AssertionError(options) {
      var _this = this;

      if (typeof options !== \\"object\\" || options === null) {
        throw new exports$d.TypeError(\\"ERR_INVALID_ARG_TYPE\\", \\"options\\", \\"object\\");
      }

      if (options.message) {
        _this = _super.call(this, options.message) || this;
      } else {
        _this = _super.call(this, util.inspect(options.actual).slice(0, 128) + \\" \\" + (options.operator + \\" \\" + util.inspect(options.expected).slice(0, 128))) || this;
      }

      _this.generatedMessage = !options.message;
      _this.name = \\"AssertionError [ERR_ASSERTION]\\";
      _this.code = \\"ERR_ASSERTION\\";
      _this.actual = options.actual;
      _this.expected = options.expected;
      _this.operator = options.operator;
      exports$d.Error.captureStackTrace(_this, options.stackStartFunction);
      return _this;
    }

    return AssertionError;
  }(g.Error);

  exports$d.AssertionError = AssertionError;

  function message(key, args) {
    assert.strictEqual(typeof key, \\"string\\"); // const msg = messages.get(key);

    var msg = messages[key];
    assert(msg, \\"An invalid error message key was used: \\" + key + \\".\\");
    var fmt;

    if (typeof msg === \\"function\\") {
      fmt = msg;
    } else {
      fmt = util.format;
      if (args === undefined || args.length === 0) return msg;
      args.unshift(msg);
    }

    return String(fmt.apply(null, args));
  }

  exports$d.message = message; // Utility function for registering the error codes. Only used here. Exported
  // *only* to allow for testing.

  function E(sym, val) {
    messages[sym] = typeof val === \\"function\\" ? val : String(val);
  }

  exports$d.E = E;
  exports$d.Error = makeNodeError(g.Error);
  exports$d.TypeError = makeNodeError(g.TypeError);
  exports$d.RangeError = makeNodeError(g.RangeError); // To declare an error message, use the E(sym, val) function above. The sym
  // must be an upper case string. The val can be either a function or a string.
  // The return value of the function must be a string.
  // Examples:
  // E('EXAMPLE_KEY1', 'This is the error value');
  // E('EXAMPLE_KEY2', (a, b) => return \`\${a} \${b}\`);
  //
  // Once an error code has been assigned, the code itself MUST NOT change and
  // any given error code must never be reused to identify a different error.
  //
  // Any error code added here should also be added to the documentation
  //
  // Note: Please try to keep these in alphabetical order

  E(\\"ERR_ARG_NOT_ITERABLE\\", \\"%s must be iterable\\");
  E(\\"ERR_ASSERTION\\", \\"%s\\");
  E(\\"ERR_BUFFER_OUT_OF_BOUNDS\\", bufferOutOfBounds);
  E(\\"ERR_CHILD_CLOSED_BEFORE_REPLY\\", \\"Child closed before reply received\\");
  E(\\"ERR_CONSOLE_WRITABLE_STREAM\\", \\"Console expects a writable stream instance for %s\\");
  E(\\"ERR_CPU_USAGE\\", \\"Unable to obtain cpu usage %s\\");
  E(\\"ERR_DNS_SET_SERVERS_FAILED\\", function (err, servers) {
    return \\"c-ares failed to set servers: \\\\\\"\\" + err + \\"\\\\\\" [\\" + servers + \\"]\\";
  });
  E(\\"ERR_FALSY_VALUE_REJECTION\\", \\"Promise was rejected with falsy value\\");
  E(\\"ERR_ENCODING_NOT_SUPPORTED\\", function (enc) {
    return \\"The \\\\\\"\\" + enc + \\"\\\\\\" encoding is not supported\\";
  });
  E(\\"ERR_ENCODING_INVALID_ENCODED_DATA\\", function (enc) {
    return \\"The encoded data was not valid for encoding \\" + enc;
  });
  E(\\"ERR_HTTP_HEADERS_SENT\\", \\"Cannot render headers after they are sent to the client\\");
  E(\\"ERR_HTTP_INVALID_STATUS_CODE\\", \\"Invalid status code: %s\\");
  E(\\"ERR_HTTP_TRAILER_INVALID\\", \\"Trailers are invalid with this transfer encoding\\");
  E(\\"ERR_INDEX_OUT_OF_RANGE\\", \\"Index out of range\\");
  E(\\"ERR_INVALID_ARG_TYPE\\", invalidArgType);
  E(\\"ERR_INVALID_ARRAY_LENGTH\\", function (name, len, actual) {
    assert.strictEqual(typeof actual, \\"number\\");
    return \\"The array \\\\\\"\\" + name + \\"\\\\\\" (length \\" + actual + \\") must be of length \\" + len + \\".\\";
  });
  E(\\"ERR_INVALID_BUFFER_SIZE\\", \\"Buffer size must be a multiple of %s\\");
  E(\\"ERR_INVALID_CALLBACK\\", \\"Callback must be a function\\");
  E(\\"ERR_INVALID_CHAR\\", \\"Invalid character in %s\\");
  E(\\"ERR_INVALID_CURSOR_POS\\", \\"Cannot set cursor row without setting its column\\");
  E(\\"ERR_INVALID_FD\\", \\"\\\\\\"fd\\\\\\" must be a positive integer: %s\\");
  E(\\"ERR_INVALID_FILE_URL_HOST\\", \\"File URL host must be \\\\\\"localhost\\\\\\" or empty on %s\\");
  E(\\"ERR_INVALID_FILE_URL_PATH\\", \\"File URL path %s\\");
  E(\\"ERR_INVALID_HANDLE_TYPE\\", \\"This handle type cannot be sent\\");
  E(\\"ERR_INVALID_IP_ADDRESS\\", \\"Invalid IP address: %s\\");
  E(\\"ERR_INVALID_OPT_VALUE\\", function (name, value) {
    return \\"The value \\\\\\"\\" + String(value) + \\"\\\\\\" is invalid for option \\\\\\"\\" + name + \\"\\\\\\"\\";
  });
  E(\\"ERR_INVALID_OPT_VALUE_ENCODING\\", function (value) {
    return \\"The value \\\\\\"\\" + String(value) + \\"\\\\\\" is invalid for option \\\\\\"encoding\\\\\\"\\";
  });
  E(\\"ERR_INVALID_REPL_EVAL_CONFIG\\", \\"Cannot specify both \\\\\\"breakEvalOnSigint\\\\\\" and \\\\\\"eval\\\\\\" for REPL\\");
  E(\\"ERR_INVALID_SYNC_FORK_INPUT\\", \\"Asynchronous forks do not support Buffer, Uint8Array or string input: %s\\");
  E(\\"ERR_INVALID_THIS\\", \\"Value of \\\\\\"this\\\\\\" must be of type %s\\");
  E(\\"ERR_INVALID_TUPLE\\", \\"%s must be an iterable %s tuple\\");
  E(\\"ERR_INVALID_URL\\", \\"Invalid URL: %s\\");
  E(\\"ERR_INVALID_URL_SCHEME\\", function (expected) {
    return \\"The URL must be \\" + oneOf(expected, \\"scheme\\");
  });
  E(\\"ERR_IPC_CHANNEL_CLOSED\\", \\"Channel closed\\");
  E(\\"ERR_IPC_DISCONNECTED\\", \\"IPC channel is already disconnected\\");
  E(\\"ERR_IPC_ONE_PIPE\\", \\"Child process can have only one IPC pipe\\");
  E(\\"ERR_IPC_SYNC_FORK\\", \\"IPC cannot be used with synchronous forks\\");
  E(\\"ERR_MISSING_ARGS\\", missingArgs);
  E(\\"ERR_MULTIPLE_CALLBACK\\", \\"Callback called multiple times\\");
  E(\\"ERR_NAPI_CONS_FUNCTION\\", \\"Constructor must be a function\\");
  E(\\"ERR_NAPI_CONS_PROTOTYPE_OBJECT\\", \\"Constructor.prototype must be an object\\");
  E(\\"ERR_NO_CRYPTO\\", \\"Node.js is not compiled with OpenSSL crypto support\\");
  E(\\"ERR_NO_LONGER_SUPPORTED\\", \\"%s is no longer supported\\");
  E(\\"ERR_PARSE_HISTORY_DATA\\", \\"Could not parse history data in %s\\");
  E(\\"ERR_SOCKET_ALREADY_BOUND\\", \\"Socket is already bound\\");
  E(\\"ERR_SOCKET_BAD_PORT\\", \\"Port should be > 0 and < 65536\\");
  E(\\"ERR_SOCKET_BAD_TYPE\\", \\"Bad socket type specified. Valid types are: udp4, udp6\\");
  E(\\"ERR_SOCKET_CANNOT_SEND\\", \\"Unable to send data\\");
  E(\\"ERR_SOCKET_CLOSED\\", \\"Socket is closed\\");
  E(\\"ERR_SOCKET_DGRAM_NOT_RUNNING\\", \\"Not running\\");
  E(\\"ERR_STDERR_CLOSE\\", \\"process.stderr cannot be closed\\");
  E(\\"ERR_STDOUT_CLOSE\\", \\"process.stdout cannot be closed\\");
  E(\\"ERR_STREAM_WRAP\\", \\"Stream has StringDecoder set or is in objectMode\\");
  E(\\"ERR_TLS_CERT_ALTNAME_INVALID\\", \\"Hostname/IP does not match certificate's altnames: %s\\");
  E(\\"ERR_TLS_DH_PARAM_SIZE\\", function (size) {
    return \\"DH parameter size \\" + size + \\" is less than 2048\\";
  });
  E(\\"ERR_TLS_HANDSHAKE_TIMEOUT\\", \\"TLS handshake timeout\\");
  E(\\"ERR_TLS_RENEGOTIATION_FAILED\\", \\"Failed to renegotiate\\");
  E(\\"ERR_TLS_REQUIRED_SERVER_NAME\\", \\"\\\\\\"servername\\\\\\" is required parameter for Server.addContext\\");
  E(\\"ERR_TLS_SESSION_ATTACK\\", \\"TSL session renegotiation attack detected\\");
  E(\\"ERR_TRANSFORM_ALREADY_TRANSFORMING\\", \\"Calling transform done when still transforming\\");
  E(\\"ERR_TRANSFORM_WITH_LENGTH_0\\", \\"Calling transform done when writableState.length != 0\\");
  E(\\"ERR_UNKNOWN_ENCODING\\", \\"Unknown encoding: %s\\");
  E(\\"ERR_UNKNOWN_SIGNAL\\", \\"Unknown signal: %s\\");
  E(\\"ERR_UNKNOWN_STDIN_TYPE\\", \\"Unknown stdin file type\\");
  E(\\"ERR_UNKNOWN_STREAM_TYPE\\", \\"Unknown stream file type\\");
  E(\\"ERR_V8BREAKITERATOR\\", \\"Full ICU data not installed. \\" + \\"See https://github.com/nodejs/node/wiki/Intl\\");

  function invalidArgType(name, expected, actual) {
    assert(name, \\"name is required\\"); // determiner: 'must be' or 'must not be'

    var determiner;

    if (expected.includes(\\"not \\")) {
      determiner = \\"must not be\\";
      expected = expected.split(\\"not \\")[1];
    } else {
      determiner = \\"must be\\";
    }

    var msg;

    if (Array.isArray(name)) {
      var names = name.map(function (val) {
        return \\"\\\\\\"\\" + val + \\"\\\\\\"\\";
      }).join(\\", \\");
      msg = \\"The \\" + names + \\" arguments \\" + determiner + \\" \\" + oneOf(expected, \\"type\\");
    } else if (name.includes(\\" argument\\")) {
      // for the case like 'first argument'
      msg = \\"The \\" + name + \\" \\" + determiner + \\" \\" + oneOf(expected, \\"type\\");
    } else {
      var type = name.includes(\\".\\") ? \\"property\\" : \\"argument\\";
      msg = \\"The \\\\\\"\\" + name + \\"\\\\\\" \\" + type + \\" \\" + determiner + \\" \\" + oneOf(expected, \\"type\\");
    } // if actual value received, output it


    if (arguments.length >= 3) {
      msg += \\". Received type \\" + (actual !== null ? typeof actual : \\"null\\");
    }

    return msg;
  }

  function missingArgs() {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    assert(args.length > 0, \\"At least one arg needs to be specified\\");
    var msg = \\"The \\";
    var len = args.length;
    args = args.map(function (a) {
      return \\"\\\\\\"\\" + a + \\"\\\\\\"\\";
    });

    switch (len) {
      case 1:
        msg += args[0] + \\" argument\\";
        break;

      case 2:
        msg += args[0] + \\" and \\" + args[1] + \\" arguments\\";
        break;

      default:
        msg += args.slice(0, len - 1).join(\\", \\");
        msg += \\", and \\" + args[len - 1] + \\" arguments\\";
        break;
    }

    return msg + \\" must be specified\\";
  }

  function oneOf(expected, thing) {
    assert(expected, \\"expected is required\\");
    assert(typeof thing === \\"string\\", \\"thing is required\\");

    if (Array.isArray(expected)) {
      var len = expected.length;
      assert(len > 0, \\"At least one expected value needs to be specified\\"); // tslint:disable-next-line

      expected = expected.map(function (i) {
        return String(i);
      });

      if (len > 2) {
        return \\"one of \\" + thing + \\" \\" + expected.slice(0, len - 1).join(\\", \\") + \\", or \\" + expected[len - 1];
      } else if (len === 2) {
        return \\"one of \\" + thing + \\" \\" + expected[0] + \\" or \\" + expected[1];
      } else {
        return \\"of \\" + thing + \\" \\" + expected[0];
      }
    } else {
      return \\"of \\" + thing + \\" \\" + String(expected);
    }
  }

  function bufferOutOfBounds(name, isWriting) {
    if (isWriting) {
      return \\"Attempt to write outside buffer bounds\\";
    } else {
      return \\"\\\\\\"\\" + name + \\"\\\\\\" is outside of buffer bounds\\";
    }
  }

  return exports$d;
}

var exports$c = {},
    _dewExec$a = false;
function dew$a() {
  if (_dewExec$a) return exports$c;
  _dewExec$a = true;
  Object.defineProperty(exports$c, \\"__esModule\\", {
    value: true
  });
  exports$c.strToEncoding = exports$c.assertEncoding = exports$c.ENCODING_UTF8 = void 0;

  var buffer_1 = dew$c();

  var errors = dew$b();

  exports$c.ENCODING_UTF8 = \\"utf8\\";

  function assertEncoding(encoding) {
    if (encoding && !buffer_1.Buffer.isEncoding(encoding)) throw new errors.TypeError(\\"ERR_INVALID_OPT_VALUE_ENCODING\\", encoding);
  }

  exports$c.assertEncoding = assertEncoding;

  function strToEncoding(str, encoding) {
    if (!encoding || encoding === exports$c.ENCODING_UTF8) return str; // UTF-8

    if (encoding === \\"buffer\\") return new buffer_1.Buffer(str); // \`buffer\` encoding

    return new buffer_1.Buffer(str).toString(encoding); // Custom encoding
  }

  exports$c.strToEncoding = strToEncoding;
  return exports$c;
}

var exports$b = {},
    _dewExec$9 = false;
function dew$9() {
  if (_dewExec$9) return exports$b;
  _dewExec$9 = true;
  Object.defineProperty(exports$b, \\"__esModule\\", {
    value: true
  });
  exports$b.Dirent = void 0;

  var constants_1 = dew$f();

  var encoding_1 = dew$a();

  var S_IFMT = constants_1.constants.S_IFMT,
      S_IFDIR = constants_1.constants.S_IFDIR,
      S_IFREG = constants_1.constants.S_IFREG,
      S_IFBLK = constants_1.constants.S_IFBLK,
      S_IFCHR = constants_1.constants.S_IFCHR,
      S_IFLNK = constants_1.constants.S_IFLNK,
      S_IFIFO = constants_1.constants.S_IFIFO,
      S_IFSOCK = constants_1.constants.S_IFSOCK;
  /**
   * A directory entry, like \`fs.Dirent\`.
   */

  var Dirent = function () {
    function Dirent() {
      this.name = \\"\\";
      this.mode = 0;
    }

    Dirent.build = function (link, encoding) {
      var dirent = new Dirent();
      var mode = link.getNode().mode;
      dirent.name = (0, encoding_1.strToEncoding)(link.getName(), encoding);
      dirent.mode = mode;
      return dirent;
    };

    Dirent.prototype._checkModeProperty = function (property) {
      return (this.mode & S_IFMT) === property;
    };

    Dirent.prototype.isDirectory = function () {
      return this._checkModeProperty(S_IFDIR);
    };

    Dirent.prototype.isFile = function () {
      return this._checkModeProperty(S_IFREG);
    };

    Dirent.prototype.isBlockDevice = function () {
      return this._checkModeProperty(S_IFBLK);
    };

    Dirent.prototype.isCharacterDevice = function () {
      return this._checkModeProperty(S_IFCHR);
    };

    Dirent.prototype.isSymbolicLink = function () {
      return this._checkModeProperty(S_IFLNK);
    };

    Dirent.prototype.isFIFO = function () {
      return this._checkModeProperty(S_IFIFO);
    };

    Dirent.prototype.isSocket = function () {
      return this._checkModeProperty(S_IFSOCK);
    };

    return Dirent;
  }();

  exports$b.Dirent = Dirent;
  exports$b.default = Dirent;
  return exports$b;
}

var exports$a = {},
    _dewExec$8 = false;

var _global$2 = typeof globalThis !== \\"undefined\\" ? globalThis : typeof self !== \\"undefined\\" ? self : global;

function dew$8() {
  if (_dewExec$8) return exports$a;
  _dewExec$8 = true;
  var process$1 = process;
  Object.defineProperty(exports$a, \\"__esModule\\", {
    value: true
  });

  var _setImmediate;

  if (typeof process$1.nextTick === \\"function\\") _setImmediate = process$1.nextTick.bind(typeof globalThis !== \\"undefined\\" ? globalThis : _global$2);else _setImmediate = setTimeout.bind(typeof globalThis !== \\"undefined\\" ? globalThis : _global$2);
  exports$a.default = _setImmediate;
  return exports$a;
}

var exports$9 = {},
    _dewExec$7 = false;
function dew$7() {
  if (_dewExec$7) return exports$9;
  _dewExec$7 = true;
  var process$1 = process;
  // Here we mock the global \`process\` variable in case we are not in Node's environment.
  Object.defineProperty(exports$9, \\"__esModule\\", {
    value: true
  });
  exports$9.createProcess = void 0;
  /**
   * Looks to return a \`process\` object, if one is available.
   *
   * The global \`process\` is returned if defined;
   * otherwise \`require('process')\` is attempted.
   *
   * If that fails, \`undefined\` is returned.
   *
   * @return {IProcess | undefined}
   */

  var maybeReturnProcess = function () {
    if (typeof process$1 !== \\"undefined\\") {
      return process$1;
    }

    try {
      return process;
    } catch (_a) {
      return undefined;
    }
  };

  function createProcess() {
    var p = maybeReturnProcess() || {};
    if (!p.getuid) p.getuid = function () {
      return 0;
    };
    if (!p.getgid) p.getgid = function () {
      return 0;
    };
    if (!p.cwd) p.cwd = function () {
      return \\"/\\";
    };
    if (!p.nextTick) p.nextTick = dew$8().default;
    if (!p.emitWarning) p.emitWarning = function (message, type) {
      // tslint:disable-next-line:no-console
      console.warn(\\"\\" + type + (type ? \\": \\" : \\"\\") + message);
    };
    if (!p.env) p.env = {};
    return p;
  }

  exports$9.createProcess = createProcess;
  exports$9.default = createProcess();
  return exports$9;
}

var exports$8 = {},
    _dewExec$6 = false;
function dew$6() {
  if (_dewExec$6) return exports$8;
  _dewExec$6 = true;

  var __extends = exports$8 && exports$8.__extends || function () {
    var extendStatics = function (d, b) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      };

      return extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== \\"function\\" && b !== null) throw new TypeError(\\"Class extends value \\" + String(b) + \\" is not a constructor or null\\");
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(exports$8, \\"__esModule\\", {
    value: true
  });
  exports$8.File = exports$8.Link = exports$8.Node = exports$8.SEP = void 0;

  var process_1 = dew$7();

  var buffer_1 = dew$c();

  var constants_1 = dew$f();

  var events_1 = y;

  var Stats_1 = dew$d();

  var S_IFMT = constants_1.constants.S_IFMT,
      S_IFDIR = constants_1.constants.S_IFDIR,
      S_IFREG = constants_1.constants.S_IFREG,
      S_IFLNK = constants_1.constants.S_IFLNK,
      O_APPEND = constants_1.constants.O_APPEND;
  exports$8.SEP = \\"/\\";
  /**
   * Node in a file system (like i-node, v-node).
   */

  var Node = function (_super) {
    __extends(Node, _super);

    function Node(ino, perm) {
      if (perm === void 0) {
        perm = 438;
      }

      var _this = _super.call(this) || this; // User ID and group ID.


      _this.uid = process_1.default.getuid();
      _this.gid = process_1.default.getgid();
      _this.atime = new Date();
      _this.mtime = new Date();
      _this.ctime = new Date();
      _this.perm = 438; // Permissions \`chmod\`, \`fchmod\`

      _this.mode = S_IFREG; // S_IFDIR, S_IFREG, etc.. (file by default?)
      // Number of hard links pointing at this Node.

      _this.nlink = 1;
      _this.perm = perm;
      _this.mode |= perm;
      _this.ino = ino;
      return _this;
    }

    Node.prototype.getString = function (encoding) {
      if (encoding === void 0) {
        encoding = \\"utf8\\";
      }

      return this.getBuffer().toString(encoding);
    };

    Node.prototype.setString = function (str) {
      // this.setBuffer(bufferFrom(str, 'utf8'));
      this.buf = (0, buffer_1.bufferFrom)(str, \\"utf8\\");
      this.touch();
    };

    Node.prototype.getBuffer = function () {
      if (!this.buf) this.setBuffer((0, buffer_1.bufferAllocUnsafe)(0));
      return (0, buffer_1.bufferFrom)(this.buf); // Return a copy.
    };

    Node.prototype.setBuffer = function (buf) {
      this.buf = (0, buffer_1.bufferFrom)(buf); // Creates a copy of data.

      this.touch();
    };

    Node.prototype.getSize = function () {
      return this.buf ? this.buf.length : 0;
    };

    Node.prototype.setModeProperty = function (property) {
      this.mode = this.mode & ~S_IFMT | property;
    };

    Node.prototype.setIsFile = function () {
      this.setModeProperty(S_IFREG);
    };

    Node.prototype.setIsDirectory = function () {
      this.setModeProperty(S_IFDIR);
    };

    Node.prototype.setIsSymlink = function () {
      this.setModeProperty(S_IFLNK);
    };

    Node.prototype.isFile = function () {
      return (this.mode & S_IFMT) === S_IFREG;
    };

    Node.prototype.isDirectory = function () {
      return (this.mode & S_IFMT) === S_IFDIR;
    };

    Node.prototype.isSymlink = function () {
      // return !!this.symlink;
      return (this.mode & S_IFMT) === S_IFLNK;
    };

    Node.prototype.makeSymlink = function (steps) {
      this.symlink = steps;
      this.setIsSymlink();
    };

    Node.prototype.write = function (buf, off, len, pos) {
      if (off === void 0) {
        off = 0;
      }

      if (len === void 0) {
        len = buf.length;
      }

      if (pos === void 0) {
        pos = 0;
      }

      if (!this.buf) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);

      if (pos + len > this.buf.length) {
        var newBuf = (0, buffer_1.bufferAllocUnsafe)(pos + len);
        this.buf.copy(newBuf, 0, 0, this.buf.length);
        this.buf = newBuf;
      }

      buf.copy(this.buf, pos, off, off + len);
      this.touch();
      return len;
    }; // Returns the number of bytes read.


    Node.prototype.read = function (buf, off, len, pos) {
      if (off === void 0) {
        off = 0;
      }

      if (len === void 0) {
        len = buf.byteLength;
      }

      if (pos === void 0) {
        pos = 0;
      }

      if (!this.buf) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
      var actualLen = len;

      if (actualLen > buf.byteLength) {
        actualLen = buf.byteLength;
      }

      if (actualLen + pos > this.buf.length) {
        actualLen = this.buf.length - pos;
      }

      this.buf.copy(buf, off, pos, pos + actualLen);
      return actualLen;
    };

    Node.prototype.truncate = function (len) {
      if (len === void 0) {
        len = 0;
      }

      if (!len) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);else {
        if (!this.buf) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);

        if (len <= this.buf.length) {
          this.buf = this.buf.slice(0, len);
        } else {
          var buf = (0, buffer_1.bufferAllocUnsafe)(0);
          this.buf.copy(buf);
          buf.fill(0, len);
        }
      }
      this.touch();
    };

    Node.prototype.chmod = function (perm) {
      this.perm = perm;
      this.mode = this.mode & ~511 | perm;
      this.touch();
    };

    Node.prototype.chown = function (uid, gid) {
      this.uid = uid;
      this.gid = gid;
      this.touch();
    };

    Node.prototype.touch = function () {
      this.mtime = new Date();
      this.emit(\\"change\\", this);
    };

    Node.prototype.canRead = function (uid, gid) {
      if (uid === void 0) {
        uid = process_1.default.getuid();
      }

      if (gid === void 0) {
        gid = process_1.default.getgid();
      }

      if (this.perm & 4
      /* IROTH */
      ) {
        return true;
      }

      if (gid === this.gid) {
        if (this.perm & 32
        /* IRGRP */
        ) {
          return true;
        }
      }

      if (uid === this.uid) {
        if (this.perm & 256
        /* IRUSR */
        ) {
          return true;
        }
      }

      return false;
    };

    Node.prototype.canWrite = function (uid, gid) {
      if (uid === void 0) {
        uid = process_1.default.getuid();
      }

      if (gid === void 0) {
        gid = process_1.default.getgid();
      }

      if (this.perm & 2
      /* IWOTH */
      ) {
        return true;
      }

      if (gid === this.gid) {
        if (this.perm & 16
        /* IWGRP */
        ) {
          return true;
        }
      }

      if (uid === this.uid) {
        if (this.perm & 128
        /* IWUSR */
        ) {
          return true;
        }
      }

      return false;
    };

    Node.prototype.del = function () {
      this.emit(\\"delete\\", this);
    };

    Node.prototype.toJSON = function () {
      return {
        ino: this.ino,
        uid: this.uid,
        gid: this.gid,
        atime: this.atime.getTime(),
        mtime: this.mtime.getTime(),
        ctime: this.ctime.getTime(),
        perm: this.perm,
        mode: this.mode,
        nlink: this.nlink,
        symlink: this.symlink,
        data: this.getString()
      };
    };

    return Node;
  }(events_1.EventEmitter);

  exports$8.Node = Node;
  /**
   * Represents a hard link that points to an i-node \`node\`.
   */

  var Link = function (_super) {
    __extends(Link, _super);

    function Link(vol, parent, name) {
      var _this = _super.call(this) || this;

      _this.children = {}; // Path to this node as Array: ['usr', 'bin', 'node'].

      _this.steps = []; // \\"i-node\\" number of the node.

      _this.ino = 0; // Number of children.

      _this.length = 0;
      _this.vol = vol;
      _this.parent = parent;
      _this.steps = parent ? parent.steps.concat([name]) : [name];
      return _this;
    }

    Link.prototype.setNode = function (node) {
      this.node = node;
      this.ino = node.ino;
    };

    Link.prototype.getNode = function () {
      return this.node;
    };

    Link.prototype.createChild = function (name, node) {
      if (node === void 0) {
        node = this.vol.createNode();
      }

      var link = new Link(this.vol, this, name);
      link.setNode(node);

      if (node.isDirectory()) ;

      this.setChild(name, link);
      return link;
    };

    Link.prototype.setChild = function (name, link) {
      if (link === void 0) {
        link = new Link(this.vol, this, name);
      }

      this.children[name] = link;
      link.parent = this;
      this.length++;
      this.emit(\\"child:add\\", link, this);
      return link;
    };

    Link.prototype.deleteChild = function (link) {
      delete this.children[link.getName()];
      this.length--;
      this.emit(\\"child:delete\\", link, this);
    };

    Link.prototype.getChild = function (name) {
      if (Object.hasOwnProperty.call(this.children, name)) {
        return this.children[name];
      }
    };

    Link.prototype.getPath = function () {
      return this.steps.join(exports$8.SEP);
    };

    Link.prototype.getName = function () {
      return this.steps[this.steps.length - 1];
    }; // del() {
    //     const parent = this.parent;
    //     if(parent) {
    //         parent.deleteChild(link);
    //     }
    //     this.parent = null;
    //     this.vol = null;
    // }

    /**
     * Walk the tree path and return the \`Link\` at that location, if any.
     * @param steps {string[]} Desired location.
     * @param stop {number} Max steps to go into.
     * @param i {number} Current step in the \`steps\` array.
     *
     * @return {Link|null}
     */


    Link.prototype.walk = function (steps, stop, i) {
      if (stop === void 0) {
        stop = steps.length;
      }

      if (i === void 0) {
        i = 0;
      }

      if (i >= steps.length) return this;
      if (i >= stop) return this;
      var step = steps[i];
      var link = this.getChild(step);
      if (!link) return null;
      return link.walk(steps, stop, i + 1);
    };

    Link.prototype.toJSON = function () {
      return {
        steps: this.steps,
        ino: this.ino,
        children: Object.keys(this.children)
      };
    };

    return Link;
  }(events_1.EventEmitter);

  exports$8.Link = Link;
  /**
   * Represents an open file (file descriptor) that points to a \`Link\` (Hard-link) and a \`Node\`.
   */

  var File = function () {
    /**
     * Open a Link-Node pair. \`node\` is provided separately as that might be a different node
     * rather the one \`link\` points to, because it might be a symlink.
     * @param link
     * @param node
     * @param flags
     * @param fd
     */
    function File(link, node, flags, fd) {
      /**
       * A cursor/offset position in a file, where data will be written on write.
       * User can \\"seek\\" this position.
       */
      this.position = 0;
      this.link = link;
      this.node = node;
      this.flags = flags;
      this.fd = fd;
    }

    File.prototype.getString = function (encoding) {

      return this.node.getString();
    };

    File.prototype.setString = function (str) {
      this.node.setString(str);
    };

    File.prototype.getBuffer = function () {
      return this.node.getBuffer();
    };

    File.prototype.setBuffer = function (buf) {
      this.node.setBuffer(buf);
    };

    File.prototype.getSize = function () {
      return this.node.getSize();
    };

    File.prototype.truncate = function (len) {
      this.node.truncate(len);
    };

    File.prototype.seekTo = function (position) {
      this.position = position;
    };

    File.prototype.stats = function () {
      return Stats_1.default.build(this.node);
    };

    File.prototype.write = function (buf, offset, length, position) {
      if (offset === void 0) {
        offset = 0;
      }

      if (length === void 0) {
        length = buf.length;
      }

      if (typeof position !== \\"number\\") position = this.position;
      if (this.flags & O_APPEND) position = this.getSize();
      var bytes = this.node.write(buf, offset, length, position);
      this.position = position + bytes;
      return bytes;
    };

    File.prototype.read = function (buf, offset, length, position) {
      if (offset === void 0) {
        offset = 0;
      }

      if (length === void 0) {
        length = buf.byteLength;
      }

      if (typeof position !== \\"number\\") position = this.position;
      var bytes = this.node.read(buf, offset, length, position);
      this.position = position + bytes;
      return bytes;
    };

    File.prototype.chmod = function (perm) {
      this.node.chmod(perm);
    };

    File.prototype.chown = function (uid, gid) {
      this.node.chown(uid, gid);
    };

    return File;
  }();

  exports$8.File = File;
  return exports$8;
}

var exports$7 = {},
    _dewExec$5 = false;

var _global$1 = typeof globalThis !== \\"undefined\\" ? globalThis : typeof self !== \\"undefined\\" ? self : global;

function dew$5() {
  if (_dewExec$5) return exports$7;
  _dewExec$5 = true;
  Object.defineProperty(exports$7, \\"__esModule\\", {
    value: true
  });
  /**
   * \`setTimeoutUnref\` is just like \`setTimeout\`,
   * only in Node's environment it will \\"unref\\" its macro task.
   */

  function setTimeoutUnref(callback, time, args) {
    var ref = setTimeout.apply(typeof globalThis !== \\"undefined\\" ? globalThis : _global$1, arguments);
    if (ref && typeof ref === \\"object\\" && typeof ref.unref === \\"function\\") ref.unref();
    return ref;
  }

  exports$7.default = setTimeoutUnref;
  return exports$7;
}

var exports$6 = {},
    _dewExec$4 = false;
function dew$4() {
  if (_dewExec$4) return exports$6;
  _dewExec$4 = true;

  var __spreadArray = exports$6 && exports$6.__spreadArray || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };

  Object.defineProperty(exports$6, \\"__esModule\\", {
    value: true
  });
  exports$6.FileHandle = void 0;

  function promisify(vol, fn, getResult) {
    if (getResult === void 0) {
      getResult = function (input) {
        return input;
      };
    }

    return function () {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      return new Promise(function (resolve, reject) {
        vol[fn].bind(vol).apply(void 0, __spreadArray(__spreadArray([], args, false), [function (error, result) {
          if (error) return reject(error);
          return resolve(getResult(result));
        }], false));
      });
    };
  }

  var FileHandle = function () {
    function FileHandle(vol, fd) {
      this.vol = vol;
      this.fd = fd;
    }

    FileHandle.prototype.appendFile = function (data, options) {
      return promisify(this.vol, \\"appendFile\\")(this.fd, data, options);
    };

    FileHandle.prototype.chmod = function (mode) {
      return promisify(this.vol, \\"fchmod\\")(this.fd, mode);
    };

    FileHandle.prototype.chown = function (uid, gid) {
      return promisify(this.vol, \\"fchown\\")(this.fd, uid, gid);
    };

    FileHandle.prototype.close = function () {
      return promisify(this.vol, \\"close\\")(this.fd);
    };

    FileHandle.prototype.datasync = function () {
      return promisify(this.vol, \\"fdatasync\\")(this.fd);
    };

    FileHandle.prototype.read = function (buffer, offset, length, position) {
      return promisify(this.vol, \\"read\\", function (bytesRead) {
        return {
          bytesRead: bytesRead,
          buffer: buffer
        };
      })(this.fd, buffer, offset, length, position);
    };

    FileHandle.prototype.readFile = function (options) {
      return promisify(this.vol, \\"readFile\\")(this.fd, options);
    };

    FileHandle.prototype.stat = function (options) {
      return promisify(this.vol, \\"fstat\\")(this.fd, options);
    };

    FileHandle.prototype.sync = function () {
      return promisify(this.vol, \\"fsync\\")(this.fd);
    };

    FileHandle.prototype.truncate = function (len) {
      return promisify(this.vol, \\"ftruncate\\")(this.fd, len);
    };

    FileHandle.prototype.utimes = function (atime, mtime) {
      return promisify(this.vol, \\"futimes\\")(this.fd, atime, mtime);
    };

    FileHandle.prototype.write = function (buffer, offset, length, position) {
      return promisify(this.vol, \\"write\\", function (bytesWritten) {
        return {
          bytesWritten: bytesWritten,
          buffer: buffer
        };
      })(this.fd, buffer, offset, length, position);
    };

    FileHandle.prototype.writeFile = function (data, options) {
      return promisify(this.vol, \\"writeFile\\")(this.fd, data, options);
    };

    return FileHandle;
  }();

  exports$6.FileHandle = FileHandle;

  function createPromisesApi(vol) {
    if (typeof Promise === \\"undefined\\") return null;
    return {
      FileHandle: FileHandle,
      access: function (path, mode) {
        return promisify(vol, \\"access\\")(path, mode);
      },
      appendFile: function (path, data, options) {
        return promisify(vol, \\"appendFile\\")(path instanceof FileHandle ? path.fd : path, data, options);
      },
      chmod: function (path, mode) {
        return promisify(vol, \\"chmod\\")(path, mode);
      },
      chown: function (path, uid, gid) {
        return promisify(vol, \\"chown\\")(path, uid, gid);
      },
      copyFile: function (src, dest, flags) {
        return promisify(vol, \\"copyFile\\")(src, dest, flags);
      },
      lchmod: function (path, mode) {
        return promisify(vol, \\"lchmod\\")(path, mode);
      },
      lchown: function (path, uid, gid) {
        return promisify(vol, \\"lchown\\")(path, uid, gid);
      },
      link: function (existingPath, newPath) {
        return promisify(vol, \\"link\\")(existingPath, newPath);
      },
      lstat: function (path, options) {
        return promisify(vol, \\"lstat\\")(path, options);
      },
      mkdir: function (path, options) {
        return promisify(vol, \\"mkdir\\")(path, options);
      },
      mkdtemp: function (prefix, options) {
        return promisify(vol, \\"mkdtemp\\")(prefix, options);
      },
      open: function (path, flags, mode) {
        return promisify(vol, \\"open\\", function (fd) {
          return new FileHandle(vol, fd);
        })(path, flags, mode);
      },
      readdir: function (path, options) {
        return promisify(vol, \\"readdir\\")(path, options);
      },
      readFile: function (id, options) {
        return promisify(vol, \\"readFile\\")(id instanceof FileHandle ? id.fd : id, options);
      },
      readlink: function (path, options) {
        return promisify(vol, \\"readlink\\")(path, options);
      },
      realpath: function (path, options) {
        return promisify(vol, \\"realpath\\")(path, options);
      },
      rename: function (oldPath, newPath) {
        return promisify(vol, \\"rename\\")(oldPath, newPath);
      },
      rmdir: function (path) {
        return promisify(vol, \\"rmdir\\")(path);
      },
      stat: function (path, options) {
        return promisify(vol, \\"stat\\")(path, options);
      },
      symlink: function (target, path, type) {
        return promisify(vol, \\"symlink\\")(target, path, type);
      },
      truncate: function (path, len) {
        return promisify(vol, \\"truncate\\")(path, len);
      },
      unlink: function (path) {
        return promisify(vol, \\"unlink\\")(path);
      },
      utimes: function (path, atime, mtime) {
        return promisify(vol, \\"utimes\\")(path, atime, mtime);
      },
      writeFile: function (id, data, options) {
        return promisify(vol, \\"writeFile\\")(id instanceof FileHandle ? id.fd : id, data, options);
      }
    };
  }

  exports$6.default = createPromisesApi;
  return exports$6;
}

var exports$5 = {},
    _dewExec$3 = false;
function dew$3() {
  if (_dewExec$3) return exports$5;
  _dewExec$3 = true;
  var process$1 = process;
  Object.defineProperty(exports$5, \\"__esModule\\", {
    value: true
  });
  exports$5.unixify = unixify;
  exports$5.correctPath = correctPath;
  var isWin = process$1.platform === \\"win32\\";

  function removeTrailingSeparator(str) {
    var i = str.length - 1;

    if (i < 2) {
      return str;
    }

    while (isSeparator(str, i)) {
      i--;
    }

    return str.substr(0, i + 1);
  }

  function isSeparator(str, i) {
    var _char = str[i];
    return i > 0 && (_char === \\"/\\" || isWin && _char === \\"\\\\\\\\\\");
  }

  function normalizePath(str, stripTrailing) {
    if (typeof str !== \\"string\\") {
      throw new TypeError(\\"expected a string\\");
    }

    str = str.replace(/[\\\\\\\\\\\\/]+/g, \\"/\\");

    if (stripTrailing !== false) {
      str = removeTrailingSeparator(str);
    }

    return str;
  }

  function unixify(filepath) {
    var stripTrailing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    if (isWin) {
      filepath = normalizePath(filepath, stripTrailing);
      return filepath.replace(/^([a-zA-Z]+:|\\\\.\\\\/)/, \\"\\");
    }

    return filepath;
  }

  function correctPath(filepath) {
    return unixify(filepath.replace(/^\\\\\\\\\\\\\\\\\\\\?\\\\\\\\.:\\\\\\\\/, \\"\\\\\\\\\\"));
  }

  return exports$5;
}

var exports$4 = {},
    _dewExec$2 = false;

var _global = typeof globalThis !== \\"undefined\\" ? globalThis : typeof self !== \\"undefined\\" ? self : global;

function dew$2() {
  if (_dewExec$2) return exports$4;
  _dewExec$2 = true;

  var __extends = exports$4 && exports$4.__extends || function () {
    var extendStatics = function (d, b) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      };

      return extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== \\"function\\" && b !== null) throw new TypeError(\\"Class extends value \\" + String(b) + \\" is not a constructor or null\\");
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __spreadArray = exports$4 && exports$4.__spreadArray || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };

  Object.defineProperty(exports$4, \\"__esModule\\", {
    value: true
  });
  exports$4.FSWatcher = exports$4.StatWatcher = exports$4.Volume = exports$4.toUnixTimestamp = exports$4.bufferToEncoding = exports$4.dataToBuffer = exports$4.dataToStr = exports$4.pathToSteps = exports$4.filenameToSteps = exports$4.pathToFilename = exports$4.flagsToNumber = exports$4.FLAGS = void 0;
  var pathModule = exports$i;

  var node_1 = dew$6();

  var Stats_1 = dew$d();

  var Dirent_1 = dew$9();

  var buffer_1 = dew$c();

  var setImmediate_1 = dew$8();

  var process_1 = dew$7();

  var setTimeoutUnref_1 = dew$5();

  var stream_1 = exports$j;

  var constants_1 = dew$f();

  var events_1 = y;

  var encoding_1 = dew$a();

  var errors = dew$b();

  var util = X;

  var promises_1 = dew$4();

  var resolveCrossPlatform = pathModule.resolve;
  var O_RDONLY = constants_1.constants.O_RDONLY,
      O_WRONLY = constants_1.constants.O_WRONLY,
      O_RDWR = constants_1.constants.O_RDWR,
      O_CREAT = constants_1.constants.O_CREAT,
      O_EXCL = constants_1.constants.O_EXCL,
      O_TRUNC = constants_1.constants.O_TRUNC,
      O_APPEND = constants_1.constants.O_APPEND,
      O_SYNC = constants_1.constants.O_SYNC,
      O_DIRECTORY = constants_1.constants.O_DIRECTORY,
      F_OK = constants_1.constants.F_OK,
      COPYFILE_EXCL = constants_1.constants.COPYFILE_EXCL,
      COPYFILE_FICLONE_FORCE = constants_1.constants.COPYFILE_FICLONE_FORCE;

  var _a = pathModule.posix ? pathModule.posix : pathModule,
      sep = _a.sep,
      relative = _a.relative,
      join = _a.join,
      dirname = _a.dirname;

  var isWin = process_1.default.platform === \\"win32\\";
  var kMinPoolSpace = 128; // const kMaxLength = require('buffer').kMaxLength;
  // ---------------------------------------- Error messages
  // TODO: Use \`internal/errors.js\` in the future.

  var ERRSTR = {
    PATH_STR: \\"path must be a string or Buffer\\",
    // FD:             'file descriptor must be a unsigned 32-bit integer',
    FD: \\"fd must be a file descriptor\\",
    MODE_INT: \\"mode must be an int\\",
    CB: \\"callback must be a function\\",
    UID: \\"uid must be an unsigned int\\",
    GID: \\"gid must be an unsigned int\\",
    LEN: \\"len must be an integer\\",
    ATIME: \\"atime must be an integer\\",
    MTIME: \\"mtime must be an integer\\",
    PREFIX: \\"filename prefix is required\\",
    BUFFER: \\"buffer must be an instance of Buffer or StaticBuffer\\",
    OFFSET: \\"offset must be an integer\\",
    LENGTH: \\"length must be an integer\\",
    POSITION: \\"position must be an integer\\"
  };

  var ERRSTR_OPTS = function (tipeof) {
    return \\"Expected options to be either an object or a string, but got \\" + tipeof + \\" instead\\";
  }; // const ERRSTR_FLAG = flag => \`Unknown file open flag: \${flag}\`;


  var ENOENT = \\"ENOENT\\";
  var EBADF = \\"EBADF\\";
  var EINVAL = \\"EINVAL\\";
  var EPERM = \\"EPERM\\";
  var EPROTO = \\"EPROTO\\";
  var EEXIST = \\"EEXIST\\";
  var ENOTDIR = \\"ENOTDIR\\";
  var EMFILE = \\"EMFILE\\";
  var EACCES = \\"EACCES\\";
  var EISDIR = \\"EISDIR\\";
  var ENOTEMPTY = \\"ENOTEMPTY\\";
  var ENOSYS = \\"ENOSYS\\";

  function formatError(errorCode, func, path, path2) {
    if (func === void 0) {
      func = \\"\\";
    }

    if (path === void 0) {
      path = \\"\\";
    }

    if (path2 === void 0) {
      path2 = \\"\\";
    }

    var pathFormatted = \\"\\";
    if (path) pathFormatted = \\" '\\" + path + \\"'\\";
    if (path2) pathFormatted += \\" -> '\\" + path2 + \\"'\\";

    switch (errorCode) {
      case ENOENT:
        return \\"ENOENT: no such file or directory, \\" + func + pathFormatted;

      case EBADF:
        return \\"EBADF: bad file descriptor, \\" + func + pathFormatted;

      case EINVAL:
        return \\"EINVAL: invalid argument, \\" + func + pathFormatted;

      case EPERM:
        return \\"EPERM: operation not permitted, \\" + func + pathFormatted;

      case EPROTO:
        return \\"EPROTO: protocol error, \\" + func + pathFormatted;

      case EEXIST:
        return \\"EEXIST: file already exists, \\" + func + pathFormatted;

      case ENOTDIR:
        return \\"ENOTDIR: not a directory, \\" + func + pathFormatted;

      case EISDIR:
        return \\"EISDIR: illegal operation on a directory, \\" + func + pathFormatted;

      case EACCES:
        return \\"EACCES: permission denied, \\" + func + pathFormatted;

      case ENOTEMPTY:
        return \\"ENOTEMPTY: directory not empty, \\" + func + pathFormatted;

      case EMFILE:
        return \\"EMFILE: too many open files, \\" + func + pathFormatted;

      case ENOSYS:
        return \\"ENOSYS: function not implemented, \\" + func + pathFormatted;

      default:
        return errorCode + \\": error occurred, \\" + func + pathFormatted;
    }
  }

  function createError(errorCode, func, path, path2, Constructor) {
    if (func === void 0) {
      func = \\"\\";
    }

    if (path === void 0) {
      path = \\"\\";
    }

    if (path2 === void 0) {
      path2 = \\"\\";
    }

    if (Constructor === void 0) {
      Constructor = Error;
    }

    var error = new Constructor(formatError(errorCode, func, path, path2));
    error.code = errorCode;
    return error;
  } // ---------------------------------------- Flags
  // List of file \`flags\` as defined by Node.


  var FLAGS;

  (function (FLAGS) {
    // Open file for reading. An exception occurs if the file does not exist.
    FLAGS[FLAGS[\\"r\\"] = O_RDONLY] = \\"r\\"; // Open file for reading and writing. An exception occurs if the file does not exist.

    FLAGS[FLAGS[\\"r+\\"] = O_RDWR] = \\"r+\\"; // Open file for reading in synchronous mode. Instructs the operating system to bypass the local file system cache.

    FLAGS[FLAGS[\\"rs\\"] = O_RDONLY | O_SYNC] = \\"rs\\";
    FLAGS[FLAGS[\\"sr\\"] = FLAGS.rs] = \\"sr\\"; // Open file for reading and writing, telling the OS to open it synchronously. See notes for 'rs' about using this with caution.

    FLAGS[FLAGS[\\"rs+\\"] = O_RDWR | O_SYNC] = \\"rs+\\";
    FLAGS[FLAGS[\\"sr+\\"] = FLAGS[\\"rs+\\"]] = \\"sr+\\"; // Open file for writing. The file is created (if it does not exist) or truncated (if it exists).

    FLAGS[FLAGS[\\"w\\"] = O_WRONLY | O_CREAT | O_TRUNC] = \\"w\\"; // Like 'w' but fails if path exists.

    FLAGS[FLAGS[\\"wx\\"] = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL] = \\"wx\\";
    FLAGS[FLAGS[\\"xw\\"] = FLAGS.wx] = \\"xw\\"; // Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).

    FLAGS[FLAGS[\\"w+\\"] = O_RDWR | O_CREAT | O_TRUNC] = \\"w+\\"; // Like 'w+' but fails if path exists.

    FLAGS[FLAGS[\\"wx+\\"] = O_RDWR | O_CREAT | O_TRUNC | O_EXCL] = \\"wx+\\";
    FLAGS[FLAGS[\\"xw+\\"] = FLAGS[\\"wx+\\"]] = \\"xw+\\"; // Open file for appending. The file is created if it does not exist.

    FLAGS[FLAGS[\\"a\\"] = O_WRONLY | O_APPEND | O_CREAT] = \\"a\\"; // Like 'a' but fails if path exists.

    FLAGS[FLAGS[\\"ax\\"] = O_WRONLY | O_APPEND | O_CREAT | O_EXCL] = \\"ax\\";
    FLAGS[FLAGS[\\"xa\\"] = FLAGS.ax] = \\"xa\\"; // Open file for reading and appending. The file is created if it does not exist.

    FLAGS[FLAGS[\\"a+\\"] = O_RDWR | O_APPEND | O_CREAT] = \\"a+\\"; // Like 'a+' but fails if path exists.

    FLAGS[FLAGS[\\"ax+\\"] = O_RDWR | O_APPEND | O_CREAT | O_EXCL] = \\"ax+\\";
    FLAGS[FLAGS[\\"xa+\\"] = FLAGS[\\"ax+\\"]] = \\"xa+\\";
  })(FLAGS = exports$4.FLAGS || (exports$4.FLAGS = {}));

  function flagsToNumber(flags) {
    if (typeof flags === \\"number\\") return flags;

    if (typeof flags === \\"string\\") {
      var flagsNum = FLAGS[flags];
      if (typeof flagsNum !== \\"undefined\\") return flagsNum;
    } // throw new TypeError(formatError(ERRSTR_FLAG(flags)));


    throw new errors.TypeError(\\"ERR_INVALID_OPT_VALUE\\", \\"flags\\", flags);
  }

  exports$4.flagsToNumber = flagsToNumber; // ---------------------------------------- Options

  function getOptions(defaults, options) {
    var opts;
    if (!options) return defaults;else {
      var tipeof = typeof options;

      switch (tipeof) {
        case \\"string\\":
          opts = Object.assign({}, defaults, {
            encoding: options
          });
          break;

        case \\"object\\":
          opts = Object.assign({}, defaults, options);
          break;

        default:
          throw TypeError(ERRSTR_OPTS(tipeof));
      }
    }
    if (opts.encoding !== \\"buffer\\") (0, encoding_1.assertEncoding)(opts.encoding);
    return opts;
  }

  function optsGenerator(defaults) {
    return function (options) {
      return getOptions(defaults, options);
    };
  }

  function validateCallback(callback) {
    if (typeof callback !== \\"function\\") throw TypeError(ERRSTR.CB);
    return callback;
  }

  function optsAndCbGenerator(getOpts) {
    return function (options, callback) {
      return typeof options === \\"function\\" ? [getOpts(), options] : [getOpts(options), validateCallback(callback)];
    };
  }

  var optsDefaults = {
    encoding: \\"utf8\\"
  };
  var getDefaultOpts = optsGenerator(optsDefaults);
  var getDefaultOptsAndCb = optsAndCbGenerator(getDefaultOpts);
  var readFileOptsDefaults = {
    flag: \\"r\\"
  };
  var getReadFileOptions = optsGenerator(readFileOptsDefaults);
  var writeFileDefaults = {
    encoding: \\"utf8\\",
    mode: 438
    /* DEFAULT */
    ,
    flag: FLAGS[FLAGS.w]
  };
  var getWriteFileOptions = optsGenerator(writeFileDefaults);
  var appendFileDefaults = {
    encoding: \\"utf8\\",
    mode: 438
    /* DEFAULT */
    ,
    flag: FLAGS[FLAGS.a]
  };
  var getAppendFileOpts = optsGenerator(appendFileDefaults);
  var getAppendFileOptsAndCb = optsAndCbGenerator(getAppendFileOpts);
  var realpathDefaults = optsDefaults;
  var getRealpathOptions = optsGenerator(realpathDefaults);
  var getRealpathOptsAndCb = optsAndCbGenerator(getRealpathOptions);
  var mkdirDefaults = {
    mode: 511
    /* DIR */
    ,
    recursive: false
  };

  var getMkdirOptions = function (options) {
    if (typeof options === \\"number\\") return Object.assign({}, mkdirDefaults, {
      mode: options
    });
    return Object.assign({}, mkdirDefaults, options);
  };

  var rmdirDefaults = {
    recursive: false
  };

  var getRmdirOptions = function (options) {
    return Object.assign({}, rmdirDefaults, options);
  };

  var readdirDefaults = {
    encoding: \\"utf8\\",
    withFileTypes: false
  };
  var getReaddirOptions = optsGenerator(readdirDefaults);
  var getReaddirOptsAndCb = optsAndCbGenerator(getReaddirOptions);
  var statDefaults = {
    bigint: false
  };

  var getStatOptions = function (options) {
    if (options === void 0) {
      options = {};
    }

    return Object.assign({}, statDefaults, options);
  };

  var getStatOptsAndCb = function (options, callback) {
    return typeof options === \\"function\\" ? [getStatOptions(), options] : [getStatOptions(options), validateCallback(callback)];
  }; // ---------------------------------------- Utility functions


  function getPathFromURLPosix(url) {
    if (url.hostname !== \\"\\") {
      throw new errors.TypeError(\\"ERR_INVALID_FILE_URL_HOST\\", process_1.default.platform);
    }

    var pathname = url.pathname;

    for (var n = 0; n < pathname.length; n++) {
      if (pathname[n] === \\"%\\") {
        var third = pathname.codePointAt(n + 2) | 32;

        if (pathname[n + 1] === \\"2\\" && third === 102) {
          throw new errors.TypeError(\\"ERR_INVALID_FILE_URL_PATH\\", \\"must not include encoded / characters\\");
        }
      }
    }

    return decodeURIComponent(pathname);
  }

  function pathToFilename(path) {
    if (typeof path !== \\"string\\" && !buffer_1.Buffer.isBuffer(path)) {
      try {
        if (!(path instanceof h.URL)) throw new TypeError(ERRSTR.PATH_STR);
      } catch (err) {
        throw new TypeError(ERRSTR.PATH_STR);
      }

      path = getPathFromURLPosix(path);
    }

    var pathString = String(path);
    nullCheck(pathString); // return slash(pathString);

    return pathString;
  }

  exports$4.pathToFilename = pathToFilename;

  var resolve = function (filename, base) {
    if (base === void 0) {
      base = process_1.default.cwd();
    }

    return resolveCrossPlatform(base, filename);
  };

  if (isWin) {
    var _resolve_1 = resolve;

    var unixify_1 = dew$3().unixify;

    resolve = function (filename, base) {
      return unixify_1(_resolve_1(filename, base));
    };
  }

  function filenameToSteps(filename, base) {
    var fullPath = resolve(filename, base);
    var fullPathSansSlash = fullPath.substr(1);
    if (!fullPathSansSlash) return [];
    return fullPathSansSlash.split(sep);
  }

  exports$4.filenameToSteps = filenameToSteps;

  function pathToSteps(path) {
    return filenameToSteps(pathToFilename(path));
  }

  exports$4.pathToSteps = pathToSteps;

  function dataToStr(data, encoding) {
    if (encoding === void 0) {
      encoding = encoding_1.ENCODING_UTF8;
    }

    if (buffer_1.Buffer.isBuffer(data)) return data.toString(encoding);else if (data instanceof Uint8Array) return (0, buffer_1.bufferFrom)(data).toString(encoding);else return String(data);
  }

  exports$4.dataToStr = dataToStr;

  function dataToBuffer(data, encoding) {
    if (encoding === void 0) {
      encoding = encoding_1.ENCODING_UTF8;
    }

    if (buffer_1.Buffer.isBuffer(data)) return data;else if (data instanceof Uint8Array) return (0, buffer_1.bufferFrom)(data);else return (0, buffer_1.bufferFrom)(String(data), encoding);
  }

  exports$4.dataToBuffer = dataToBuffer;

  function bufferToEncoding(buffer, encoding) {
    if (!encoding || encoding === \\"buffer\\") return buffer;else return buffer.toString(encoding);
  }

  exports$4.bufferToEncoding = bufferToEncoding;

  function nullCheck(path, callback) {
    if ((\\"\\" + path).indexOf(\\"\\\\0\\") !== -1) {
      var er = new Error(\\"Path must be a string without null bytes\\");
      er.code = ENOENT;
      if (typeof callback !== \\"function\\") throw er;
      process_1.default.nextTick(callback, er);
      return false;
    }

    return true;
  }

  function _modeToNumber(mode, def) {
    if (typeof mode === \\"number\\") return mode;
    if (typeof mode === \\"string\\") return parseInt(mode, 8);
    if (def) return modeToNumber(def);
    return undefined;
  }

  function modeToNumber(mode, def) {
    var result = _modeToNumber(mode, def);

    if (typeof result !== \\"number\\" || isNaN(result)) throw new TypeError(ERRSTR.MODE_INT);
    return result;
  }

  function isFd(path) {
    return path >>> 0 === path;
  }

  function validateFd(fd) {
    if (!isFd(fd)) throw TypeError(ERRSTR.FD);
  } // converts Date or number to a fractional UNIX timestamp


  function toUnixTimestamp(time) {
    // tslint:disable-next-line triple-equals
    if (typeof time === \\"string\\" && +time == time) {
      return +time;
    }

    if (time instanceof Date) {
      return time.getTime() / 1000;
    }

    if (isFinite(time)) {
      if (time < 0) {
        return Date.now() / 1000;
      }

      return time;
    }

    throw new Error(\\"Cannot parse time: \\" + time);
  }

  exports$4.toUnixTimestamp = toUnixTimestamp;

  function validateUid(uid) {
    if (typeof uid !== \\"number\\") throw TypeError(ERRSTR.UID);
  }

  function validateGid(gid) {
    if (typeof gid !== \\"number\\") throw TypeError(ERRSTR.GID);
  }

  function flattenJSON(nestedJSON) {
    var flatJSON = {};

    function flatten(pathPrefix, node) {
      for (var path in node) {
        var contentOrNode = node[path];
        var joinedPath = join(pathPrefix, path);

        if (typeof contentOrNode === \\"string\\") {
          flatJSON[joinedPath] = contentOrNode;
        } else if (typeof contentOrNode === \\"object\\" && contentOrNode !== null && Object.keys(contentOrNode).length > 0) {
          // empty directories need an explicit entry and therefore get handled in \`else\`, non-empty ones are implicitly considered
          flatten(joinedPath, contentOrNode);
        } else {
          // without this branch null, empty-object or non-object entries would not be handled in the same way
          // by both fromJSON() and fromNestedJSON()
          flatJSON[joinedPath] = null;
        }
      }
    }

    flatten(\\"\\", nestedJSON);
    return flatJSON;
  }
  /**
   * \`Volume\` represents a file system.
   */


  var Volume = function () {
    function Volume(props) {
      if (props === void 0) {
        props = {};
      } // I-node number counter.


      this.ino = 0; // A mapping for i-node numbers to i-nodes (\`Node\`);

      this.inodes = {}; // List of released i-node numbers, for reuse.

      this.releasedInos = []; // A mapping for file descriptors to \`File\`s.

      this.fds = {}; // A list of reusable (opened and closed) file descriptors, that should be
      // used first before creating a new file descriptor.

      this.releasedFds = []; // Max number of open files.

      this.maxFiles = 10000; // Current number of open files.

      this.openFiles = 0;
      this.promisesApi = (0, promises_1.default)(this);
      this.statWatchers = {};
      this.props = Object.assign({
        Node: node_1.Node,
        Link: node_1.Link,
        File: node_1.File
      }, props);
      var root = this.createLink();
      root.setNode(this.createNode(true));
      var self = this; // tslint:disable-line no-this-assignment

      this.StatWatcher = function (_super) {
        __extends(StatWatcher, _super);

        function StatWatcher() {
          return _super.call(this, self) || this;
        }

        return StatWatcher;
      }(StatWatcher);

      var _ReadStream = FsReadStream;

      this.ReadStream = function (_super) {
        __extends(class_1, _super);

        function class_1() {
          var args = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }

          return _super.apply(this, __spreadArray([self], args, false)) || this;
        }

        return class_1;
      }(_ReadStream);

      var _WriteStream = FsWriteStream;

      this.WriteStream = function (_super) {
        __extends(class_2, _super);

        function class_2() {
          var args = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }

          return _super.apply(this, __spreadArray([self], args, false)) || this;
        }

        return class_2;
      }(_WriteStream);

      this.FSWatcher = function (_super) {
        __extends(FSWatcher, _super);

        function FSWatcher() {
          return _super.call(this, self) || this;
        }

        return FSWatcher;
      }(FSWatcher); // root.setChild('.', root);
      // root.getNode().nlink++;
      // root.setChild('..', root);
      // root.getNode().nlink++;


      this.root = root;
    }

    Volume.fromJSON = function (json, cwd) {
      var vol = new Volume();
      vol.fromJSON(json, cwd);
      return vol;
    };

    Volume.fromNestedJSON = function (json, cwd) {
      var vol = new Volume();
      vol.fromNestedJSON(json, cwd);
      return vol;
    };

    Object.defineProperty(Volume.prototype, \\"promises\\", {
      get: function () {
        if (this.promisesApi === null) throw new Error(\\"Promise is not supported in this environment.\\");
        return this.promisesApi;
      },
      enumerable: false,
      configurable: true
    });

    Volume.prototype.createLink = function (parent, name, isDirectory, perm) {
      if (isDirectory === void 0) {
        isDirectory = false;
      }

      if (!parent) {
        return new this.props.Link(this, null, \\"\\");
      }

      if (!name) {
        throw new Error(\\"createLink: name cannot be empty\\");
      }

      return parent.createChild(name, this.createNode(isDirectory, perm));
    };

    Volume.prototype.deleteLink = function (link) {
      var parent = link.parent;

      if (parent) {
        parent.deleteChild(link);
        return true;
      }

      return false;
    };

    Volume.prototype.newInoNumber = function () {
      var releasedFd = this.releasedInos.pop();
      if (releasedFd) return releasedFd;else {
        this.ino = (this.ino + 1) % 4294967295;
        return this.ino;
      }
    };

    Volume.prototype.newFdNumber = function () {
      var releasedFd = this.releasedFds.pop();
      return typeof releasedFd === \\"number\\" ? releasedFd : Volume.fd--;
    };

    Volume.prototype.createNode = function (isDirectory, perm) {
      if (isDirectory === void 0) {
        isDirectory = false;
      }

      var node = new this.props.Node(this.newInoNumber(), perm);
      if (isDirectory) node.setIsDirectory();
      this.inodes[node.ino] = node;
      return node;
    };

    Volume.prototype.getNode = function (ino) {
      return this.inodes[ino];
    };

    Volume.prototype.deleteNode = function (node) {
      node.del();
      delete this.inodes[node.ino];
      this.releasedInos.push(node.ino);
    }; // Generates 6 character long random string, used by \`mkdtemp\`.


    Volume.prototype.genRndStr = function () {
      var str = (Math.random() + 1).toString(36).substr(2, 6);
      if (str.length === 6) return str;else return this.genRndStr();
    }; // Returns a \`Link\` (hard link) referenced by path \\"split\\" into steps.


    Volume.prototype.getLink = function (steps) {
      return this.root.walk(steps);
    }; // Just link \`getLink\`, but throws a correct user error, if link to found.


    Volume.prototype.getLinkOrThrow = function (filename, funcName) {
      var steps = filenameToSteps(filename);
      var link = this.getLink(steps);
      if (!link) throw createError(ENOENT, funcName, filename);
      return link;
    }; // Just like \`getLink\`, but also dereference/resolves symbolic links.


    Volume.prototype.getResolvedLink = function (filenameOrSteps) {
      var steps = typeof filenameOrSteps === \\"string\\" ? filenameToSteps(filenameOrSteps) : filenameOrSteps;
      var link = this.root;
      var i = 0;

      while (i < steps.length) {
        var step = steps[i];
        link = link.getChild(step);
        if (!link) return null;
        var node = link.getNode();

        if (node.isSymlink()) {
          steps = node.symlink.concat(steps.slice(i + 1));
          link = this.root;
          i = 0;
          continue;
        }

        i++;
      }

      return link;
    }; // Just like \`getLinkOrThrow\`, but also dereference/resolves symbolic links.


    Volume.prototype.getResolvedLinkOrThrow = function (filename, funcName) {
      var link = this.getResolvedLink(filename);
      if (!link) throw createError(ENOENT, funcName, filename);
      return link;
    };

    Volume.prototype.resolveSymlinks = function (link) {
      // let node: Node = link.getNode();
      // while(link && node.isSymlink()) {
      //     link = this.getLink(node.symlink);
      //     if(!link) return null;
      //     node = link.getNode();
      // }
      // return link;
      return this.getResolvedLink(link.steps.slice(1));
    }; // Just like \`getLinkOrThrow\`, but also verifies that the link is a directory.


    Volume.prototype.getLinkAsDirOrThrow = function (filename, funcName) {
      var link = this.getLinkOrThrow(filename, funcName);
      if (!link.getNode().isDirectory()) throw createError(ENOTDIR, funcName, filename);
      return link;
    }; // Get the immediate parent directory of the link.


    Volume.prototype.getLinkParent = function (steps) {
      return this.root.walk(steps, steps.length - 1);
    };

    Volume.prototype.getLinkParentAsDirOrThrow = function (filenameOrSteps, funcName) {
      var steps = filenameOrSteps instanceof Array ? filenameOrSteps : filenameToSteps(filenameOrSteps);
      var link = this.getLinkParent(steps);
      if (!link) throw createError(ENOENT, funcName, sep + steps.join(sep));
      if (!link.getNode().isDirectory()) throw createError(ENOTDIR, funcName, sep + steps.join(sep));
      return link;
    };

    Volume.prototype.getFileByFd = function (fd) {
      return this.fds[String(fd)];
    };

    Volume.prototype.getFileByFdOrThrow = function (fd, funcName) {
      if (!isFd(fd)) throw TypeError(ERRSTR.FD);
      var file = this.getFileByFd(fd);
      if (!file) throw createError(EBADF, funcName);
      return file;
    };

    Volume.prototype.getNodeByIdOrCreate = function (id, flags, perm) {
      if (typeof id === \\"number\\") {
        var file = this.getFileByFd(id);
        if (!file) throw Error(\\"File nto found\\");
        return file.node;
      } else {
        var steps = pathToSteps(id);
        var link = this.getLink(steps);
        if (link) return link.getNode(); // Try creating a node if not found.

        if (flags & O_CREAT) {
          var dirLink = this.getLinkParent(steps);

          if (dirLink) {
            var name_1 = steps[steps.length - 1];
            link = this.createLink(dirLink, name_1, false, perm);
            return link.getNode();
          }
        }

        throw createError(ENOENT, \\"getNodeByIdOrCreate\\", pathToFilename(id));
      }
    };

    Volume.prototype.wrapAsync = function (method, args, callback) {
      var _this = this;

      validateCallback(callback);
      (0, setImmediate_1.default)(function () {
        var result;

        try {
          result = method.apply(_this, args);
        } catch (err) {
          callback(err);
          return;
        }

        callback(null, result);
      });
    };

    Volume.prototype._toJSON = function (link, json, path) {
      var _a;

      if (link === void 0) {
        link = this.root;
      }

      if (json === void 0) {
        json = {};
      }

      var isEmpty = true;
      var children = link.children;

      if (link.getNode().isFile()) {
        children = (_a = {}, _a[link.getName()] = link.parent.getChild(link.getName()), _a);
        link = link.parent;
      }

      for (var name_2 in children) {
        isEmpty = false;
        var child = link.getChild(name_2);

        if (!child) {
          throw new Error(\\"_toJSON: unexpected undefined\\");
        }

        var node = child.getNode();

        if (node.isFile()) {
          var filename = child.getPath();
          if (path) filename = relative(path, filename);
          json[filename] = node.getString();
        } else if (node.isDirectory()) {
          this._toJSON(child, json, path);
        }
      }

      var dirPath = link.getPath();
      if (path) dirPath = relative(path, dirPath);

      if (dirPath && isEmpty) {
        json[dirPath] = null;
      }

      return json;
    };

    Volume.prototype.toJSON = function (paths, json, isRelative) {
      if (json === void 0) {
        json = {};
      }

      if (isRelative === void 0) {
        isRelative = false;
      }

      var links = [];

      if (paths) {
        if (!(paths instanceof Array)) paths = [paths];

        for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
          var path = paths_1[_i];
          var filename = pathToFilename(path);
          var link = this.getResolvedLink(filename);
          if (!link) continue;
          links.push(link);
        }
      } else {
        links.push(this.root);
      }

      if (!links.length) return json;

      for (var _a = 0, links_1 = links; _a < links_1.length; _a++) {
        var link = links_1[_a];

        this._toJSON(link, json, isRelative ? link.getPath() : \\"\\");
      }

      return json;
    };

    Volume.prototype.fromJSON = function (json, cwd) {
      if (cwd === void 0) {
        cwd = process_1.default.cwd();
      }

      for (var filename in json) {
        var data = json[filename];
        filename = resolve(filename, cwd);

        if (typeof data === \\"string\\") {
          var dir = dirname(filename);
          this.mkdirpBase(dir, 511
          /* DIR */
          );
          this.writeFileSync(filename, data);
        } else {
          this.mkdirpBase(filename, 511
          /* DIR */
          );
        }
      }
    };

    Volume.prototype.fromNestedJSON = function (json, cwd) {
      this.fromJSON(flattenJSON(json), cwd);
    };

    Volume.prototype.reset = function () {
      this.ino = 0;
      this.inodes = {};
      this.releasedInos = [];
      this.fds = {};
      this.releasedFds = [];
      this.openFiles = 0;
      this.root = this.createLink();
      this.root.setNode(this.createNode(true));
    }; // Legacy interface


    Volume.prototype.mountSync = function (mountpoint, json) {
      this.fromJSON(json, mountpoint);
    };

    Volume.prototype.openLink = function (link, flagsNum, resolveSymlinks) {
      if (resolveSymlinks === void 0) {
        resolveSymlinks = true;
      }

      if (this.openFiles >= this.maxFiles) {
        // Too many open files.
        throw createError(EMFILE, \\"open\\", link.getPath());
      } // Resolve symlinks.


      var realLink = link;
      if (resolveSymlinks) realLink = this.resolveSymlinks(link);
      if (!realLink) throw createError(ENOENT, \\"open\\", link.getPath());
      var node = realLink.getNode(); // Check whether node is a directory

      if (node.isDirectory()) {
        if ((flagsNum & (O_RDONLY | O_RDWR | O_WRONLY)) !== O_RDONLY) throw createError(EISDIR, \\"open\\", link.getPath());
      } else {
        if (flagsNum & O_DIRECTORY) throw createError(ENOTDIR, \\"open\\", link.getPath());
      } // Check node permissions


      if (!(flagsNum & O_WRONLY)) {
        if (!node.canRead()) {
          throw createError(EACCES, \\"open\\", link.getPath());
        }
      }

      var file = new this.props.File(link, node, flagsNum, this.newFdNumber());
      this.fds[file.fd] = file;
      this.openFiles++;
      if (flagsNum & O_TRUNC) file.truncate();
      return file;
    };

    Volume.prototype.openFile = function (filename, flagsNum, modeNum, resolveSymlinks) {
      if (resolveSymlinks === void 0) {
        resolveSymlinks = true;
      }

      var steps = filenameToSteps(filename);
      var link = resolveSymlinks ? this.getResolvedLink(steps) : this.getLink(steps); // Try creating a new file, if it does not exist.

      if (!link && flagsNum & O_CREAT) {
        // const dirLink: Link = this.getLinkParent(steps);
        var dirLink = this.getResolvedLink(steps.slice(0, steps.length - 1)); // if(!dirLink) throw createError(ENOENT, 'open', filename);

        if (!dirLink) throw createError(ENOENT, \\"open\\", sep + steps.join(sep));

        if (flagsNum & O_CREAT && typeof modeNum === \\"number\\") {
          link = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);
        }
      }

      if (link) return this.openLink(link, flagsNum, resolveSymlinks);
      throw createError(ENOENT, \\"open\\", filename);
    };

    Volume.prototype.openBase = function (filename, flagsNum, modeNum, resolveSymlinks) {
      if (resolveSymlinks === void 0) {
        resolveSymlinks = true;
      }

      var file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);
      if (!file) throw createError(ENOENT, \\"open\\", filename);
      return file.fd;
    };

    Volume.prototype.openSync = function (path, flags, mode) {
      if (mode === void 0) {
        mode = 438
        /* DEFAULT */
        ;
      } // Validate (1) mode; (2) path; (3) flags - in that order.


      var modeNum = modeToNumber(mode);
      var fileName = pathToFilename(path);
      var flagsNum = flagsToNumber(flags);
      return this.openBase(fileName, flagsNum, modeNum);
    };

    Volume.prototype.open = function (path, flags, a, b) {
      var mode = a;
      var callback = b;

      if (typeof a === \\"function\\") {
        mode = 438
        /* DEFAULT */
        ;
        callback = a;
      }

      mode = mode || 438
      /* DEFAULT */
      ;
      var modeNum = modeToNumber(mode);
      var fileName = pathToFilename(path);
      var flagsNum = flagsToNumber(flags);
      this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum], callback);
    };

    Volume.prototype.closeFile = function (file) {
      if (!this.fds[file.fd]) return;
      this.openFiles--;
      delete this.fds[file.fd];
      this.releasedFds.push(file.fd);
    };

    Volume.prototype.closeSync = function (fd) {
      validateFd(fd);
      var file = this.getFileByFdOrThrow(fd, \\"close\\");
      this.closeFile(file);
    };

    Volume.prototype.close = function (fd, callback) {
      validateFd(fd);
      this.wrapAsync(this.closeSync, [fd], callback);
    };

    Volume.prototype.openFileOrGetById = function (id, flagsNum, modeNum) {
      if (typeof id === \\"number\\") {
        var file = this.fds[id];
        if (!file) throw createError(ENOENT);
        return file;
      } else {
        return this.openFile(pathToFilename(id), flagsNum, modeNum);
      }
    };

    Volume.prototype.readBase = function (fd, buffer, offset, length, position) {
      var file = this.getFileByFdOrThrow(fd);
      return file.read(buffer, Number(offset), Number(length), position);
    };

    Volume.prototype.readSync = function (fd, buffer, offset, length, position) {
      validateFd(fd);
      return this.readBase(fd, buffer, offset, length, position);
    };

    Volume.prototype.read = function (fd, buffer, offset, length, position, callback) {
      var _this = this;

      validateCallback(callback); // This \`if\` branch is from Node.js

      if (length === 0) {
        return process_1.default.nextTick(function () {
          if (callback) callback(null, 0, buffer);
        });
      }

      (0, setImmediate_1.default)(function () {
        try {
          var bytes = _this.readBase(fd, buffer, offset, length, position);

          callback(null, bytes, buffer);
        } catch (err) {
          callback(err);
        }
      });
    };

    Volume.prototype.readFileBase = function (id, flagsNum, encoding) {
      var result;
      var isUserFd = typeof id === \\"number\\";
      var userOwnsFd = isUserFd && isFd(id);
      var fd;
      if (userOwnsFd) fd = id;else {
        var filename = pathToFilename(id);
        var steps = filenameToSteps(filename);
        var link = this.getResolvedLink(steps);

        if (link) {
          var node = link.getNode();
          if (node.isDirectory()) throw createError(EISDIR, \\"open\\", link.getPath());
        }

        fd = this.openSync(id, flagsNum);
      }

      try {
        result = bufferToEncoding(this.getFileByFdOrThrow(fd).getBuffer(), encoding);
      } finally {
        if (!userOwnsFd) {
          this.closeSync(fd);
        }
      }

      return result;
    };

    Volume.prototype.readFileSync = function (file, options) {
      var opts = getReadFileOptions(options);
      var flagsNum = flagsToNumber(opts.flag);
      return this.readFileBase(file, flagsNum, opts.encoding);
    };

    Volume.prototype.readFile = function (id, a, b) {
      var _a = optsAndCbGenerator(getReadFileOptions)(a, b),
          opts = _a[0],
          callback = _a[1];

      var flagsNum = flagsToNumber(opts.flag);
      this.wrapAsync(this.readFileBase, [id, flagsNum, opts.encoding], callback);
    };

    Volume.prototype.writeBase = function (fd, buf, offset, length, position) {
      var file = this.getFileByFdOrThrow(fd, \\"write\\");
      return file.write(buf, offset, length, position);
    };

    Volume.prototype.writeSync = function (fd, a, b, c, d) {
      validateFd(fd);
      var encoding;
      var offset;
      var length;
      var position;
      var isBuffer = typeof a !== \\"string\\";

      if (isBuffer) {
        offset = (b || 0) | 0;
        length = c;
        position = d;
      } else {
        position = b;
        encoding = c;
      }

      var buf = dataToBuffer(a, encoding);

      if (isBuffer) {
        if (typeof length === \\"undefined\\") {
          length = buf.length;
        }
      } else {
        offset = 0;
        length = buf.length;
      }

      return this.writeBase(fd, buf, offset, length, position);
    };

    Volume.prototype.write = function (fd, a, b, c, d, e) {
      var _this = this;

      validateFd(fd);
      var offset;
      var length;
      var position;
      var encoding;
      var callback;
      var tipa = typeof a;
      var tipb = typeof b;
      var tipc = typeof c;
      var tipd = typeof d;

      if (tipa !== \\"string\\") {
        if (tipb === \\"function\\") {
          callback = b;
        } else if (tipc === \\"function\\") {
          offset = b | 0;
          callback = c;
        } else if (tipd === \\"function\\") {
          offset = b | 0;
          length = c;
          callback = d;
        } else {
          offset = b | 0;
          length = c;
          position = d;
          callback = e;
        }
      } else {
        if (tipb === \\"function\\") {
          callback = b;
        } else if (tipc === \\"function\\") {
          position = b;
          callback = c;
        } else if (tipd === \\"function\\") {
          position = b;
          encoding = c;
          callback = d;
        }
      }

      var buf = dataToBuffer(a, encoding);

      if (tipa !== \\"string\\") {
        if (typeof length === \\"undefined\\") length = buf.length;
      } else {
        offset = 0;
        length = buf.length;
      }

      var cb = validateCallback(callback);
      (0, setImmediate_1.default)(function () {
        try {
          var bytes = _this.writeBase(fd, buf, offset, length, position);

          if (tipa !== \\"string\\") {
            cb(null, bytes, buf);
          } else {
            cb(null, bytes, a);
          }
        } catch (err) {
          cb(err);
        }
      });
    };

    Volume.prototype.writeFileBase = function (id, buf, flagsNum, modeNum) {
      // console.log('writeFileBase', id, buf, flagsNum, modeNum);
      // const node = this.getNodeByIdOrCreate(id, flagsNum, modeNum);
      // node.setBuffer(buf);
      var isUserFd = typeof id === \\"number\\";
      var fd;
      if (isUserFd) fd = id;else {
        fd = this.openBase(pathToFilename(id), flagsNum, modeNum); // fd = this.openSync(id as PathLike, flagsNum, modeNum);
      }
      var offset = 0;
      var length = buf.length;
      var position = flagsNum & O_APPEND ? undefined : 0;

      try {
        while (length > 0) {
          var written = this.writeSync(fd, buf, offset, length, position);
          offset += written;
          length -= written;
          if (position !== undefined) position += written;
        }
      } finally {
        if (!isUserFd) this.closeSync(fd);
      }
    };

    Volume.prototype.writeFileSync = function (id, data, options) {
      var opts = getWriteFileOptions(options);
      var flagsNum = flagsToNumber(opts.flag);
      var modeNum = modeToNumber(opts.mode);
      var buf = dataToBuffer(data, opts.encoding);
      this.writeFileBase(id, buf, flagsNum, modeNum);
    };

    Volume.prototype.writeFile = function (id, data, a, b) {
      var options = a;
      var callback = b;

      if (typeof a === \\"function\\") {
        options = writeFileDefaults;
        callback = a;
      }

      var cb = validateCallback(callback);
      var opts = getWriteFileOptions(options);
      var flagsNum = flagsToNumber(opts.flag);
      var modeNum = modeToNumber(opts.mode);
      var buf = dataToBuffer(data, opts.encoding);
      this.wrapAsync(this.writeFileBase, [id, buf, flagsNum, modeNum], cb);
    };

    Volume.prototype.linkBase = function (filename1, filename2) {
      var steps1 = filenameToSteps(filename1);
      var link1 = this.getLink(steps1);
      if (!link1) throw createError(ENOENT, \\"link\\", filename1, filename2);
      var steps2 = filenameToSteps(filename2); // Check new link directory exists.

      var dir2 = this.getLinkParent(steps2);
      if (!dir2) throw createError(ENOENT, \\"link\\", filename1, filename2);
      var name = steps2[steps2.length - 1]; // Check if new file already exists.

      if (dir2.getChild(name)) throw createError(EEXIST, \\"link\\", filename1, filename2);
      var node = link1.getNode();
      node.nlink++;
      dir2.createChild(name, node);
    };

    Volume.prototype.copyFileBase = function (src, dest, flags) {
      var buf = this.readFileSync(src);

      if (flags & COPYFILE_EXCL) {
        if (this.existsSync(dest)) {
          throw createError(EEXIST, \\"copyFile\\", src, dest);
        }
      }

      if (flags & COPYFILE_FICLONE_FORCE) {
        throw createError(ENOSYS, \\"copyFile\\", src, dest);
      }

      this.writeFileBase(dest, buf, FLAGS.w, 438
      /* DEFAULT */
      );
    };

    Volume.prototype.copyFileSync = function (src, dest, flags) {
      var srcFilename = pathToFilename(src);
      var destFilename = pathToFilename(dest);
      return this.copyFileBase(srcFilename, destFilename, (flags || 0) | 0);
    };

    Volume.prototype.copyFile = function (src, dest, a, b) {
      var srcFilename = pathToFilename(src);
      var destFilename = pathToFilename(dest);
      var flags;
      var callback;

      if (typeof a === \\"function\\") {
        flags = 0;
        callback = a;
      } else {
        flags = a;
        callback = b;
      }

      validateCallback(callback);
      this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);
    };

    Volume.prototype.linkSync = function (existingPath, newPath) {
      var existingPathFilename = pathToFilename(existingPath);
      var newPathFilename = pathToFilename(newPath);
      this.linkBase(existingPathFilename, newPathFilename);
    };

    Volume.prototype.link = function (existingPath, newPath, callback) {
      var existingPathFilename = pathToFilename(existingPath);
      var newPathFilename = pathToFilename(newPath);
      this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);
    };

    Volume.prototype.unlinkBase = function (filename) {
      var steps = filenameToSteps(filename);
      var link = this.getLink(steps);
      if (!link) throw createError(ENOENT, \\"unlink\\", filename); // TODO: Check if it is file, dir, other...

      if (link.length) throw Error(\\"Dir not empty...\\");
      this.deleteLink(link);
      var node = link.getNode();
      node.nlink--; // When all hard links to i-node are deleted, remove the i-node, too.

      if (node.nlink <= 0) {
        this.deleteNode(node);
      }
    };

    Volume.prototype.unlinkSync = function (path) {
      var filename = pathToFilename(path);
      this.unlinkBase(filename);
    };

    Volume.prototype.unlink = function (path, callback) {
      var filename = pathToFilename(path);
      this.wrapAsync(this.unlinkBase, [filename], callback);
    };

    Volume.prototype.symlinkBase = function (targetFilename, pathFilename) {
      var pathSteps = filenameToSteps(pathFilename); // Check if directory exists, where we about to create a symlink.

      var dirLink = this.getLinkParent(pathSteps);
      if (!dirLink) throw createError(ENOENT, \\"symlink\\", targetFilename, pathFilename);
      var name = pathSteps[pathSteps.length - 1]; // Check if new file already exists.

      if (dirLink.getChild(name)) throw createError(EEXIST, \\"symlink\\", targetFilename, pathFilename); // Create symlink.

      var symlink = dirLink.createChild(name);
      symlink.getNode().makeSymlink(filenameToSteps(targetFilename));
      return symlink;
    }; // \`type\` argument works only on Windows.


    Volume.prototype.symlinkSync = function (target, path, type) {
      var targetFilename = pathToFilename(target);
      var pathFilename = pathToFilename(path);
      this.symlinkBase(targetFilename, pathFilename);
    };

    Volume.prototype.symlink = function (target, path, a, b) {
      var callback = validateCallback(typeof a === \\"function\\" ? a : b);
      var targetFilename = pathToFilename(target);
      var pathFilename = pathToFilename(path);
      this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);
    };

    Volume.prototype.realpathBase = function (filename, encoding) {
      var steps = filenameToSteps(filename);
      var realLink = this.getResolvedLink(steps);
      if (!realLink) throw createError(ENOENT, \\"realpath\\", filename);
      return (0, encoding_1.strToEncoding)(realLink.getPath(), encoding);
    };

    Volume.prototype.realpathSync = function (path, options) {
      return this.realpathBase(pathToFilename(path), getRealpathOptions(options).encoding);
    };

    Volume.prototype.realpath = function (path, a, b) {
      var _a = getRealpathOptsAndCb(a, b),
          opts = _a[0],
          callback = _a[1];

      var pathFilename = pathToFilename(path);
      this.wrapAsync(this.realpathBase, [pathFilename, opts.encoding], callback);
    };

    Volume.prototype.lstatBase = function (filename, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }

      var link = this.getLink(filenameToSteps(filename));
      if (!link) throw createError(ENOENT, \\"lstat\\", filename);
      return Stats_1.default.build(link.getNode(), bigint);
    };

    Volume.prototype.lstatSync = function (path, options) {
      return this.lstatBase(pathToFilename(path), getStatOptions(options).bigint);
    };

    Volume.prototype.lstat = function (path, a, b) {
      var _a = getStatOptsAndCb(a, b),
          opts = _a[0],
          callback = _a[1];

      this.wrapAsync(this.lstatBase, [pathToFilename(path), opts.bigint], callback);
    };

    Volume.prototype.statBase = function (filename, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }

      var link = this.getResolvedLink(filenameToSteps(filename));
      if (!link) throw createError(ENOENT, \\"stat\\", filename);
      return Stats_1.default.build(link.getNode(), bigint);
    };

    Volume.prototype.statSync = function (path, options) {
      return this.statBase(pathToFilename(path), getStatOptions(options).bigint);
    };

    Volume.prototype.stat = function (path, a, b) {
      var _a = getStatOptsAndCb(a, b),
          opts = _a[0],
          callback = _a[1];

      this.wrapAsync(this.statBase, [pathToFilename(path), opts.bigint], callback);
    };

    Volume.prototype.fstatBase = function (fd, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }

      var file = this.getFileByFd(fd);
      if (!file) throw createError(EBADF, \\"fstat\\");
      return Stats_1.default.build(file.node, bigint);
    };

    Volume.prototype.fstatSync = function (fd, options) {
      return this.fstatBase(fd, getStatOptions(options).bigint);
    };

    Volume.prototype.fstat = function (fd, a, b) {
      var _a = getStatOptsAndCb(a, b),
          opts = _a[0],
          callback = _a[1];

      this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);
    };

    Volume.prototype.renameBase = function (oldPathFilename, newPathFilename) {
      var link = this.getLink(filenameToSteps(oldPathFilename));
      if (!link) throw createError(ENOENT, \\"rename\\", oldPathFilename, newPathFilename); // TODO: Check if it is directory, if non-empty, we cannot move it, right?

      var newPathSteps = filenameToSteps(newPathFilename); // Check directory exists for the new location.

      var newPathDirLink = this.getLinkParent(newPathSteps);
      if (!newPathDirLink) throw createError(ENOENT, \\"rename\\", oldPathFilename, newPathFilename); // TODO: Also treat cases with directories and symbolic links.
      // TODO: See: http://man7.org/linux/man-pages/man2/rename.2.html
      // Remove hard link from old folder.

      var oldLinkParent = link.parent;

      if (oldLinkParent) {
        oldLinkParent.deleteChild(link);
      } // Rename should overwrite the new path, if that exists.


      var name = newPathSteps[newPathSteps.length - 1];
      link.steps = __spreadArray(__spreadArray([], newPathDirLink.steps, true), [name], false);
      newPathDirLink.setChild(link.getName(), link);
    };

    Volume.prototype.renameSync = function (oldPath, newPath) {
      var oldPathFilename = pathToFilename(oldPath);
      var newPathFilename = pathToFilename(newPath);
      this.renameBase(oldPathFilename, newPathFilename);
    };

    Volume.prototype.rename = function (oldPath, newPath, callback) {
      var oldPathFilename = pathToFilename(oldPath);
      var newPathFilename = pathToFilename(newPath);
      this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);
    };

    Volume.prototype.existsBase = function (filename) {
      return !!this.statBase(filename);
    };

    Volume.prototype.existsSync = function (path) {
      try {
        return this.existsBase(pathToFilename(path));
      } catch (err) {
        return false;
      }
    };

    Volume.prototype.exists = function (path, callback) {
      var _this = this;

      var filename = pathToFilename(path);
      if (typeof callback !== \\"function\\") throw Error(ERRSTR.CB);
      (0, setImmediate_1.default)(function () {
        try {
          callback(_this.existsBase(filename));
        } catch (err) {
          callback(false);
        }
      });
    };

    Volume.prototype.accessBase = function (filename, mode) {
      this.getLinkOrThrow(filename, \\"access\\"); // TODO: Verify permissions
    };

    Volume.prototype.accessSync = function (path, mode) {
      if (mode === void 0) {
        mode = F_OK;
      }

      var filename = pathToFilename(path);
      mode = mode | 0;
      this.accessBase(filename, mode);
    };

    Volume.prototype.access = function (path, a, b) {
      var mode = F_OK;
      var callback;

      if (typeof a !== \\"function\\") {
        mode = a | 0; // cast to number

        callback = validateCallback(b);
      } else {
        callback = a;
      }

      var filename = pathToFilename(path);
      this.wrapAsync(this.accessBase, [filename, mode], callback);
    };

    Volume.prototype.appendFileSync = function (id, data, options) {
      if (options === void 0) {
        options = appendFileDefaults;
      }

      var opts = getAppendFileOpts(options); // force append behavior when using a supplied file descriptor

      if (!opts.flag || isFd(id)) opts.flag = \\"a\\";
      this.writeFileSync(id, data, opts);
    };

    Volume.prototype.appendFile = function (id, data, a, b) {
      var _a = getAppendFileOptsAndCb(a, b),
          opts = _a[0],
          callback = _a[1]; // force append behavior when using a supplied file descriptor


      if (!opts.flag || isFd(id)) opts.flag = \\"a\\";
      this.writeFile(id, data, opts, callback);
    };

    Volume.prototype.readdirBase = function (filename, options) {
      var steps = filenameToSteps(filename);
      var link = this.getResolvedLink(steps);
      if (!link) throw createError(ENOENT, \\"readdir\\", filename);
      var node = link.getNode();
      if (!node.isDirectory()) throw createError(ENOTDIR, \\"scandir\\", filename);

      if (options.withFileTypes) {
        var list_1 = [];

        for (var name_3 in link.children) {
          var child = link.getChild(name_3);

          if (!child) {
            continue;
          }

          list_1.push(Dirent_1.default.build(child, options.encoding));
        }

        if (!isWin && options.encoding !== \\"buffer\\") list_1.sort(function (a, b) {
          if (a.name < b.name) return -1;
          if (a.name > b.name) return 1;
          return 0;
        });
        return list_1;
      }

      var list = [];

      for (var name_4 in link.children) {
        list.push((0, encoding_1.strToEncoding)(name_4, options.encoding));
      }

      if (!isWin && options.encoding !== \\"buffer\\") list.sort();
      return list;
    };

    Volume.prototype.readdirSync = function (path, options) {
      var opts = getReaddirOptions(options);
      var filename = pathToFilename(path);
      return this.readdirBase(filename, opts);
    };

    Volume.prototype.readdir = function (path, a, b) {
      var _a = getReaddirOptsAndCb(a, b),
          options = _a[0],
          callback = _a[1];

      var filename = pathToFilename(path);
      this.wrapAsync(this.readdirBase, [filename, options], callback);
    };

    Volume.prototype.readlinkBase = function (filename, encoding) {
      var link = this.getLinkOrThrow(filename, \\"readlink\\");
      var node = link.getNode();
      if (!node.isSymlink()) throw createError(EINVAL, \\"readlink\\", filename);
      var str = sep + node.symlink.join(sep);
      return (0, encoding_1.strToEncoding)(str, encoding);
    };

    Volume.prototype.readlinkSync = function (path, options) {
      var opts = getDefaultOpts(options);
      var filename = pathToFilename(path);
      return this.readlinkBase(filename, opts.encoding);
    };

    Volume.prototype.readlink = function (path, a, b) {
      var _a = getDefaultOptsAndCb(a, b),
          opts = _a[0],
          callback = _a[1];

      var filename = pathToFilename(path);
      this.wrapAsync(this.readlinkBase, [filename, opts.encoding], callback);
    };

    Volume.prototype.fsyncBase = function (fd) {
      this.getFileByFdOrThrow(fd, \\"fsync\\");
    };

    Volume.prototype.fsyncSync = function (fd) {
      this.fsyncBase(fd);
    };

    Volume.prototype.fsync = function (fd, callback) {
      this.wrapAsync(this.fsyncBase, [fd], callback);
    };

    Volume.prototype.fdatasyncBase = function (fd) {
      this.getFileByFdOrThrow(fd, \\"fdatasync\\");
    };

    Volume.prototype.fdatasyncSync = function (fd) {
      this.fdatasyncBase(fd);
    };

    Volume.prototype.fdatasync = function (fd, callback) {
      this.wrapAsync(this.fdatasyncBase, [fd], callback);
    };

    Volume.prototype.ftruncateBase = function (fd, len) {
      var file = this.getFileByFdOrThrow(fd, \\"ftruncate\\");
      file.truncate(len);
    };

    Volume.prototype.ftruncateSync = function (fd, len) {
      this.ftruncateBase(fd, len);
    };

    Volume.prototype.ftruncate = function (fd, a, b) {
      var len = typeof a === \\"number\\" ? a : 0;
      var callback = validateCallback(typeof a === \\"number\\" ? b : a);
      this.wrapAsync(this.ftruncateBase, [fd, len], callback);
    };

    Volume.prototype.truncateBase = function (path, len) {
      var fd = this.openSync(path, \\"r+\\");

      try {
        this.ftruncateSync(fd, len);
      } finally {
        this.closeSync(fd);
      }
    };

    Volume.prototype.truncateSync = function (id, len) {
      if (isFd(id)) return this.ftruncateSync(id, len);
      this.truncateBase(id, len);
    };

    Volume.prototype.truncate = function (id, a, b) {
      var len = typeof a === \\"number\\" ? a : 0;
      var callback = validateCallback(typeof a === \\"number\\" ? b : a);
      if (isFd(id)) return this.ftruncate(id, len, callback);
      this.wrapAsync(this.truncateBase, [id, len], callback);
    };

    Volume.prototype.futimesBase = function (fd, atime, mtime) {
      var file = this.getFileByFdOrThrow(fd, \\"futimes\\");
      var node = file.node;
      node.atime = new Date(atime * 1000);
      node.mtime = new Date(mtime * 1000);
    };

    Volume.prototype.futimesSync = function (fd, atime, mtime) {
      this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));
    };

    Volume.prototype.futimes = function (fd, atime, mtime, callback) {
      this.wrapAsync(this.futimesBase, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
    };

    Volume.prototype.utimesBase = function (filename, atime, mtime) {
      var fd = this.openSync(filename, \\"r+\\");

      try {
        this.futimesBase(fd, atime, mtime);
      } finally {
        this.closeSync(fd);
      }
    };

    Volume.prototype.utimesSync = function (path, atime, mtime) {
      this.utimesBase(pathToFilename(path), toUnixTimestamp(atime), toUnixTimestamp(mtime));
    };

    Volume.prototype.utimes = function (path, atime, mtime, callback) {
      this.wrapAsync(this.utimesBase, [pathToFilename(path), toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
    };

    Volume.prototype.mkdirBase = function (filename, modeNum) {
      var steps = filenameToSteps(filename); // This will throw if user tries to create root dir \`fs.mkdirSync('/')\`.

      if (!steps.length) {
        throw createError(EEXIST, \\"mkdir\\", filename);
      }

      var dir = this.getLinkParentAsDirOrThrow(filename, \\"mkdir\\"); // Check path already exists.

      var name = steps[steps.length - 1];
      if (dir.getChild(name)) throw createError(EEXIST, \\"mkdir\\", filename);
      dir.createChild(name, this.createNode(true, modeNum));
    };
    /**
     * Creates directory tree recursively.
     * @param filename
     * @param modeNum
     */


    Volume.prototype.mkdirpBase = function (filename, modeNum) {
      var steps = filenameToSteps(filename);
      var link = this.root;

      for (var i = 0; i < steps.length; i++) {
        var step = steps[i];
        if (!link.getNode().isDirectory()) throw createError(ENOTDIR, \\"mkdir\\", link.getPath());
        var child = link.getChild(step);

        if (child) {
          if (child.getNode().isDirectory()) link = child;else throw createError(ENOTDIR, \\"mkdir\\", child.getPath());
        } else {
          link = link.createChild(step, this.createNode(true, modeNum));
        }
      }
    };

    Volume.prototype.mkdirSync = function (path, options) {
      var opts = getMkdirOptions(options);
      var modeNum = modeToNumber(opts.mode, 511);
      var filename = pathToFilename(path);
      if (opts.recursive) this.mkdirpBase(filename, modeNum);else this.mkdirBase(filename, modeNum);
    };

    Volume.prototype.mkdir = function (path, a, b) {
      var opts = getMkdirOptions(a);
      var callback = validateCallback(typeof a === \\"function\\" ? a : b);
      var modeNum = modeToNumber(opts.mode, 511);
      var filename = pathToFilename(path);
      if (opts.recursive) this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);else this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);
    }; // legacy interface


    Volume.prototype.mkdirpSync = function (path, mode) {
      this.mkdirSync(path, {
        mode: mode,
        recursive: true
      });
    };

    Volume.prototype.mkdirp = function (path, a, b) {
      var mode = typeof a === \\"function\\" ? undefined : a;
      var callback = validateCallback(typeof a === \\"function\\" ? a : b);
      this.mkdir(path, {
        mode: mode,
        recursive: true
      }, callback);
    };

    Volume.prototype.mkdtempBase = function (prefix, encoding, retry) {
      if (retry === void 0) {
        retry = 5;
      }

      var filename = prefix + this.genRndStr();

      try {
        this.mkdirBase(filename, 511
        /* DIR */
        );
        return (0, encoding_1.strToEncoding)(filename, encoding);
      } catch (err) {
        if (err.code === EEXIST) {
          if (retry > 1) return this.mkdtempBase(prefix, encoding, retry - 1);else throw Error(\\"Could not create temp dir.\\");
        } else throw err;
      }
    };

    Volume.prototype.mkdtempSync = function (prefix, options) {
      var encoding = getDefaultOpts(options).encoding;
      if (!prefix || typeof prefix !== \\"string\\") throw new TypeError(\\"filename prefix is required\\");
      nullCheck(prefix);
      return this.mkdtempBase(prefix, encoding);
    };

    Volume.prototype.mkdtemp = function (prefix, a, b) {
      var _a = getDefaultOptsAndCb(a, b),
          encoding = _a[0].encoding,
          callback = _a[1];

      if (!prefix || typeof prefix !== \\"string\\") throw new TypeError(\\"filename prefix is required\\");
      if (!nullCheck(prefix)) return;
      this.wrapAsync(this.mkdtempBase, [prefix, encoding], callback);
    };

    Volume.prototype.rmdirBase = function (filename, options) {
      var opts = getRmdirOptions(options);
      var link = this.getLinkAsDirOrThrow(filename, \\"rmdir\\"); // Check directory is empty.

      if (link.length && !opts.recursive) throw createError(ENOTEMPTY, \\"rmdir\\", filename);
      this.deleteLink(link);
    };

    Volume.prototype.rmdirSync = function (path, options) {
      this.rmdirBase(pathToFilename(path), options);
    };

    Volume.prototype.rmdir = function (path, a, b) {
      var opts = getRmdirOptions(a);
      var callback = validateCallback(typeof a === \\"function\\" ? a : b);
      this.wrapAsync(this.rmdirBase, [pathToFilename(path), opts], callback);
    };

    Volume.prototype.fchmodBase = function (fd, modeNum) {
      var file = this.getFileByFdOrThrow(fd, \\"fchmod\\");
      file.chmod(modeNum);
    };

    Volume.prototype.fchmodSync = function (fd, mode) {
      this.fchmodBase(fd, modeToNumber(mode));
    };

    Volume.prototype.fchmod = function (fd, mode, callback) {
      this.wrapAsync(this.fchmodBase, [fd, modeToNumber(mode)], callback);
    };

    Volume.prototype.chmodBase = function (filename, modeNum) {
      var fd = this.openSync(filename, \\"r+\\");

      try {
        this.fchmodBase(fd, modeNum);
      } finally {
        this.closeSync(fd);
      }
    };

    Volume.prototype.chmodSync = function (path, mode) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path);
      this.chmodBase(filename, modeNum);
    };

    Volume.prototype.chmod = function (path, mode, callback) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path);
      this.wrapAsync(this.chmodBase, [filename, modeNum], callback);
    };

    Volume.prototype.lchmodBase = function (filename, modeNum) {
      var fd = this.openBase(filename, O_RDWR, 0, false);

      try {
        this.fchmodBase(fd, modeNum);
      } finally {
        this.closeSync(fd);
      }
    };

    Volume.prototype.lchmodSync = function (path, mode) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path);
      this.lchmodBase(filename, modeNum);
    };

    Volume.prototype.lchmod = function (path, mode, callback) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path);
      this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);
    };

    Volume.prototype.fchownBase = function (fd, uid, gid) {
      this.getFileByFdOrThrow(fd, \\"fchown\\").chown(uid, gid);
    };

    Volume.prototype.fchownSync = function (fd, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.fchownBase(fd, uid, gid);
    };

    Volume.prototype.fchown = function (fd, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);
    };

    Volume.prototype.chownBase = function (filename, uid, gid) {
      var link = this.getResolvedLinkOrThrow(filename, \\"chown\\");
      var node = link.getNode();
      node.chown(uid, gid); // if(node.isFile() || node.isSymlink()) {
      //
      // } else if(node.isDirectory()) {
      //
      // } else {
      // TODO: What do we do here?
      // }
    };

    Volume.prototype.chownSync = function (path, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.chownBase(pathToFilename(path), uid, gid);
    };

    Volume.prototype.chown = function (path, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.chownBase, [pathToFilename(path), uid, gid], callback);
    };

    Volume.prototype.lchownBase = function (filename, uid, gid) {
      this.getLinkOrThrow(filename, \\"lchown\\").getNode().chown(uid, gid);
    };

    Volume.prototype.lchownSync = function (path, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.lchownBase(pathToFilename(path), uid, gid);
    };

    Volume.prototype.lchown = function (path, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.lchownBase, [pathToFilename(path), uid, gid], callback);
    };

    Volume.prototype.watchFile = function (path, a, b) {
      var filename = pathToFilename(path);
      var options = a;
      var listener = b;

      if (typeof options === \\"function\\") {
        listener = a;
        options = null;
      }

      if (typeof listener !== \\"function\\") {
        throw Error(\\"\\\\\\"watchFile()\\\\\\" requires a listener function\\");
      }

      var interval = 5007;
      var persistent = true;

      if (options && typeof options === \\"object\\") {
        if (typeof options.interval === \\"number\\") interval = options.interval;
        if (typeof options.persistent === \\"boolean\\") persistent = options.persistent;
      }

      var watcher = this.statWatchers[filename];

      if (!watcher) {
        watcher = new this.StatWatcher();
        watcher.start(filename, persistent, interval);
        this.statWatchers[filename] = watcher;
      }

      watcher.addListener(\\"change\\", listener);
      return watcher;
    };

    Volume.prototype.unwatchFile = function (path, listener) {
      var filename = pathToFilename(path);
      var watcher = this.statWatchers[filename];
      if (!watcher) return;

      if (typeof listener === \\"function\\") {
        watcher.removeListener(\\"change\\", listener);
      } else {
        watcher.removeAllListeners(\\"change\\");
      }

      if (watcher.listenerCount(\\"change\\") === 0) {
        watcher.stop();
        delete this.statWatchers[filename];
      }
    };

    Volume.prototype.createReadStream = function (path, options) {
      return new this.ReadStream(path, options);
    };

    Volume.prototype.createWriteStream = function (path, options) {
      return new this.WriteStream(path, options);
    }; // watch(path: PathLike): FSWatcher;
    // watch(path: PathLike, options?: IWatchOptions | string): FSWatcher;


    Volume.prototype.watch = function (path, options, listener) {
      var filename = pathToFilename(path);
      var givenOptions = options;

      if (typeof options === \\"function\\") {
        listener = options;
        givenOptions = null;
      } // tslint:disable-next-line prefer-const


      var _a = getDefaultOpts(givenOptions),
          persistent = _a.persistent,
          recursive = _a.recursive,
          encoding = _a.encoding;

      if (persistent === undefined) persistent = true;
      if (recursive === undefined) recursive = false;
      var watcher = new this.FSWatcher();
      watcher.start(filename, persistent, recursive, encoding);

      if (listener) {
        watcher.addListener(\\"change\\", listener);
      }

      return watcher;
    };
    /**
     * Global file descriptor counter. UNIX file descriptors start from 0 and go sequentially
     * up, so here, in order not to conflict with them, we choose some big number and descrease
     * the file descriptor of every new opened file.
     * @type {number}
     * @todo This should not be static, right?
     */


    Volume.fd = 2147483647;
    return Volume;
  }();

  exports$4.Volume = Volume;

  function emitStop(self) {
    self.emit(\\"stop\\");
  }

  var StatWatcher = function (_super) {
    __extends(StatWatcher, _super);

    function StatWatcher(vol) {
      var _this = _super.call(this) || this;

      _this.onInterval = function () {
        try {
          var stats = _this.vol.statSync(_this.filename);

          if (_this.hasChanged(stats)) {
            _this.emit(\\"change\\", stats, _this.prev);

            _this.prev = stats;
          }
        } finally {
          _this.loop();
        }
      };

      _this.vol = vol;
      return _this;
    }

    StatWatcher.prototype.loop = function () {
      this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
    };

    StatWatcher.prototype.hasChanged = function (stats) {
      // if(!this.prev) return false;
      if (stats.mtimeMs > this.prev.mtimeMs) return true;
      if (stats.nlink !== this.prev.nlink) return true;
      return false;
    };

    StatWatcher.prototype.start = function (path, persistent, interval) {
      if (persistent === void 0) {
        persistent = true;
      }

      if (interval === void 0) {
        interval = 5007;
      }

      this.filename = pathToFilename(path);
      this.setTimeout = persistent ? setTimeout.bind(typeof globalThis !== \\"undefined\\" ? globalThis : _global) : setTimeoutUnref_1.default;
      this.interval = interval;
      this.prev = this.vol.statSync(this.filename);
      this.loop();
    };

    StatWatcher.prototype.stop = function () {
      clearTimeout(this.timeoutRef);
      process_1.default.nextTick(emitStop, this);
    };

    return StatWatcher;
  }(events_1.EventEmitter);

  exports$4.StatWatcher = StatWatcher;
  var pool;

  function allocNewPool(poolSize) {
    pool = (0, buffer_1.bufferAllocUnsafe)(poolSize);
    pool.used = 0;
  }

  util.inherits(FsReadStream, stream_1.Readable);
  exports$4.ReadStream = FsReadStream;

  function FsReadStream(vol, path, options) {
    if (!(this instanceof FsReadStream)) return new FsReadStream(vol, path, options);
    this._vol = vol; // a little bit bigger buffer and water marks by default

    options = Object.assign({}, getOptions(options, {}));
    if (options.highWaterMark === undefined) options.highWaterMark = 64 * 1024;
    stream_1.Readable.call(this, options);
    this.path = pathToFilename(path);
    this.fd = options.fd === undefined ? null : options.fd;
    this.flags = options.flags === undefined ? \\"r\\" : options.flags;
    this.mode = options.mode === undefined ? 438 : options.mode;
    this.start = options.start;
    this.end = options.end;
    this.autoClose = options.autoClose === undefined ? true : options.autoClose;
    this.pos = undefined;
    this.bytesRead = 0;

    if (this.start !== undefined) {
      if (typeof this.start !== \\"number\\") {
        throw new TypeError(\\"\\\\\\"start\\\\\\" option must be a Number\\");
      }

      if (this.end === undefined) {
        this.end = Infinity;
      } else if (typeof this.end !== \\"number\\") {
        throw new TypeError(\\"\\\\\\"end\\\\\\" option must be a Number\\");
      }

      if (this.start > this.end) {
        throw new Error(\\"\\\\\\"start\\\\\\" option must be <= \\\\\\"end\\\\\\" option\\");
      }

      this.pos = this.start;
    }

    if (typeof this.fd !== \\"number\\") this.open();
    this.on(\\"end\\", function () {
      if (this.autoClose) {
        if (this.destroy) this.destroy();
      }
    });
  }

  FsReadStream.prototype.open = function () {
    var self = this; // tslint:disable-line no-this-assignment

    this._vol.open(this.path, this.flags, this.mode, function (er, fd) {
      if (er) {
        if (self.autoClose) {
          if (self.destroy) self.destroy();
        }

        self.emit(\\"error\\", er);
        return;
      }

      self.fd = fd;
      self.emit(\\"open\\", fd); // start the flow of data.

      self.read();
    });
  };

  FsReadStream.prototype._read = function (n) {
    if (typeof this.fd !== \\"number\\") {
      return this.once(\\"open\\", function () {
        this._read(n);
      });
    }

    if (this.destroyed) return;

    if (!pool || pool.length - pool.used < kMinPoolSpace) {
      // discard the old pool.
      allocNewPool(this._readableState.highWaterMark);
    } // Grab another reference to the pool in the case that while we're
    // in the thread pool another read() finishes up the pool, and
    // allocates a new one.


    var thisPool = pool;
    var toRead = Math.min(pool.length - pool.used, n);
    var start = pool.used;
    if (this.pos !== undefined) toRead = Math.min(this.end - this.pos + 1, toRead); // already read everything we were supposed to read!
    // treat as EOF.

    if (toRead <= 0) return this.push(null); // the actual read.

    var self = this; // tslint:disable-line no-this-assignment

    this._vol.read(this.fd, pool, pool.used, toRead, this.pos, onread); // move the pool positions, and internal position for reading.


    if (this.pos !== undefined) this.pos += toRead;
    pool.used += toRead;

    function onread(er, bytesRead) {
      if (er) {
        if (self.autoClose && self.destroy) {
          self.destroy();
        }

        self.emit(\\"error\\", er);
      } else {
        var b = null;

        if (bytesRead > 0) {
          self.bytesRead += bytesRead;
          b = thisPool.slice(start, start + bytesRead);
        }

        self.push(b);
      }
    }
  };

  FsReadStream.prototype._destroy = function (err, cb) {
    this.close(function (err2) {
      cb(err || err2);
    });
  };

  FsReadStream.prototype.close = function (cb) {
    var _this = this;

    if (cb) this.once(\\"close\\", cb);

    if (this.closed || typeof this.fd !== \\"number\\") {
      if (typeof this.fd !== \\"number\\") {
        this.once(\\"open\\", closeOnOpen);
        return;
      }

      return process_1.default.nextTick(function () {
        return _this.emit(\\"close\\");
      });
    }

    this.closed = true;

    this._vol.close(this.fd, function (er) {
      if (er) _this.emit(\\"error\\", er);else _this.emit(\\"close\\");
    });

    this.fd = null;
  }; // needed because as it will be called with arguments
  // that does not match this.close() signature


  function closeOnOpen(fd) {
    this.close();
  }

  util.inherits(FsWriteStream, stream_1.Writable);
  exports$4.WriteStream = FsWriteStream;

  function FsWriteStream(vol, path, options) {
    if (!(this instanceof FsWriteStream)) return new FsWriteStream(vol, path, options);
    this._vol = vol;
    options = Object.assign({}, getOptions(options, {}));
    stream_1.Writable.call(this, options);
    this.path = pathToFilename(path);
    this.fd = options.fd === undefined ? null : options.fd;
    this.flags = options.flags === undefined ? \\"w\\" : options.flags;
    this.mode = options.mode === undefined ? 438 : options.mode;
    this.start = options.start;
    this.autoClose = options.autoClose === undefined ? true : !!options.autoClose;
    this.pos = undefined;
    this.bytesWritten = 0;

    if (this.start !== undefined) {
      if (typeof this.start !== \\"number\\") {
        throw new TypeError(\\"\\\\\\"start\\\\\\" option must be a Number\\");
      }

      if (this.start < 0) {
        throw new Error(\\"\\\\\\"start\\\\\\" must be >= zero\\");
      }

      this.pos = this.start;
    }

    if (options.encoding) this.setDefaultEncoding(options.encoding);
    if (typeof this.fd !== \\"number\\") this.open(); // dispose on finish.

    this.once(\\"finish\\", function () {
      if (this.autoClose) {
        this.close();
      }
    });
  }

  FsWriteStream.prototype.open = function () {
    this._vol.open(this.path, this.flags, this.mode, function (er, fd) {
      if (er) {
        if (this.autoClose && this.destroy) {
          this.destroy();
        }

        this.emit(\\"error\\", er);
        return;
      }

      this.fd = fd;
      this.emit(\\"open\\", fd);
    }.bind(this));
  };

  FsWriteStream.prototype._write = function (data, encoding, cb) {
    if (!(data instanceof buffer_1.Buffer)) return this.emit(\\"error\\", new Error(\\"Invalid data\\"));

    if (typeof this.fd !== \\"number\\") {
      return this.once(\\"open\\", function () {
        this._write(data, encoding, cb);
      });
    }

    var self = this; // tslint:disable-line no-this-assignment

    this._vol.write(this.fd, data, 0, data.length, this.pos, function (er, bytes) {
      if (er) {
        if (self.autoClose && self.destroy) {
          self.destroy();
        }

        return cb(er);
      }

      self.bytesWritten += bytes;
      cb();
    });

    if (this.pos !== undefined) this.pos += data.length;
  };

  FsWriteStream.prototype._writev = function (data, cb) {
    if (typeof this.fd !== \\"number\\") {
      return this.once(\\"open\\", function () {
        this._writev(data, cb);
      });
    }

    var self = this; // tslint:disable-line no-this-assignment

    var len = data.length;
    var chunks = new Array(len);
    var size = 0;

    for (var i = 0; i < len; i++) {
      var chunk = data[i].chunk;
      chunks[i] = chunk;
      size += chunk.length;
    }

    var buf = buffer_1.Buffer.concat(chunks);

    this._vol.write(this.fd, buf, 0, buf.length, this.pos, function (er, bytes) {
      if (er) {
        if (self.destroy) self.destroy();
        return cb(er);
      }

      self.bytesWritten += bytes;
      cb();
    });

    if (this.pos !== undefined) this.pos += size;
  };

  FsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;
  FsWriteStream.prototype.close = FsReadStream.prototype.close; // There is no shutdown() for files.

  FsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end; // ---------------------------------------- FSWatcher

  var FSWatcher = function (_super) {
    __extends(FSWatcher, _super);

    function FSWatcher(vol) {
      var _this = _super.call(this) || this;

      _this._filename = \\"\\";
      _this._filenameEncoded = \\"\\"; // _persistent: boolean = true;

      _this._recursive = false;
      _this._encoding = encoding_1.ENCODING_UTF8;

      _this._onNodeChange = function () {
        _this._emit(\\"change\\");
      };

      _this._onParentChild = function (link) {
        if (link.getName() === _this._getName()) {
          _this._emit(\\"rename\\");
        }
      };

      _this._emit = function (type) {
        _this.emit(\\"change\\", type, _this._filenameEncoded);
      };

      _this._persist = function () {
        _this._timer = setTimeout(_this._persist, 1000000);
      };

      _this._vol = vol;
      return _this; // TODO: Emit \\"error\\" messages when watching.
      // this._handle.onchange = function(status, eventType, filename) {
      //     if (status < 0) {
      //         self._handle.close();
      //         const error = !filename ?
      //             errnoException(status, 'Error watching file for changes:') :
      //             errnoException(status, \`Error watching file \${filename} for changes:\`);
      //         error.filename = filename;
      //         self.emit('error', error);
      //     } else {
      //         self.emit('change', eventType, filename);
      //     }
      // };
    }

    FSWatcher.prototype._getName = function () {
      return this._steps[this._steps.length - 1];
    };

    FSWatcher.prototype.start = function (path, persistent, recursive, encoding) {
      if (persistent === void 0) {
        persistent = true;
      }

      if (recursive === void 0) {
        recursive = false;
      }

      if (encoding === void 0) {
        encoding = encoding_1.ENCODING_UTF8;
      }

      this._filename = pathToFilename(path);
      this._steps = filenameToSteps(this._filename);
      this._filenameEncoded = (0, encoding_1.strToEncoding)(this._filename); // this._persistent = persistent;

      this._recursive = recursive;
      this._encoding = encoding;

      try {
        this._link = this._vol.getLinkOrThrow(this._filename, \\"FSWatcher\\");
      } catch (err) {
        var error = new Error(\\"watch \\" + this._filename + \\" \\" + err.code);
        error.code = err.code;
        error.errno = err.code;
        throw error;
      }

      this._link.getNode().on(\\"change\\", this._onNodeChange);

      this._link.on(\\"child:add\\", this._onNodeChange);

      this._link.on(\\"child:delete\\", this._onNodeChange);

      var parent = this._link.parent;

      if (parent) {
        // parent.on('child:add', this._onParentChild);
        parent.setMaxListeners(parent.getMaxListeners() + 1);
        parent.on(\\"child:delete\\", this._onParentChild);
      }

      if (persistent) this._persist();
    };

    FSWatcher.prototype.close = function () {
      clearTimeout(this._timer);

      this._link.getNode().removeListener(\\"change\\", this._onNodeChange);

      var parent = this._link.parent;

      if (parent) {
        // parent.removeListener('child:add', this._onParentChild);
        parent.removeListener(\\"child:delete\\", this._onParentChild);
      }
    };

    return FSWatcher;
  }(events_1.EventEmitter);

  exports$4.FSWatcher = FSWatcher;
  return exports$4;
}

var exports$3 = {},
    _dewExec$1 = false;
function dew$1() {
  if (_dewExec$1) return exports$3;
  _dewExec$1 = true;
  Object.defineProperty(exports$3, \\"__esModule\\", {
    value: true
  });
  exports$3.fsAsyncMethods = exports$3.fsSyncMethods = exports$3.fsProps = void 0;
  var fsProps = [\\"constants\\", \\"F_OK\\", \\"R_OK\\", \\"W_OK\\", \\"X_OK\\", \\"Stats\\"];
  exports$3.fsProps = fsProps;
  var fsSyncMethods = [\\"renameSync\\", \\"ftruncateSync\\", \\"truncateSync\\", \\"chownSync\\", \\"fchownSync\\", \\"lchownSync\\", \\"chmodSync\\", \\"fchmodSync\\", \\"lchmodSync\\", \\"statSync\\", \\"lstatSync\\", \\"fstatSync\\", \\"linkSync\\", \\"symlinkSync\\", \\"readlinkSync\\", \\"realpathSync\\", \\"unlinkSync\\", \\"rmdirSync\\", \\"mkdirSync\\", \\"mkdirpSync\\", \\"readdirSync\\", \\"closeSync\\", \\"openSync\\", \\"utimesSync\\", \\"futimesSync\\", \\"fsyncSync\\", \\"writeSync\\", \\"readSync\\", \\"readFileSync\\", \\"writeFileSync\\", \\"appendFileSync\\", \\"existsSync\\", \\"accessSync\\", \\"fdatasyncSync\\", \\"mkdtempSync\\", \\"copyFileSync\\", \\"createReadStream\\", \\"createWriteStream\\"];
  exports$3.fsSyncMethods = fsSyncMethods;
  var fsAsyncMethods = [\\"rename\\", \\"ftruncate\\", \\"truncate\\", \\"chown\\", \\"fchown\\", \\"lchown\\", \\"chmod\\", \\"fchmod\\", \\"lchmod\\", \\"stat\\", \\"lstat\\", \\"fstat\\", \\"link\\", \\"symlink\\", \\"readlink\\", \\"realpath\\", \\"unlink\\", \\"rmdir\\", \\"mkdir\\", \\"mkdirp\\", \\"readdir\\", \\"close\\", \\"open\\", \\"utimes\\", \\"futimes\\", \\"fsync\\", \\"write\\", \\"read\\", \\"readFile\\", \\"writeFile\\", \\"appendFile\\", \\"exists\\", \\"access\\", \\"fdatasync\\", \\"mkdtemp\\", \\"copyFile\\", \\"watchFile\\", \\"unwatchFile\\", \\"watch\\"];
  exports$3.fsAsyncMethods = fsAsyncMethods;
  return exports$3;
}

var exports$2 = {},
    _dewExec = false;
function dew() {
  if (_dewExec) return exports$2;
  _dewExec = true;

  var __assign = exports$2 && exports$2.__assign || function () {
    __assign = Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }

      return t;
    };

    return __assign.apply(this, arguments);
  };

  Object.defineProperty(exports$2, \\"__esModule\\", {
    value: true
  });
  exports$2.fs = exports$2.createFsFromVolume = exports$2.vol = exports$2.Volume = void 0;

  var Stats_1 = dew$d();

  var Dirent_1 = dew$9();

  var volume_1 = dew$2();

  var _a = dew$1(),
      fsSyncMethods = _a.fsSyncMethods,
      fsAsyncMethods = _a.fsAsyncMethods;

  var constants_1 = dew$f();

  var F_OK = constants_1.constants.F_OK,
      R_OK = constants_1.constants.R_OK,
      W_OK = constants_1.constants.W_OK,
      X_OK = constants_1.constants.X_OK;
  exports$2.Volume = volume_1.Volume; // Default volume.

  exports$2.vol = new volume_1.Volume();

  function createFsFromVolume(vol) {
    var fs = {
      F_OK: F_OK,
      R_OK: R_OK,
      W_OK: W_OK,
      X_OK: X_OK,
      constants: constants_1.constants,
      Stats: Stats_1.default,
      Dirent: Dirent_1.default
    }; // Bind FS methods.

    for (var _i = 0, fsSyncMethods_1 = fsSyncMethods; _i < fsSyncMethods_1.length; _i++) {
      var method = fsSyncMethods_1[_i];
      if (typeof vol[method] === \\"function\\") fs[method] = vol[method].bind(vol);
    }

    for (var _a = 0, fsAsyncMethods_1 = fsAsyncMethods; _a < fsAsyncMethods_1.length; _a++) {
      var method = fsAsyncMethods_1[_a];
      if (typeof vol[method] === \\"function\\") fs[method] = vol[method].bind(vol);
    }

    fs.StatWatcher = vol.StatWatcher;
    fs.FSWatcher = vol.FSWatcher;
    fs.WriteStream = vol.WriteStream;
    fs.ReadStream = vol.ReadStream;
    fs.promises = vol.promises;
    fs._toUnixTimestamp = volume_1.toUnixTimestamp;
    return fs;
  }

  exports$2.createFsFromVolume = createFsFromVolume;
  exports$2.fs = createFsFromVolume(exports$2.vol);
  exports$2 = __assign(__assign({}, exports$2), exports$2.fs);
  exports$2.semantic = true;
  return exports$2;
}

const exports$1 = dew();
exports$1['__esModule']; exports$1['fs']; exports$1['createFsFromVolume']; exports$1['vol']; exports$1['Volume']; exports$1['semantic'];

const exports = dew$2();
exports['__esModule']; exports['FSWatcher']; exports['StatWatcher']; exports['Volume']; exports['toUnixTimestamp']; exports['bufferToEncoding']; exports['dataToBuffer']; exports['dataToStr']; exports['pathToSteps']; exports['filenameToSteps']; exports['pathToFilename']; exports['flagsToNumber']; exports['FLAGS']; exports['ReadStream']; exports['WriteStream'];

const { vol, createFsFromVolume } = exports$1;

function unimplemented(name) {
  throw new Error(\`Node.js fs \${name} is not supported by JSPM core in the browser\`);
}

vol.fromNestedJSON({
  '/dev': { stdin: '', stdout: '', stderr: '' },
  '/usr/bin': {},
  '/home': {},
  '/tmp': {},
});

vol.releasedFds = [2, 1, 0];
vol.openSync('/dev/stdin', 'w');
vol.openSync('/dev/stdout', 'r');
vol.openSync('/dev/stderr', 'r');
watchStdo('/dev/stdout', 1, console.log);
watchStdo('/dev/stderr', 2, console.error);
function watchStdo(path, fd, listener) {
  let oldSize = 0;
  const decoder = new TextDecoder();
  vol.watch(path, 'utf8', () => {
    const { size } = vol.fstatSync(fd);
    const buf = Buffer.alloc(size - oldSize);
    vol.readSync(fd, buf, 0, buf.length, oldSize);
    oldSize = size;
    listener(decoder.decode(buf, { stream: true }));
  });
}

const fs = createFsFromVolume(vol);

fs.opendir = () => unimplemented('opendir');
fs.opendirSync = () => unimplemented('opendirSync');
fs.promises.opendir = () => unimplemented('promises.opendir');
fs.cp = () => unimplemented('cp');
fs.cpSync = () => unimplemented('cpSync');
fs.promises.cp = () => unimplemented('promises.cp');
fs.readv = () => unimplemented('readv');
fs.readvSync = () => unimplemented('readvSync');
fs.rm = () => unimplemented('rm');
fs.rmSync = () => unimplemented('rmSync');
fs.promises.rm = () => unimplemented('promises.rm');
fs.Dir = () => unimplemented('Dir');
fs.promises.watch = () => unimplemented('promises.watch');

fs.FileReadStream = fs.ReadStream;
fs.FileWriteStream = fs.WriteStream;

function handleFsUrl (url, isSync) {
  if (url.protocol === 'file:')
    return fileURLToPath(url);
  if (url.protocol === 'https:' || url.protocol === 'http:') {
    const path = '\\\\\\\\\\\\\\\\url\\\\\\\\' + url.href.replaceAll(/\\\\//g, '\\\\\\\\\\\\\\\\');
    if (existsSync(path))
      return path;
    if (isSync)
      throw new Error(\`Cannot sync request URL \${url} via FS. JSPM FS support for network URLs requires using async FS methods or priming the MemFS cache first with an async request before a sync request.\`);
    return (async () => {
      const res = await fetch(url);
      if (!res.ok)
        throw new Error(\`Unable to fetch \${url.href}, \${res.status}\`);
      const buf = await res.arrayBuffer();
      writeFileSync(path, Buffer.from(buf));
      return path;
    })();
  }
  throw new Error('URL ' + url + ' not supported in JSPM FS implementation.');
}

function wrapFsSync (fn) {
  return function (path, ...args) {
    if (path instanceof URL)
      return fn(handleFsUrl(path, true), ...args);
    return fn(path, ...args);
  };
}

function wrapFsPromise (fn) {
  return async function (path, ...args) {
    if (path instanceof URL)
      return fn(await handleFsUrl(path), ...args);
    return fn(path, ...args);
  };
}

function wrapFsCallback (fn) {
  return function (path, ...args) {
    const cb = args[args.length - 1];
    if (path instanceof URL && typeof cb === 'function') {
      handleFsUrl(path).then(path => {
        fn(path, ...args);
      }, cb);
    }
    else {
      fn(path, ...args);
    }
  }; 
}

fs.promises.readFile = wrapFsPromise(fs.promises.readFile);
fs.readFile = wrapFsCallback(fs.readFile);
fs.readFileSync = wrapFsSync(fs.readFileSync);

const {
  appendFile,
  appendFileSync,
  access,
  accessSync,
  chown,
  chownSync,
  chmod,
  chmodSync,
  close,
  closeSync,
  copyFile,
  copyFileSync,
  cp,
  cpSync,
  createReadStream,
  createWriteStream,
  exists,
  existsSync,
  fchown,
  fchownSync,
  fchmod,
  fchmodSync,
  fdatasync,
  fdatasyncSync,
  fstat,
  fstatSync,
  fsync,
  fsyncSync,
  ftruncate,
  ftruncateSync,
  futimes,
  futimesSync,
  lchown,
  lchownSync,
  lchmod,
  lchmodSync,
  link,
  linkSync,
  lstat,
  lstatSync,
  mkdir,
  mkdirSync,
  mkdtemp,
  mkdtempSync,
  open,
  openSync,
  opendir,
  opendirSync,
  readdir,
  readdirSync,
  read,
  readSync,
  readv,
  readvSync,
  readFile,
  readFileSync,
  readlink,
  readlinkSync,
  realpath,
  realpathSync,
  rename,
  renameSync,
  rm,
  rmSync,
  rmdir,
  rmdirSync,
  stat,
  statSync,
  symlink,
  symlinkSync,
  truncate,
  truncateSync,
  unwatchFile,
  unlink,
  unlinkSync,
  utimes,
  utimesSync,
  watch,
  watchFile,
  writeFile,
  writeFileSync,
  write,
  writeSync,
  writev,
  writevSync,
  Dir,
  Dirent,
  Stats,
  ReadStream,
  WriteStream,
  FileReadStream,
  FileWriteStream,
  _toUnixTimestamp,
  constants: { F_OK, R_OK, W_OK, X_OK },
  constants,
  promises,
} = fs;

export { Dir, Dirent, F_OK, FileReadStream, FileWriteStream, R_OK, ReadStream, Stats, W_OK, WriteStream, X_OK, _toUnixTimestamp, access, accessSync, appendFile, appendFileSync, chmod, chmodSync, chown, chownSync, close, closeSync, constants, copyFile, copyFileSync, cp, cpSync, createReadStream, createWriteStream, fs as default, exists, existsSync, fchmod, fchmodSync, fchown, fchownSync, fdatasync, fdatasyncSync, fstat, fstatSync, fsync, fsyncSync, ftruncate, ftruncateSync, futimes, futimesSync, lchmod, lchmodSync, lchown, lchownSync, link, linkSync, lstat, lstatSync, mkdir, mkdirSync, mkdtemp, mkdtempSync, open, openSync, opendir, opendirSync, promises, read, readFile, readFileSync, readSync, readdir, readdirSync, readlink, readlinkSync, readv, readvSync, realpath, realpathSync, rename, renameSync, rm, rmSync, rmdir, rmdirSync, stat, statSync, symlink, symlinkSync, truncate, truncateSync, unlink, unlinkSync, unwatchFile, utimes, utimesSync, watch, watchFile, write, writeFile, writeFileSync, writeSync, writev, writevSync };
"
`;

exports[`polyfillPath 2`] = `
"import { b as buffer } from './chunk-44e51b61.js';
import et from './assert.js';
import './util.js';
import { X } from './chunk-b4205b57.js';
import './path.js';
import { p as process } from './chunk-2eac56ff.js';
import './events.js';
import { y } from './chunk-4bd36a8f.js';
import './stream.js';
import h, { fileURLToPath } from './url.js';
import { e as exports$i } from './chunk-23dbec7b.js';
import { e as exports$j } from './chunk-6c718bbe.js';
import { Buffer } from './buffer.js';
import './chunk-ce0fbc82.js';
import './chunk-5decc758.js';
import './chunk-4ccc3a29.js';
import './chunk-924bb2e1.js';
import './chunk-b04e620d.js';

var exports$h = {},
    _dewExec$f = false;
function dew$f() {
  if (_dewExec$f) return exports$h;
  _dewExec$f = true;
  Object.defineProperty(exports$h, \\"__esModule\\", {
    value: true
  });
  exports$h.constants = void 0;
  exports$h.constants = {
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 64,
    O_EXCL: 128,
    O_NOCTTY: 256,
    O_TRUNC: 512,
    O_APPEND: 1024,
    O_DIRECTORY: 65536,
    O_NOATIME: 262144,
    O_NOFOLLOW: 131072,
    O_SYNC: 1052672,
    O_DIRECT: 16384,
    O_NONBLOCK: 2048,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    UV_FS_COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_EXCL: 1,
    COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE_FORCE: 4
  };
  return exports$h;
}

var exports$g = {},
    _dewExec$e = false;
function dew$e() {
  if (_dewExec$e) return exports$g;
  _dewExec$e = true;
  if (typeof BigInt === \\"function\\") exports$g.default = BigInt;else exports$g.default = function BigIntNotSupported() {
    throw new Error(\\"BigInt is not supported in this environment.\\");
  };
  return exports$g;
}

var exports$f = {},
    _dewExec$d = false;
function dew$d() {
  if (_dewExec$d) return exports$f;
  _dewExec$d = true;
  Object.defineProperty(exports$f, \\"__esModule\\", {
    value: true
  });
  exports$f.Stats = void 0;

  var constants_1 = dew$f();

  var getBigInt_1 = dew$e();

  var S_IFMT = constants_1.constants.S_IFMT,
      S_IFDIR = constants_1.constants.S_IFDIR,
      S_IFREG = constants_1.constants.S_IFREG,
      S_IFBLK = constants_1.constants.S_IFBLK,
      S_IFCHR = constants_1.constants.S_IFCHR,
      S_IFLNK = constants_1.constants.S_IFLNK,
      S_IFIFO = constants_1.constants.S_IFIFO,
      S_IFSOCK = constants_1.constants.S_IFSOCK;
  /**
   * Statistics about a file/directory, like \`fs.Stats\`.
   */

  var Stats = function () {
    function Stats() {}

    Stats.build = function (node, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }

      var stats = new Stats();
      var uid = node.uid,
          gid = node.gid,
          atime = node.atime,
          mtime = node.mtime,
          ctime = node.ctime;
      var getStatNumber = !bigint ? function (number) {
        return number;
      } : getBigInt_1.default; // Copy all values on Stats from Node, so that if Node values
      // change, values on Stats would still be the old ones,
      // just like in Node fs.

      stats.uid = getStatNumber(uid);
      stats.gid = getStatNumber(gid);
      stats.rdev = getStatNumber(0);
      stats.blksize = getStatNumber(4096);
      stats.ino = getStatNumber(node.ino);
      stats.size = getStatNumber(node.getSize());
      stats.blocks = getStatNumber(1);
      stats.atime = atime;
      stats.mtime = mtime;
      stats.ctime = ctime;
      stats.birthtime = ctime;
      stats.atimeMs = getStatNumber(atime.getTime());
      stats.mtimeMs = getStatNumber(mtime.getTime());
      var ctimeMs = getStatNumber(ctime.getTime());
      stats.ctimeMs = ctimeMs;
      stats.birthtimeMs = ctimeMs;
      stats.dev = getStatNumber(0);
      stats.mode = getStatNumber(node.mode);
      stats.nlink = getStatNumber(node.nlink);
      return stats;
    };

    Stats.prototype._checkModeProperty = function (property) {
      return (Number(this.mode) & S_IFMT) === property;
    };

    Stats.prototype.isDirectory = function () {
      return this._checkModeProperty(S_IFDIR);
    };

    Stats.prototype.isFile = function () {
      return this._checkModeProperty(S_IFREG);
    };

    Stats.prototype.isBlockDevice = function () {
      return this._checkModeProperty(S_IFBLK);
    };

    Stats.prototype.isCharacterDevice = function () {
      return this._checkModeProperty(S_IFCHR);
    };

    Stats.prototype.isSymbolicLink = function () {
      return this._checkModeProperty(S_IFLNK);
    };

    Stats.prototype.isFIFO = function () {
      return this._checkModeProperty(S_IFIFO);
    };

    Stats.prototype.isSocket = function () {
      return this._checkModeProperty(S_IFSOCK);
    };

    return Stats;
  }();

  exports$f.Stats = Stats;
  exports$f.default = Stats;
  return exports$f;
}

var exports$e = {},
    _dewExec$c = false;
function dew$c() {
  if (_dewExec$c) return exports$e;
  _dewExec$c = true;

  var __spreadArray = exports$e && exports$e.__spreadArray || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };

  Object.defineProperty(exports$e, \\"__esModule\\", {
    value: true
  });
  exports$e.bufferFrom = exports$e.bufferAllocUnsafe = exports$e.Buffer = void 0;
  var buffer_1 = buffer;
  Object.defineProperty(exports$e, \\"Buffer\\", {
    enumerable: true,
    get: function () {
      return buffer_1.Buffer;
    }
  });

  function bufferV0P12Ponyfill(arg0) {
    var args = [];

    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }

    return new (buffer_1.Buffer.bind.apply(buffer_1.Buffer, __spreadArray([void 0, arg0], args, false)))();
  }

  var bufferAllocUnsafe = buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;
  exports$e.bufferAllocUnsafe = bufferAllocUnsafe;
  var bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;
  exports$e.bufferFrom = bufferFrom;
  return exports$e;
}

var exports$d = {},
    _dewExec$b = false;

var _global$3 = typeof globalThis !== \\"undefined\\" ? globalThis : typeof self !== \\"undefined\\" ? self : global;

function dew$b() {
  if (_dewExec$b) return exports$d;
  _dewExec$b = true;

  // The whole point behind this internal module is to allow Node.js to no
  // longer be forced to treat every error message change as a semver-major
  // change. The NodeError classes here all expose a \`code\` property whose
  // value statically and permanently identifies the error. While the error
  // message may change, the code should not.
  var __extends = exports$d && exports$d.__extends || function () {
    var extendStatics = function (d, b) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      };

      return extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== \\"function\\" && b !== null) throw new TypeError(\\"Class extends value \\" + String(b) + \\" is not a constructor or null\\");
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(exports$d, \\"__esModule\\", {
    value: true
  });
  exports$d.E = exports$d.AssertionError = exports$d.message = exports$d.RangeError = exports$d.TypeError = exports$d.Error = void 0;
  var assert = et;
  var util = X;
  var kCode = typeof Symbol === \\"undefined\\" ? \\"_kCode\\" : Symbol(\\"code\\");
  var messages = {}; // new Map();

  function makeNodeError(Base) {
    return function (_super) {
      __extends(NodeError, _super);

      function NodeError(key) {
        var args = [];

        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }

        var _this = _super.call(this, message(key, args)) || this;

        _this.code = key;
        _this[kCode] = key;
        _this.name = _super.prototype.name + \\" [\\" + _this[kCode] + \\"]\\";
        return _this;
      }

      return NodeError;
    }(Base);
  }

  var g = typeof globalThis !== \\"undefined\\" ? globalThis : _global$3;

  var AssertionError = function (_super) {
    __extends(AssertionError, _super);

    function AssertionError(options) {
      var _this = this;

      if (typeof options !== \\"object\\" || options === null) {
        throw new exports$d.TypeError(\\"ERR_INVALID_ARG_TYPE\\", \\"options\\", \\"object\\");
      }

      if (options.message) {
        _this = _super.call(this, options.message) || this;
      } else {
        _this = _super.call(this, util.inspect(options.actual).slice(0, 128) + \\" \\" + (options.operator + \\" \\" + util.inspect(options.expected).slice(0, 128))) || this;
      }

      _this.generatedMessage = !options.message;
      _this.name = \\"AssertionError [ERR_ASSERTION]\\";
      _this.code = \\"ERR_ASSERTION\\";
      _this.actual = options.actual;
      _this.expected = options.expected;
      _this.operator = options.operator;
      exports$d.Error.captureStackTrace(_this, options.stackStartFunction);
      return _this;
    }

    return AssertionError;
  }(g.Error);

  exports$d.AssertionError = AssertionError;

  function message(key, args) {
    assert.strictEqual(typeof key, \\"string\\"); // const msg = messages.get(key);

    var msg = messages[key];
    assert(msg, \\"An invalid error message key was used: \\" + key + \\".\\");
    var fmt;

    if (typeof msg === \\"function\\") {
      fmt = msg;
    } else {
      fmt = util.format;
      if (args === undefined || args.length === 0) return msg;
      args.unshift(msg);
    }

    return String(fmt.apply(null, args));
  }

  exports$d.message = message; // Utility function for registering the error codes. Only used here. Exported
  // *only* to allow for testing.

  function E(sym, val) {
    messages[sym] = typeof val === \\"function\\" ? val : String(val);
  }

  exports$d.E = E;
  exports$d.Error = makeNodeError(g.Error);
  exports$d.TypeError = makeNodeError(g.TypeError);
  exports$d.RangeError = makeNodeError(g.RangeError); // To declare an error message, use the E(sym, val) function above. The sym
  // must be an upper case string. The val can be either a function or a string.
  // The return value of the function must be a string.
  // Examples:
  // E('EXAMPLE_KEY1', 'This is the error value');
  // E('EXAMPLE_KEY2', (a, b) => return \`\${a} \${b}\`);
  //
  // Once an error code has been assigned, the code itself MUST NOT change and
  // any given error code must never be reused to identify a different error.
  //
  // Any error code added here should also be added to the documentation
  //
  // Note: Please try to keep these in alphabetical order

  E(\\"ERR_ARG_NOT_ITERABLE\\", \\"%s must be iterable\\");
  E(\\"ERR_ASSERTION\\", \\"%s\\");
  E(\\"ERR_BUFFER_OUT_OF_BOUNDS\\", bufferOutOfBounds);
  E(\\"ERR_CHILD_CLOSED_BEFORE_REPLY\\", \\"Child closed before reply received\\");
  E(\\"ERR_CONSOLE_WRITABLE_STREAM\\", \\"Console expects a writable stream instance for %s\\");
  E(\\"ERR_CPU_USAGE\\", \\"Unable to obtain cpu usage %s\\");
  E(\\"ERR_DNS_SET_SERVERS_FAILED\\", function (err, servers) {
    return \\"c-ares failed to set servers: \\\\\\"\\" + err + \\"\\\\\\" [\\" + servers + \\"]\\";
  });
  E(\\"ERR_FALSY_VALUE_REJECTION\\", \\"Promise was rejected with falsy value\\");
  E(\\"ERR_ENCODING_NOT_SUPPORTED\\", function (enc) {
    return \\"The \\\\\\"\\" + enc + \\"\\\\\\" encoding is not supported\\";
  });
  E(\\"ERR_ENCODING_INVALID_ENCODED_DATA\\", function (enc) {
    return \\"The encoded data was not valid for encoding \\" + enc;
  });
  E(\\"ERR_HTTP_HEADERS_SENT\\", \\"Cannot render headers after they are sent to the client\\");
  E(\\"ERR_HTTP_INVALID_STATUS_CODE\\", \\"Invalid status code: %s\\");
  E(\\"ERR_HTTP_TRAILER_INVALID\\", \\"Trailers are invalid with this transfer encoding\\");
  E(\\"ERR_INDEX_OUT_OF_RANGE\\", \\"Index out of range\\");
  E(\\"ERR_INVALID_ARG_TYPE\\", invalidArgType);
  E(\\"ERR_INVALID_ARRAY_LENGTH\\", function (name, len, actual) {
    assert.strictEqual(typeof actual, \\"number\\");
    return \\"The array \\\\\\"\\" + name + \\"\\\\\\" (length \\" + actual + \\") must be of length \\" + len + \\".\\";
  });
  E(\\"ERR_INVALID_BUFFER_SIZE\\", \\"Buffer size must be a multiple of %s\\");
  E(\\"ERR_INVALID_CALLBACK\\", \\"Callback must be a function\\");
  E(\\"ERR_INVALID_CHAR\\", \\"Invalid character in %s\\");
  E(\\"ERR_INVALID_CURSOR_POS\\", \\"Cannot set cursor row without setting its column\\");
  E(\\"ERR_INVALID_FD\\", \\"\\\\\\"fd\\\\\\" must be a positive integer: %s\\");
  E(\\"ERR_INVALID_FILE_URL_HOST\\", \\"File URL host must be \\\\\\"localhost\\\\\\" or empty on %s\\");
  E(\\"ERR_INVALID_FILE_URL_PATH\\", \\"File URL path %s\\");
  E(\\"ERR_INVALID_HANDLE_TYPE\\", \\"This handle type cannot be sent\\");
  E(\\"ERR_INVALID_IP_ADDRESS\\", \\"Invalid IP address: %s\\");
  E(\\"ERR_INVALID_OPT_VALUE\\", function (name, value) {
    return \\"The value \\\\\\"\\" + String(value) + \\"\\\\\\" is invalid for option \\\\\\"\\" + name + \\"\\\\\\"\\";
  });
  E(\\"ERR_INVALID_OPT_VALUE_ENCODING\\", function (value) {
    return \\"The value \\\\\\"\\" + String(value) + \\"\\\\\\" is invalid for option \\\\\\"encoding\\\\\\"\\";
  });
  E(\\"ERR_INVALID_REPL_EVAL_CONFIG\\", \\"Cannot specify both \\\\\\"breakEvalOnSigint\\\\\\" and \\\\\\"eval\\\\\\" for REPL\\");
  E(\\"ERR_INVALID_SYNC_FORK_INPUT\\", \\"Asynchronous forks do not support Buffer, Uint8Array or string input: %s\\");
  E(\\"ERR_INVALID_THIS\\", \\"Value of \\\\\\"this\\\\\\" must be of type %s\\");
  E(\\"ERR_INVALID_TUPLE\\", \\"%s must be an iterable %s tuple\\");
  E(\\"ERR_INVALID_URL\\", \\"Invalid URL: %s\\");
  E(\\"ERR_INVALID_URL_SCHEME\\", function (expected) {
    return \\"The URL must be \\" + oneOf(expected, \\"scheme\\");
  });
  E(\\"ERR_IPC_CHANNEL_CLOSED\\", \\"Channel closed\\");
  E(\\"ERR_IPC_DISCONNECTED\\", \\"IPC channel is already disconnected\\");
  E(\\"ERR_IPC_ONE_PIPE\\", \\"Child process can have only one IPC pipe\\");
  E(\\"ERR_IPC_SYNC_FORK\\", \\"IPC cannot be used with synchronous forks\\");
  E(\\"ERR_MISSING_ARGS\\", missingArgs);
  E(\\"ERR_MULTIPLE_CALLBACK\\", \\"Callback called multiple times\\");
  E(\\"ERR_NAPI_CONS_FUNCTION\\", \\"Constructor must be a function\\");
  E(\\"ERR_NAPI_CONS_PROTOTYPE_OBJECT\\", \\"Constructor.prototype must be an object\\");
  E(\\"ERR_NO_CRYPTO\\", \\"Node.js is not compiled with OpenSSL crypto support\\");
  E(\\"ERR_NO_LONGER_SUPPORTED\\", \\"%s is no longer supported\\");
  E(\\"ERR_PARSE_HISTORY_DATA\\", \\"Could not parse history data in %s\\");
  E(\\"ERR_SOCKET_ALREADY_BOUND\\", \\"Socket is already bound\\");
  E(\\"ERR_SOCKET_BAD_PORT\\", \\"Port should be > 0 and < 65536\\");
  E(\\"ERR_SOCKET_BAD_TYPE\\", \\"Bad socket type specified. Valid types are: udp4, udp6\\");
  E(\\"ERR_SOCKET_CANNOT_SEND\\", \\"Unable to send data\\");
  E(\\"ERR_SOCKET_CLOSED\\", \\"Socket is closed\\");
  E(\\"ERR_SOCKET_DGRAM_NOT_RUNNING\\", \\"Not running\\");
  E(\\"ERR_STDERR_CLOSE\\", \\"process.stderr cannot be closed\\");
  E(\\"ERR_STDOUT_CLOSE\\", \\"process.stdout cannot be closed\\");
  E(\\"ERR_STREAM_WRAP\\", \\"Stream has StringDecoder set or is in objectMode\\");
  E(\\"ERR_TLS_CERT_ALTNAME_INVALID\\", \\"Hostname/IP does not match certificate's altnames: %s\\");
  E(\\"ERR_TLS_DH_PARAM_SIZE\\", function (size) {
    return \\"DH parameter size \\" + size + \\" is less than 2048\\";
  });
  E(\\"ERR_TLS_HANDSHAKE_TIMEOUT\\", \\"TLS handshake timeout\\");
  E(\\"ERR_TLS_RENEGOTIATION_FAILED\\", \\"Failed to renegotiate\\");
  E(\\"ERR_TLS_REQUIRED_SERVER_NAME\\", \\"\\\\\\"servername\\\\\\" is required parameter for Server.addContext\\");
  E(\\"ERR_TLS_SESSION_ATTACK\\", \\"TSL session renegotiation attack detected\\");
  E(\\"ERR_TRANSFORM_ALREADY_TRANSFORMING\\", \\"Calling transform done when still transforming\\");
  E(\\"ERR_TRANSFORM_WITH_LENGTH_0\\", \\"Calling transform done when writableState.length != 0\\");
  E(\\"ERR_UNKNOWN_ENCODING\\", \\"Unknown encoding: %s\\");
  E(\\"ERR_UNKNOWN_SIGNAL\\", \\"Unknown signal: %s\\");
  E(\\"ERR_UNKNOWN_STDIN_TYPE\\", \\"Unknown stdin file type\\");
  E(\\"ERR_UNKNOWN_STREAM_TYPE\\", \\"Unknown stream file type\\");
  E(\\"ERR_V8BREAKITERATOR\\", \\"Full ICU data not installed. \\" + \\"See https://github.com/nodejs/node/wiki/Intl\\");

  function invalidArgType(name, expected, actual) {
    assert(name, \\"name is required\\"); // determiner: 'must be' or 'must not be'

    var determiner;

    if (expected.includes(\\"not \\")) {
      determiner = \\"must not be\\";
      expected = expected.split(\\"not \\")[1];
    } else {
      determiner = \\"must be\\";
    }

    var msg;

    if (Array.isArray(name)) {
      var names = name.map(function (val) {
        return \\"\\\\\\"\\" + val + \\"\\\\\\"\\";
      }).join(\\", \\");
      msg = \\"The \\" + names + \\" arguments \\" + determiner + \\" \\" + oneOf(expected, \\"type\\");
    } else if (name.includes(\\" argument\\")) {
      // for the case like 'first argument'
      msg = \\"The \\" + name + \\" \\" + determiner + \\" \\" + oneOf(expected, \\"type\\");
    } else {
      var type = name.includes(\\".\\") ? \\"property\\" : \\"argument\\";
      msg = \\"The \\\\\\"\\" + name + \\"\\\\\\" \\" + type + \\" \\" + determiner + \\" \\" + oneOf(expected, \\"type\\");
    } // if actual value received, output it


    if (arguments.length >= 3) {
      msg += \\". Received type \\" + (actual !== null ? typeof actual : \\"null\\");
    }

    return msg;
  }

  function missingArgs() {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    assert(args.length > 0, \\"At least one arg needs to be specified\\");
    var msg = \\"The \\";
    var len = args.length;
    args = args.map(function (a) {
      return \\"\\\\\\"\\" + a + \\"\\\\\\"\\";
    });

    switch (len) {
      case 1:
        msg += args[0] + \\" argument\\";
        break;

      case 2:
        msg += args[0] + \\" and \\" + args[1] + \\" arguments\\";
        break;

      default:
        msg += args.slice(0, len - 1).join(\\", \\");
        msg += \\", and \\" + args[len - 1] + \\" arguments\\";
        break;
    }

    return msg + \\" must be specified\\";
  }

  function oneOf(expected, thing) {
    assert(expected, \\"expected is required\\");
    assert(typeof thing === \\"string\\", \\"thing is required\\");

    if (Array.isArray(expected)) {
      var len = expected.length;
      assert(len > 0, \\"At least one expected value needs to be specified\\"); // tslint:disable-next-line

      expected = expected.map(function (i) {
        return String(i);
      });

      if (len > 2) {
        return \\"one of \\" + thing + \\" \\" + expected.slice(0, len - 1).join(\\", \\") + \\", or \\" + expected[len - 1];
      } else if (len === 2) {
        return \\"one of \\" + thing + \\" \\" + expected[0] + \\" or \\" + expected[1];
      } else {
        return \\"of \\" + thing + \\" \\" + expected[0];
      }
    } else {
      return \\"of \\" + thing + \\" \\" + String(expected);
    }
  }

  function bufferOutOfBounds(name, isWriting) {
    if (isWriting) {
      return \\"Attempt to write outside buffer bounds\\";
    } else {
      return \\"\\\\\\"\\" + name + \\"\\\\\\" is outside of buffer bounds\\";
    }
  }

  return exports$d;
}

var exports$c = {},
    _dewExec$a = false;
function dew$a() {
  if (_dewExec$a) return exports$c;
  _dewExec$a = true;
  Object.defineProperty(exports$c, \\"__esModule\\", {
    value: true
  });
  exports$c.strToEncoding = exports$c.assertEncoding = exports$c.ENCODING_UTF8 = void 0;

  var buffer_1 = dew$c();

  var errors = dew$b();

  exports$c.ENCODING_UTF8 = \\"utf8\\";

  function assertEncoding(encoding) {
    if (encoding && !buffer_1.Buffer.isEncoding(encoding)) throw new errors.TypeError(\\"ERR_INVALID_OPT_VALUE_ENCODING\\", encoding);
  }

  exports$c.assertEncoding = assertEncoding;

  function strToEncoding(str, encoding) {
    if (!encoding || encoding === exports$c.ENCODING_UTF8) return str; // UTF-8

    if (encoding === \\"buffer\\") return new buffer_1.Buffer(str); // \`buffer\` encoding

    return new buffer_1.Buffer(str).toString(encoding); // Custom encoding
  }

  exports$c.strToEncoding = strToEncoding;
  return exports$c;
}

var exports$b = {},
    _dewExec$9 = false;
function dew$9() {
  if (_dewExec$9) return exports$b;
  _dewExec$9 = true;
  Object.defineProperty(exports$b, \\"__esModule\\", {
    value: true
  });
  exports$b.Dirent = void 0;

  var constants_1 = dew$f();

  var encoding_1 = dew$a();

  var S_IFMT = constants_1.constants.S_IFMT,
      S_IFDIR = constants_1.constants.S_IFDIR,
      S_IFREG = constants_1.constants.S_IFREG,
      S_IFBLK = constants_1.constants.S_IFBLK,
      S_IFCHR = constants_1.constants.S_IFCHR,
      S_IFLNK = constants_1.constants.S_IFLNK,
      S_IFIFO = constants_1.constants.S_IFIFO,
      S_IFSOCK = constants_1.constants.S_IFSOCK;
  /**
   * A directory entry, like \`fs.Dirent\`.
   */

  var Dirent = function () {
    function Dirent() {
      this.name = \\"\\";
      this.mode = 0;
    }

    Dirent.build = function (link, encoding) {
      var dirent = new Dirent();
      var mode = link.getNode().mode;
      dirent.name = (0, encoding_1.strToEncoding)(link.getName(), encoding);
      dirent.mode = mode;
      return dirent;
    };

    Dirent.prototype._checkModeProperty = function (property) {
      return (this.mode & S_IFMT) === property;
    };

    Dirent.prototype.isDirectory = function () {
      return this._checkModeProperty(S_IFDIR);
    };

    Dirent.prototype.isFile = function () {
      return this._checkModeProperty(S_IFREG);
    };

    Dirent.prototype.isBlockDevice = function () {
      return this._checkModeProperty(S_IFBLK);
    };

    Dirent.prototype.isCharacterDevice = function () {
      return this._checkModeProperty(S_IFCHR);
    };

    Dirent.prototype.isSymbolicLink = function () {
      return this._checkModeProperty(S_IFLNK);
    };

    Dirent.prototype.isFIFO = function () {
      return this._checkModeProperty(S_IFIFO);
    };

    Dirent.prototype.isSocket = function () {
      return this._checkModeProperty(S_IFSOCK);
    };

    return Dirent;
  }();

  exports$b.Dirent = Dirent;
  exports$b.default = Dirent;
  return exports$b;
}

var exports$a = {},
    _dewExec$8 = false;

var _global$2 = typeof globalThis !== \\"undefined\\" ? globalThis : typeof self !== \\"undefined\\" ? self : global;

function dew$8() {
  if (_dewExec$8) return exports$a;
  _dewExec$8 = true;
  var process$1 = process;
  Object.defineProperty(exports$a, \\"__esModule\\", {
    value: true
  });

  var _setImmediate;

  if (typeof process$1.nextTick === \\"function\\") _setImmediate = process$1.nextTick.bind(typeof globalThis !== \\"undefined\\" ? globalThis : _global$2);else _setImmediate = setTimeout.bind(typeof globalThis !== \\"undefined\\" ? globalThis : _global$2);
  exports$a.default = _setImmediate;
  return exports$a;
}

var exports$9 = {},
    _dewExec$7 = false;
function dew$7() {
  if (_dewExec$7) return exports$9;
  _dewExec$7 = true;
  var process$1 = process;
  // Here we mock the global \`process\` variable in case we are not in Node's environment.
  Object.defineProperty(exports$9, \\"__esModule\\", {
    value: true
  });
  exports$9.createProcess = void 0;
  /**
   * Looks to return a \`process\` object, if one is available.
   *
   * The global \`process\` is returned if defined;
   * otherwise \`require('process')\` is attempted.
   *
   * If that fails, \`undefined\` is returned.
   *
   * @return {IProcess | undefined}
   */

  var maybeReturnProcess = function () {
    if (typeof process$1 !== \\"undefined\\") {
      return process$1;
    }

    try {
      return process;
    } catch (_a) {
      return undefined;
    }
  };

  function createProcess() {
    var p = maybeReturnProcess() || {};
    if (!p.getuid) p.getuid = function () {
      return 0;
    };
    if (!p.getgid) p.getgid = function () {
      return 0;
    };
    if (!p.cwd) p.cwd = function () {
      return \\"/\\";
    };
    if (!p.nextTick) p.nextTick = dew$8().default;
    if (!p.emitWarning) p.emitWarning = function (message, type) {
      // tslint:disable-next-line:no-console
      console.warn(\\"\\" + type + (type ? \\": \\" : \\"\\") + message);
    };
    if (!p.env) p.env = {};
    return p;
  }

  exports$9.createProcess = createProcess;
  exports$9.default = createProcess();
  return exports$9;
}

var exports$8 = {},
    _dewExec$6 = false;
function dew$6() {
  if (_dewExec$6) return exports$8;
  _dewExec$6 = true;

  var __extends = exports$8 && exports$8.__extends || function () {
    var extendStatics = function (d, b) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      };

      return extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== \\"function\\" && b !== null) throw new TypeError(\\"Class extends value \\" + String(b) + \\" is not a constructor or null\\");
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(exports$8, \\"__esModule\\", {
    value: true
  });
  exports$8.File = exports$8.Link = exports$8.Node = exports$8.SEP = void 0;

  var process_1 = dew$7();

  var buffer_1 = dew$c();

  var constants_1 = dew$f();

  var events_1 = y;

  var Stats_1 = dew$d();

  var S_IFMT = constants_1.constants.S_IFMT,
      S_IFDIR = constants_1.constants.S_IFDIR,
      S_IFREG = constants_1.constants.S_IFREG,
      S_IFLNK = constants_1.constants.S_IFLNK,
      O_APPEND = constants_1.constants.O_APPEND;
  exports$8.SEP = \\"/\\";
  /**
   * Node in a file system (like i-node, v-node).
   */

  var Node = function (_super) {
    __extends(Node, _super);

    function Node(ino, perm) {
      if (perm === void 0) {
        perm = 438;
      }

      var _this = _super.call(this) || this; // User ID and group ID.


      _this.uid = process_1.default.getuid();
      _this.gid = process_1.default.getgid();
      _this.atime = new Date();
      _this.mtime = new Date();
      _this.ctime = new Date();
      _this.perm = 438; // Permissions \`chmod\`, \`fchmod\`

      _this.mode = S_IFREG; // S_IFDIR, S_IFREG, etc.. (file by default?)
      // Number of hard links pointing at this Node.

      _this.nlink = 1;
      _this.perm = perm;
      _this.mode |= perm;
      _this.ino = ino;
      return _this;
    }

    Node.prototype.getString = function (encoding) {
      if (encoding === void 0) {
        encoding = \\"utf8\\";
      }

      return this.getBuffer().toString(encoding);
    };

    Node.prototype.setString = function (str) {
      // this.setBuffer(bufferFrom(str, 'utf8'));
      this.buf = (0, buffer_1.bufferFrom)(str, \\"utf8\\");
      this.touch();
    };

    Node.prototype.getBuffer = function () {
      if (!this.buf) this.setBuffer((0, buffer_1.bufferAllocUnsafe)(0));
      return (0, buffer_1.bufferFrom)(this.buf); // Return a copy.
    };

    Node.prototype.setBuffer = function (buf) {
      this.buf = (0, buffer_1.bufferFrom)(buf); // Creates a copy of data.

      this.touch();
    };

    Node.prototype.getSize = function () {
      return this.buf ? this.buf.length : 0;
    };

    Node.prototype.setModeProperty = function (property) {
      this.mode = this.mode & ~S_IFMT | property;
    };

    Node.prototype.setIsFile = function () {
      this.setModeProperty(S_IFREG);
    };

    Node.prototype.setIsDirectory = function () {
      this.setModeProperty(S_IFDIR);
    };

    Node.prototype.setIsSymlink = function () {
      this.setModeProperty(S_IFLNK);
    };

    Node.prototype.isFile = function () {
      return (this.mode & S_IFMT) === S_IFREG;
    };

    Node.prototype.isDirectory = function () {
      return (this.mode & S_IFMT) === S_IFDIR;
    };

    Node.prototype.isSymlink = function () {
      // return !!this.symlink;
      return (this.mode & S_IFMT) === S_IFLNK;
    };

    Node.prototype.makeSymlink = function (steps) {
      this.symlink = steps;
      this.setIsSymlink();
    };

    Node.prototype.write = function (buf, off, len, pos) {
      if (off === void 0) {
        off = 0;
      }

      if (len === void 0) {
        len = buf.length;
      }

      if (pos === void 0) {
        pos = 0;
      }

      if (!this.buf) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);

      if (pos + len > this.buf.length) {
        var newBuf = (0, buffer_1.bufferAllocUnsafe)(pos + len);
        this.buf.copy(newBuf, 0, 0, this.buf.length);
        this.buf = newBuf;
      }

      buf.copy(this.buf, pos, off, off + len);
      this.touch();
      return len;
    }; // Returns the number of bytes read.


    Node.prototype.read = function (buf, off, len, pos) {
      if (off === void 0) {
        off = 0;
      }

      if (len === void 0) {
        len = buf.byteLength;
      }

      if (pos === void 0) {
        pos = 0;
      }

      if (!this.buf) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
      var actualLen = len;

      if (actualLen > buf.byteLength) {
        actualLen = buf.byteLength;
      }

      if (actualLen + pos > this.buf.length) {
        actualLen = this.buf.length - pos;
      }

      this.buf.copy(buf, off, pos, pos + actualLen);
      return actualLen;
    };

    Node.prototype.truncate = function (len) {
      if (len === void 0) {
        len = 0;
      }

      if (!len) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);else {
        if (!this.buf) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);

        if (len <= this.buf.length) {
          this.buf = this.buf.slice(0, len);
        } else {
          var buf = (0, buffer_1.bufferAllocUnsafe)(0);
          this.buf.copy(buf);
          buf.fill(0, len);
        }
      }
      this.touch();
    };

    Node.prototype.chmod = function (perm) {
      this.perm = perm;
      this.mode = this.mode & ~511 | perm;
      this.touch();
    };

    Node.prototype.chown = function (uid, gid) {
      this.uid = uid;
      this.gid = gid;
      this.touch();
    };

    Node.prototype.touch = function () {
      this.mtime = new Date();
      this.emit(\\"change\\", this);
    };

    Node.prototype.canRead = function (uid, gid) {
      if (uid === void 0) {
        uid = process_1.default.getuid();
      }

      if (gid === void 0) {
        gid = process_1.default.getgid();
      }

      if (this.perm & 4
      /* IROTH */
      ) {
        return true;
      }

      if (gid === this.gid) {
        if (this.perm & 32
        /* IRGRP */
        ) {
          return true;
        }
      }

      if (uid === this.uid) {
        if (this.perm & 256
        /* IRUSR */
        ) {
          return true;
        }
      }

      return false;
    };

    Node.prototype.canWrite = function (uid, gid) {
      if (uid === void 0) {
        uid = process_1.default.getuid();
      }

      if (gid === void 0) {
        gid = process_1.default.getgid();
      }

      if (this.perm & 2
      /* IWOTH */
      ) {
        return true;
      }

      if (gid === this.gid) {
        if (this.perm & 16
        /* IWGRP */
        ) {
          return true;
        }
      }

      if (uid === this.uid) {
        if (this.perm & 128
        /* IWUSR */
        ) {
          return true;
        }
      }

      return false;
    };

    Node.prototype.del = function () {
      this.emit(\\"delete\\", this);
    };

    Node.prototype.toJSON = function () {
      return {
        ino: this.ino,
        uid: this.uid,
        gid: this.gid,
        atime: this.atime.getTime(),
        mtime: this.mtime.getTime(),
        ctime: this.ctime.getTime(),
        perm: this.perm,
        mode: this.mode,
        nlink: this.nlink,
        symlink: this.symlink,
        data: this.getString()
      };
    };

    return Node;
  }(events_1.EventEmitter);

  exports$8.Node = Node;
  /**
   * Represents a hard link that points to an i-node \`node\`.
   */

  var Link = function (_super) {
    __extends(Link, _super);

    function Link(vol, parent, name) {
      var _this = _super.call(this) || this;

      _this.children = {}; // Path to this node as Array: ['usr', 'bin', 'node'].

      _this.steps = []; // \\"i-node\\" number of the node.

      _this.ino = 0; // Number of children.

      _this.length = 0;
      _this.vol = vol;
      _this.parent = parent;
      _this.steps = parent ? parent.steps.concat([name]) : [name];
      return _this;
    }

    Link.prototype.setNode = function (node) {
      this.node = node;
      this.ino = node.ino;
    };

    Link.prototype.getNode = function () {
      return this.node;
    };

    Link.prototype.createChild = function (name, node) {
      if (node === void 0) {
        node = this.vol.createNode();
      }

      var link = new Link(this.vol, this, name);
      link.setNode(node);

      if (node.isDirectory()) ;

      this.setChild(name, link);
      return link;
    };

    Link.prototype.setChild = function (name, link) {
      if (link === void 0) {
        link = new Link(this.vol, this, name);
      }

      this.children[name] = link;
      link.parent = this;
      this.length++;
      this.emit(\\"child:add\\", link, this);
      return link;
    };

    Link.prototype.deleteChild = function (link) {
      delete this.children[link.getName()];
      this.length--;
      this.emit(\\"child:delete\\", link, this);
    };

    Link.prototype.getChild = function (name) {
      if (Object.hasOwnProperty.call(this.children, name)) {
        return this.children[name];
      }
    };

    Link.prototype.getPath = function () {
      return this.steps.join(exports$8.SEP);
    };

    Link.prototype.getName = function () {
      return this.steps[this.steps.length - 1];
    }; // del() {
    //     const parent = this.parent;
    //     if(parent) {
    //         parent.deleteChild(link);
    //     }
    //     this.parent = null;
    //     this.vol = null;
    // }

    /**
     * Walk the tree path and return the \`Link\` at that location, if any.
     * @param steps {string[]} Desired location.
     * @param stop {number} Max steps to go into.
     * @param i {number} Current step in the \`steps\` array.
     *
     * @return {Link|null}
     */


    Link.prototype.walk = function (steps, stop, i) {
      if (stop === void 0) {
        stop = steps.length;
      }

      if (i === void 0) {
        i = 0;
      }

      if (i >= steps.length) return this;
      if (i >= stop) return this;
      var step = steps[i];
      var link = this.getChild(step);
      if (!link) return null;
      return link.walk(steps, stop, i + 1);
    };

    Link.prototype.toJSON = function () {
      return {
        steps: this.steps,
        ino: this.ino,
        children: Object.keys(this.children)
      };
    };

    return Link;
  }(events_1.EventEmitter);

  exports$8.Link = Link;
  /**
   * Represents an open file (file descriptor) that points to a \`Link\` (Hard-link) and a \`Node\`.
   */

  var File = function () {
    /**
     * Open a Link-Node pair. \`node\` is provided separately as that might be a different node
     * rather the one \`link\` points to, because it might be a symlink.
     * @param link
     * @param node
     * @param flags
     * @param fd
     */
    function File(link, node, flags, fd) {
      /**
       * A cursor/offset position in a file, where data will be written on write.
       * User can \\"seek\\" this position.
       */
      this.position = 0;
      this.link = link;
      this.node = node;
      this.flags = flags;
      this.fd = fd;
    }

    File.prototype.getString = function (encoding) {

      return this.node.getString();
    };

    File.prototype.setString = function (str) {
      this.node.setString(str);
    };

    File.prototype.getBuffer = function () {
      return this.node.getBuffer();
    };

    File.prototype.setBuffer = function (buf) {
      this.node.setBuffer(buf);
    };

    File.prototype.getSize = function () {
      return this.node.getSize();
    };

    File.prototype.truncate = function (len) {
      this.node.truncate(len);
    };

    File.prototype.seekTo = function (position) {
      this.position = position;
    };

    File.prototype.stats = function () {
      return Stats_1.default.build(this.node);
    };

    File.prototype.write = function (buf, offset, length, position) {
      if (offset === void 0) {
        offset = 0;
      }

      if (length === void 0) {
        length = buf.length;
      }

      if (typeof position !== \\"number\\") position = this.position;
      if (this.flags & O_APPEND) position = this.getSize();
      var bytes = this.node.write(buf, offset, length, position);
      this.position = position + bytes;
      return bytes;
    };

    File.prototype.read = function (buf, offset, length, position) {
      if (offset === void 0) {
        offset = 0;
      }

      if (length === void 0) {
        length = buf.byteLength;
      }

      if (typeof position !== \\"number\\") position = this.position;
      var bytes = this.node.read(buf, offset, length, position);
      this.position = position + bytes;
      return bytes;
    };

    File.prototype.chmod = function (perm) {
      this.node.chmod(perm);
    };

    File.prototype.chown = function (uid, gid) {
      this.node.chown(uid, gid);
    };

    return File;
  }();

  exports$8.File = File;
  return exports$8;
}

var exports$7 = {},
    _dewExec$5 = false;

var _global$1 = typeof globalThis !== \\"undefined\\" ? globalThis : typeof self !== \\"undefined\\" ? self : global;

function dew$5() {
  if (_dewExec$5) return exports$7;
  _dewExec$5 = true;
  Object.defineProperty(exports$7, \\"__esModule\\", {
    value: true
  });
  /**
   * \`setTimeoutUnref\` is just like \`setTimeout\`,
   * only in Node's environment it will \\"unref\\" its macro task.
   */

  function setTimeoutUnref(callback, time, args) {
    var ref = setTimeout.apply(typeof globalThis !== \\"undefined\\" ? globalThis : _global$1, arguments);
    if (ref && typeof ref === \\"object\\" && typeof ref.unref === \\"function\\") ref.unref();
    return ref;
  }

  exports$7.default = setTimeoutUnref;
  return exports$7;
}

var exports$6 = {},
    _dewExec$4 = false;
function dew$4() {
  if (_dewExec$4) return exports$6;
  _dewExec$4 = true;

  var __spreadArray = exports$6 && exports$6.__spreadArray || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };

  Object.defineProperty(exports$6, \\"__esModule\\", {
    value: true
  });
  exports$6.FileHandle = void 0;

  function promisify(vol, fn, getResult) {
    if (getResult === void 0) {
      getResult = function (input) {
        return input;
      };
    }

    return function () {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      return new Promise(function (resolve, reject) {
        vol[fn].bind(vol).apply(void 0, __spreadArray(__spreadArray([], args, false), [function (error, result) {
          if (error) return reject(error);
          return resolve(getResult(result));
        }], false));
      });
    };
  }

  var FileHandle = function () {
    function FileHandle(vol, fd) {
      this.vol = vol;
      this.fd = fd;
    }

    FileHandle.prototype.appendFile = function (data, options) {
      return promisify(this.vol, \\"appendFile\\")(this.fd, data, options);
    };

    FileHandle.prototype.chmod = function (mode) {
      return promisify(this.vol, \\"fchmod\\")(this.fd, mode);
    };

    FileHandle.prototype.chown = function (uid, gid) {
      return promisify(this.vol, \\"fchown\\")(this.fd, uid, gid);
    };

    FileHandle.prototype.close = function () {
      return promisify(this.vol, \\"close\\")(this.fd);
    };

    FileHandle.prototype.datasync = function () {
      return promisify(this.vol, \\"fdatasync\\")(this.fd);
    };

    FileHandle.prototype.read = function (buffer, offset, length, position) {
      return promisify(this.vol, \\"read\\", function (bytesRead) {
        return {
          bytesRead: bytesRead,
          buffer: buffer
        };
      })(this.fd, buffer, offset, length, position);
    };

    FileHandle.prototype.readFile = function (options) {
      return promisify(this.vol, \\"readFile\\")(this.fd, options);
    };

    FileHandle.prototype.stat = function (options) {
      return promisify(this.vol, \\"fstat\\")(this.fd, options);
    };

    FileHandle.prototype.sync = function () {
      return promisify(this.vol, \\"fsync\\")(this.fd);
    };

    FileHandle.prototype.truncate = function (len) {
      return promisify(this.vol, \\"ftruncate\\")(this.fd, len);
    };

    FileHandle.prototype.utimes = function (atime, mtime) {
      return promisify(this.vol, \\"futimes\\")(this.fd, atime, mtime);
    };

    FileHandle.prototype.write = function (buffer, offset, length, position) {
      return promisify(this.vol, \\"write\\", function (bytesWritten) {
        return {
          bytesWritten: bytesWritten,
          buffer: buffer
        };
      })(this.fd, buffer, offset, length, position);
    };

    FileHandle.prototype.writeFile = function (data, options) {
      return promisify(this.vol, \\"writeFile\\")(this.fd, data, options);
    };

    return FileHandle;
  }();

  exports$6.FileHandle = FileHandle;

  function createPromisesApi(vol) {
    if (typeof Promise === \\"undefined\\") return null;
    return {
      FileHandle: FileHandle,
      access: function (path, mode) {
        return promisify(vol, \\"access\\")(path, mode);
      },
      appendFile: function (path, data, options) {
        return promisify(vol, \\"appendFile\\")(path instanceof FileHandle ? path.fd : path, data, options);
      },
      chmod: function (path, mode) {
        return promisify(vol, \\"chmod\\")(path, mode);
      },
      chown: function (path, uid, gid) {
        return promisify(vol, \\"chown\\")(path, uid, gid);
      },
      copyFile: function (src, dest, flags) {
        return promisify(vol, \\"copyFile\\")(src, dest, flags);
      },
      lchmod: function (path, mode) {
        return promisify(vol, \\"lchmod\\")(path, mode);
      },
      lchown: function (path, uid, gid) {
        return promisify(vol, \\"lchown\\")(path, uid, gid);
      },
      link: function (existingPath, newPath) {
        return promisify(vol, \\"link\\")(existingPath, newPath);
      },
      lstat: function (path, options) {
        return promisify(vol, \\"lstat\\")(path, options);
      },
      mkdir: function (path, options) {
        return promisify(vol, \\"mkdir\\")(path, options);
      },
      mkdtemp: function (prefix, options) {
        return promisify(vol, \\"mkdtemp\\")(prefix, options);
      },
      open: function (path, flags, mode) {
        return promisify(vol, \\"open\\", function (fd) {
          return new FileHandle(vol, fd);
        })(path, flags, mode);
      },
      readdir: function (path, options) {
        return promisify(vol, \\"readdir\\")(path, options);
      },
      readFile: function (id, options) {
        return promisify(vol, \\"readFile\\")(id instanceof FileHandle ? id.fd : id, options);
      },
      readlink: function (path, options) {
        return promisify(vol, \\"readlink\\")(path, options);
      },
      realpath: function (path, options) {
        return promisify(vol, \\"realpath\\")(path, options);
      },
      rename: function (oldPath, newPath) {
        return promisify(vol, \\"rename\\")(oldPath, newPath);
      },
      rmdir: function (path) {
        return promisify(vol, \\"rmdir\\")(path);
      },
      stat: function (path, options) {
        return promisify(vol, \\"stat\\")(path, options);
      },
      symlink: function (target, path, type) {
        return promisify(vol, \\"symlink\\")(target, path, type);
      },
      truncate: function (path, len) {
        return promisify(vol, \\"truncate\\")(path, len);
      },
      unlink: function (path) {
        return promisify(vol, \\"unlink\\")(path);
      },
      utimes: function (path, atime, mtime) {
        return promisify(vol, \\"utimes\\")(path, atime, mtime);
      },
      writeFile: function (id, data, options) {
        return promisify(vol, \\"writeFile\\")(id instanceof FileHandle ? id.fd : id, data, options);
      }
    };
  }

  exports$6.default = createPromisesApi;
  return exports$6;
}

var exports$5 = {},
    _dewExec$3 = false;
function dew$3() {
  if (_dewExec$3) return exports$5;
  _dewExec$3 = true;
  var process$1 = process;
  Object.defineProperty(exports$5, \\"__esModule\\", {
    value: true
  });
  exports$5.unixify = unixify;
  exports$5.correctPath = correctPath;
  var isWin = process$1.platform === \\"win32\\";

  function removeTrailingSeparator(str) {
    var i = str.length - 1;

    if (i < 2) {
      return str;
    }

    while (isSeparator(str, i)) {
      i--;
    }

    return str.substr(0, i + 1);
  }

  function isSeparator(str, i) {
    var _char = str[i];
    return i > 0 && (_char === \\"/\\" || isWin && _char === \\"\\\\\\\\\\");
  }

  function normalizePath(str, stripTrailing) {
    if (typeof str !== \\"string\\") {
      throw new TypeError(\\"expected a string\\");
    }

    str = str.replace(/[\\\\\\\\\\\\/]+/g, \\"/\\");

    if (stripTrailing !== false) {
      str = removeTrailingSeparator(str);
    }

    return str;
  }

  function unixify(filepath) {
    var stripTrailing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    if (isWin) {
      filepath = normalizePath(filepath, stripTrailing);
      return filepath.replace(/^([a-zA-Z]+:|\\\\.\\\\/)/, \\"\\");
    }

    return filepath;
  }

  function correctPath(filepath) {
    return unixify(filepath.replace(/^\\\\\\\\\\\\\\\\\\\\?\\\\\\\\.:\\\\\\\\/, \\"\\\\\\\\\\"));
  }

  return exports$5;
}

var exports$4 = {},
    _dewExec$2 = false;

var _global = typeof globalThis !== \\"undefined\\" ? globalThis : typeof self !== \\"undefined\\" ? self : global;

function dew$2() {
  if (_dewExec$2) return exports$4;
  _dewExec$2 = true;

  var __extends = exports$4 && exports$4.__extends || function () {
    var extendStatics = function (d, b) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      };

      return extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== \\"function\\" && b !== null) throw new TypeError(\\"Class extends value \\" + String(b) + \\" is not a constructor or null\\");
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __spreadArray = exports$4 && exports$4.__spreadArray || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };

  Object.defineProperty(exports$4, \\"__esModule\\", {
    value: true
  });
  exports$4.FSWatcher = exports$4.StatWatcher = exports$4.Volume = exports$4.toUnixTimestamp = exports$4.bufferToEncoding = exports$4.dataToBuffer = exports$4.dataToStr = exports$4.pathToSteps = exports$4.filenameToSteps = exports$4.pathToFilename = exports$4.flagsToNumber = exports$4.FLAGS = void 0;
  var pathModule = exports$i;

  var node_1 = dew$6();

  var Stats_1 = dew$d();

  var Dirent_1 = dew$9();

  var buffer_1 = dew$c();

  var setImmediate_1 = dew$8();

  var process_1 = dew$7();

  var setTimeoutUnref_1 = dew$5();

  var stream_1 = exports$j;

  var constants_1 = dew$f();

  var events_1 = y;

  var encoding_1 = dew$a();

  var errors = dew$b();

  var util = X;

  var promises_1 = dew$4();

  var resolveCrossPlatform = pathModule.resolve;
  var O_RDONLY = constants_1.constants.O_RDONLY,
      O_WRONLY = constants_1.constants.O_WRONLY,
      O_RDWR = constants_1.constants.O_RDWR,
      O_CREAT = constants_1.constants.O_CREAT,
      O_EXCL = constants_1.constants.O_EXCL,
      O_TRUNC = constants_1.constants.O_TRUNC,
      O_APPEND = constants_1.constants.O_APPEND,
      O_SYNC = constants_1.constants.O_SYNC,
      O_DIRECTORY = constants_1.constants.O_DIRECTORY,
      F_OK = constants_1.constants.F_OK,
      COPYFILE_EXCL = constants_1.constants.COPYFILE_EXCL,
      COPYFILE_FICLONE_FORCE = constants_1.constants.COPYFILE_FICLONE_FORCE;

  var _a = pathModule.posix ? pathModule.posix : pathModule,
      sep = _a.sep,
      relative = _a.relative,
      join = _a.join,
      dirname = _a.dirname;

  var isWin = process_1.default.platform === \\"win32\\";
  var kMinPoolSpace = 128; // const kMaxLength = require('buffer').kMaxLength;
  // ---------------------------------------- Error messages
  // TODO: Use \`internal/errors.js\` in the future.

  var ERRSTR = {
    PATH_STR: \\"path must be a string or Buffer\\",
    // FD:             'file descriptor must be a unsigned 32-bit integer',
    FD: \\"fd must be a file descriptor\\",
    MODE_INT: \\"mode must be an int\\",
    CB: \\"callback must be a function\\",
    UID: \\"uid must be an unsigned int\\",
    GID: \\"gid must be an unsigned int\\",
    LEN: \\"len must be an integer\\",
    ATIME: \\"atime must be an integer\\",
    MTIME: \\"mtime must be an integer\\",
    PREFIX: \\"filename prefix is required\\",
    BUFFER: \\"buffer must be an instance of Buffer or StaticBuffer\\",
    OFFSET: \\"offset must be an integer\\",
    LENGTH: \\"length must be an integer\\",
    POSITION: \\"position must be an integer\\"
  };

  var ERRSTR_OPTS = function (tipeof) {
    return \\"Expected options to be either an object or a string, but got \\" + tipeof + \\" instead\\";
  }; // const ERRSTR_FLAG = flag => \`Unknown file open flag: \${flag}\`;


  var ENOENT = \\"ENOENT\\";
  var EBADF = \\"EBADF\\";
  var EINVAL = \\"EINVAL\\";
  var EPERM = \\"EPERM\\";
  var EPROTO = \\"EPROTO\\";
  var EEXIST = \\"EEXIST\\";
  var ENOTDIR = \\"ENOTDIR\\";
  var EMFILE = \\"EMFILE\\";
  var EACCES = \\"EACCES\\";
  var EISDIR = \\"EISDIR\\";
  var ENOTEMPTY = \\"ENOTEMPTY\\";
  var ENOSYS = \\"ENOSYS\\";

  function formatError(errorCode, func, path, path2) {
    if (func === void 0) {
      func = \\"\\";
    }

    if (path === void 0) {
      path = \\"\\";
    }

    if (path2 === void 0) {
      path2 = \\"\\";
    }

    var pathFormatted = \\"\\";
    if (path) pathFormatted = \\" '\\" + path + \\"'\\";
    if (path2) pathFormatted += \\" -> '\\" + path2 + \\"'\\";

    switch (errorCode) {
      case ENOENT:
        return \\"ENOENT: no such file or directory, \\" + func + pathFormatted;

      case EBADF:
        return \\"EBADF: bad file descriptor, \\" + func + pathFormatted;

      case EINVAL:
        return \\"EINVAL: invalid argument, \\" + func + pathFormatted;

      case EPERM:
        return \\"EPERM: operation not permitted, \\" + func + pathFormatted;

      case EPROTO:
        return \\"EPROTO: protocol error, \\" + func + pathFormatted;

      case EEXIST:
        return \\"EEXIST: file already exists, \\" + func + pathFormatted;

      case ENOTDIR:
        return \\"ENOTDIR: not a directory, \\" + func + pathFormatted;

      case EISDIR:
        return \\"EISDIR: illegal operation on a directory, \\" + func + pathFormatted;

      case EACCES:
        return \\"EACCES: permission denied, \\" + func + pathFormatted;

      case ENOTEMPTY:
        return \\"ENOTEMPTY: directory not empty, \\" + func + pathFormatted;

      case EMFILE:
        return \\"EMFILE: too many open files, \\" + func + pathFormatted;

      case ENOSYS:
        return \\"ENOSYS: function not implemented, \\" + func + pathFormatted;

      default:
        return errorCode + \\": error occurred, \\" + func + pathFormatted;
    }
  }

  function createError(errorCode, func, path, path2, Constructor) {
    if (func === void 0) {
      func = \\"\\";
    }

    if (path === void 0) {
      path = \\"\\";
    }

    if (path2 === void 0) {
      path2 = \\"\\";
    }

    if (Constructor === void 0) {
      Constructor = Error;
    }

    var error = new Constructor(formatError(errorCode, func, path, path2));
    error.code = errorCode;
    return error;
  } // ---------------------------------------- Flags
  // List of file \`flags\` as defined by Node.


  var FLAGS;

  (function (FLAGS) {
    // Open file for reading. An exception occurs if the file does not exist.
    FLAGS[FLAGS[\\"r\\"] = O_RDONLY] = \\"r\\"; // Open file for reading and writing. An exception occurs if the file does not exist.

    FLAGS[FLAGS[\\"r+\\"] = O_RDWR] = \\"r+\\"; // Open file for reading in synchronous mode. Instructs the operating system to bypass the local file system cache.

    FLAGS[FLAGS[\\"rs\\"] = O_RDONLY | O_SYNC] = \\"rs\\";
    FLAGS[FLAGS[\\"sr\\"] = FLAGS.rs] = \\"sr\\"; // Open file for reading and writing, telling the OS to open it synchronously. See notes for 'rs' about using this with caution.

    FLAGS[FLAGS[\\"rs+\\"] = O_RDWR | O_SYNC] = \\"rs+\\";
    FLAGS[FLAGS[\\"sr+\\"] = FLAGS[\\"rs+\\"]] = \\"sr+\\"; // Open file for writing. The file is created (if it does not exist) or truncated (if it exists).

    FLAGS[FLAGS[\\"w\\"] = O_WRONLY | O_CREAT | O_TRUNC] = \\"w\\"; // Like 'w' but fails if path exists.

    FLAGS[FLAGS[\\"wx\\"] = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL] = \\"wx\\";
    FLAGS[FLAGS[\\"xw\\"] = FLAGS.wx] = \\"xw\\"; // Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).

    FLAGS[FLAGS[\\"w+\\"] = O_RDWR | O_CREAT | O_TRUNC] = \\"w+\\"; // Like 'w+' but fails if path exists.

    FLAGS[FLAGS[\\"wx+\\"] = O_RDWR | O_CREAT | O_TRUNC | O_EXCL] = \\"wx+\\";
    FLAGS[FLAGS[\\"xw+\\"] = FLAGS[\\"wx+\\"]] = \\"xw+\\"; // Open file for appending. The file is created if it does not exist.

    FLAGS[FLAGS[\\"a\\"] = O_WRONLY | O_APPEND | O_CREAT] = \\"a\\"; // Like 'a' but fails if path exists.

    FLAGS[FLAGS[\\"ax\\"] = O_WRONLY | O_APPEND | O_CREAT | O_EXCL] = \\"ax\\";
    FLAGS[FLAGS[\\"xa\\"] = FLAGS.ax] = \\"xa\\"; // Open file for reading and appending. The file is created if it does not exist.

    FLAGS[FLAGS[\\"a+\\"] = O_RDWR | O_APPEND | O_CREAT] = \\"a+\\"; // Like 'a+' but fails if path exists.

    FLAGS[FLAGS[\\"ax+\\"] = O_RDWR | O_APPEND | O_CREAT | O_EXCL] = \\"ax+\\";
    FLAGS[FLAGS[\\"xa+\\"] = FLAGS[\\"ax+\\"]] = \\"xa+\\";
  })(FLAGS = exports$4.FLAGS || (exports$4.FLAGS = {}));

  function flagsToNumber(flags) {
    if (typeof flags === \\"number\\") return flags;

    if (typeof flags === \\"string\\") {
      var flagsNum = FLAGS[flags];
      if (typeof flagsNum !== \\"undefined\\") return flagsNum;
    } // throw new TypeError(formatError(ERRSTR_FLAG(flags)));


    throw new errors.TypeError(\\"ERR_INVALID_OPT_VALUE\\", \\"flags\\", flags);
  }

  exports$4.flagsToNumber = flagsToNumber; // ---------------------------------------- Options

  function getOptions(defaults, options) {
    var opts;
    if (!options) return defaults;else {
      var tipeof = typeof options;

      switch (tipeof) {
        case \\"string\\":
          opts = Object.assign({}, defaults, {
            encoding: options
          });
          break;

        case \\"object\\":
          opts = Object.assign({}, defaults, options);
          break;

        default:
          throw TypeError(ERRSTR_OPTS(tipeof));
      }
    }
    if (opts.encoding !== \\"buffer\\") (0, encoding_1.assertEncoding)(opts.encoding);
    return opts;
  }

  function optsGenerator(defaults) {
    return function (options) {
      return getOptions(defaults, options);
    };
  }

  function validateCallback(callback) {
    if (typeof callback !== \\"function\\") throw TypeError(ERRSTR.CB);
    return callback;
  }

  function optsAndCbGenerator(getOpts) {
    return function (options, callback) {
      return typeof options === \\"function\\" ? [getOpts(), options] : [getOpts(options), validateCallback(callback)];
    };
  }

  var optsDefaults = {
    encoding: \\"utf8\\"
  };
  var getDefaultOpts = optsGenerator(optsDefaults);
  var getDefaultOptsAndCb = optsAndCbGenerator(getDefaultOpts);
  var readFileOptsDefaults = {
    flag: \\"r\\"
  };
  var getReadFileOptions = optsGenerator(readFileOptsDefaults);
  var writeFileDefaults = {
    encoding: \\"utf8\\",
    mode: 438
    /* DEFAULT */
    ,
    flag: FLAGS[FLAGS.w]
  };
  var getWriteFileOptions = optsGenerator(writeFileDefaults);
  var appendFileDefaults = {
    encoding: \\"utf8\\",
    mode: 438
    /* DEFAULT */
    ,
    flag: FLAGS[FLAGS.a]
  };
  var getAppendFileOpts = optsGenerator(appendFileDefaults);
  var getAppendFileOptsAndCb = optsAndCbGenerator(getAppendFileOpts);
  var realpathDefaults = optsDefaults;
  var getRealpathOptions = optsGenerator(realpathDefaults);
  var getRealpathOptsAndCb = optsAndCbGenerator(getRealpathOptions);
  var mkdirDefaults = {
    mode: 511
    /* DIR */
    ,
    recursive: false
  };

  var getMkdirOptions = function (options) {
    if (typeof options === \\"number\\") return Object.assign({}, mkdirDefaults, {
      mode: options
    });
    return Object.assign({}, mkdirDefaults, options);
  };

  var rmdirDefaults = {
    recursive: false
  };

  var getRmdirOptions = function (options) {
    return Object.assign({}, rmdirDefaults, options);
  };

  var readdirDefaults = {
    encoding: \\"utf8\\",
    withFileTypes: false
  };
  var getReaddirOptions = optsGenerator(readdirDefaults);
  var getReaddirOptsAndCb = optsAndCbGenerator(getReaddirOptions);
  var statDefaults = {
    bigint: false
  };

  var getStatOptions = function (options) {
    if (options === void 0) {
      options = {};
    }

    return Object.assign({}, statDefaults, options);
  };

  var getStatOptsAndCb = function (options, callback) {
    return typeof options === \\"function\\" ? [getStatOptions(), options] : [getStatOptions(options), validateCallback(callback)];
  }; // ---------------------------------------- Utility functions


  function getPathFromURLPosix(url) {
    if (url.hostname !== \\"\\") {
      throw new errors.TypeError(\\"ERR_INVALID_FILE_URL_HOST\\", process_1.default.platform);
    }

    var pathname = url.pathname;

    for (var n = 0; n < pathname.length; n++) {
      if (pathname[n] === \\"%\\") {
        var third = pathname.codePointAt(n + 2) | 32;

        if (pathname[n + 1] === \\"2\\" && third === 102) {
          throw new errors.TypeError(\\"ERR_INVALID_FILE_URL_PATH\\", \\"must not include encoded / characters\\");
        }
      }
    }

    return decodeURIComponent(pathname);
  }

  function pathToFilename(path) {
    if (typeof path !== \\"string\\" && !buffer_1.Buffer.isBuffer(path)) {
      try {
        if (!(path instanceof h.URL)) throw new TypeError(ERRSTR.PATH_STR);
      } catch (err) {
        throw new TypeError(ERRSTR.PATH_STR);
      }

      path = getPathFromURLPosix(path);
    }

    var pathString = String(path);
    nullCheck(pathString); // return slash(pathString);

    return pathString;
  }

  exports$4.pathToFilename = pathToFilename;

  var resolve = function (filename, base) {
    if (base === void 0) {
      base = process_1.default.cwd();
    }

    return resolveCrossPlatform(base, filename);
  };

  if (isWin) {
    var _resolve_1 = resolve;

    var unixify_1 = dew$3().unixify;

    resolve = function (filename, base) {
      return unixify_1(_resolve_1(filename, base));
    };
  }

  function filenameToSteps(filename, base) {
    var fullPath = resolve(filename, base);
    var fullPathSansSlash = fullPath.substr(1);
    if (!fullPathSansSlash) return [];
    return fullPathSansSlash.split(sep);
  }

  exports$4.filenameToSteps = filenameToSteps;

  function pathToSteps(path) {
    return filenameToSteps(pathToFilename(path));
  }

  exports$4.pathToSteps = pathToSteps;

  function dataToStr(data, encoding) {
    if (encoding === void 0) {
      encoding = encoding_1.ENCODING_UTF8;
    }

    if (buffer_1.Buffer.isBuffer(data)) return data.toString(encoding);else if (data instanceof Uint8Array) return (0, buffer_1.bufferFrom)(data).toString(encoding);else return String(data);
  }

  exports$4.dataToStr = dataToStr;

  function dataToBuffer(data, encoding) {
    if (encoding === void 0) {
      encoding = encoding_1.ENCODING_UTF8;
    }

    if (buffer_1.Buffer.isBuffer(data)) return data;else if (data instanceof Uint8Array) return (0, buffer_1.bufferFrom)(data);else return (0, buffer_1.bufferFrom)(String(data), encoding);
  }

  exports$4.dataToBuffer = dataToBuffer;

  function bufferToEncoding(buffer, encoding) {
    if (!encoding || encoding === \\"buffer\\") return buffer;else return buffer.toString(encoding);
  }

  exports$4.bufferToEncoding = bufferToEncoding;

  function nullCheck(path, callback) {
    if ((\\"\\" + path).indexOf(\\"\\\\0\\") !== -1) {
      var er = new Error(\\"Path must be a string without null bytes\\");
      er.code = ENOENT;
      if (typeof callback !== \\"function\\") throw er;
      process_1.default.nextTick(callback, er);
      return false;
    }

    return true;
  }

  function _modeToNumber(mode, def) {
    if (typeof mode === \\"number\\") return mode;
    if (typeof mode === \\"string\\") return parseInt(mode, 8);
    if (def) return modeToNumber(def);
    return undefined;
  }

  function modeToNumber(mode, def) {
    var result = _modeToNumber(mode, def);

    if (typeof result !== \\"number\\" || isNaN(result)) throw new TypeError(ERRSTR.MODE_INT);
    return result;
  }

  function isFd(path) {
    return path >>> 0 === path;
  }

  function validateFd(fd) {
    if (!isFd(fd)) throw TypeError(ERRSTR.FD);
  } // converts Date or number to a fractional UNIX timestamp


  function toUnixTimestamp(time) {
    // tslint:disable-next-line triple-equals
    if (typeof time === \\"string\\" && +time == time) {
      return +time;
    }

    if (time instanceof Date) {
      return time.getTime() / 1000;
    }

    if (isFinite(time)) {
      if (time < 0) {
        return Date.now() / 1000;
      }

      return time;
    }

    throw new Error(\\"Cannot parse time: \\" + time);
  }

  exports$4.toUnixTimestamp = toUnixTimestamp;

  function validateUid(uid) {
    if (typeof uid !== \\"number\\") throw TypeError(ERRSTR.UID);
  }

  function validateGid(gid) {
    if (typeof gid !== \\"number\\") throw TypeError(ERRSTR.GID);
  }

  function flattenJSON(nestedJSON) {
    var flatJSON = {};

    function flatten(pathPrefix, node) {
      for (var path in node) {
        var contentOrNode = node[path];
        var joinedPath = join(pathPrefix, path);

        if (typeof contentOrNode === \\"string\\") {
          flatJSON[joinedPath] = contentOrNode;
        } else if (typeof contentOrNode === \\"object\\" && contentOrNode !== null && Object.keys(contentOrNode).length > 0) {
          // empty directories need an explicit entry and therefore get handled in \`else\`, non-empty ones are implicitly considered
          flatten(joinedPath, contentOrNode);
        } else {
          // without this branch null, empty-object or non-object entries would not be handled in the same way
          // by both fromJSON() and fromNestedJSON()
          flatJSON[joinedPath] = null;
        }
      }
    }

    flatten(\\"\\", nestedJSON);
    return flatJSON;
  }
  /**
   * \`Volume\` represents a file system.
   */


  var Volume = function () {
    function Volume(props) {
      if (props === void 0) {
        props = {};
      } // I-node number counter.


      this.ino = 0; // A mapping for i-node numbers to i-nodes (\`Node\`);

      this.inodes = {}; // List of released i-node numbers, for reuse.

      this.releasedInos = []; // A mapping for file descriptors to \`File\`s.

      this.fds = {}; // A list of reusable (opened and closed) file descriptors, that should be
      // used first before creating a new file descriptor.

      this.releasedFds = []; // Max number of open files.

      this.maxFiles = 10000; // Current number of open files.

      this.openFiles = 0;
      this.promisesApi = (0, promises_1.default)(this);
      this.statWatchers = {};
      this.props = Object.assign({
        Node: node_1.Node,
        Link: node_1.Link,
        File: node_1.File
      }, props);
      var root = this.createLink();
      root.setNode(this.createNode(true));
      var self = this; // tslint:disable-line no-this-assignment

      this.StatWatcher = function (_super) {
        __extends(StatWatcher, _super);

        function StatWatcher() {
          return _super.call(this, self) || this;
        }

        return StatWatcher;
      }(StatWatcher);

      var _ReadStream = FsReadStream;

      this.ReadStream = function (_super) {
        __extends(class_1, _super);

        function class_1() {
          var args = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }

          return _super.apply(this, __spreadArray([self], args, false)) || this;
        }

        return class_1;
      }(_ReadStream);

      var _WriteStream = FsWriteStream;

      this.WriteStream = function (_super) {
        __extends(class_2, _super);

        function class_2() {
          var args = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }

          return _super.apply(this, __spreadArray([self], args, false)) || this;
        }

        return class_2;
      }(_WriteStream);

      this.FSWatcher = function (_super) {
        __extends(FSWatcher, _super);

        function FSWatcher() {
          return _super.call(this, self) || this;
        }

        return FSWatcher;
      }(FSWatcher); // root.setChild('.', root);
      // root.getNode().nlink++;
      // root.setChild('..', root);
      // root.getNode().nlink++;


      this.root = root;
    }

    Volume.fromJSON = function (json, cwd) {
      var vol = new Volume();
      vol.fromJSON(json, cwd);
      return vol;
    };

    Volume.fromNestedJSON = function (json, cwd) {
      var vol = new Volume();
      vol.fromNestedJSON(json, cwd);
      return vol;
    };

    Object.defineProperty(Volume.prototype, \\"promises\\", {
      get: function () {
        if (this.promisesApi === null) throw new Error(\\"Promise is not supported in this environment.\\");
        return this.promisesApi;
      },
      enumerable: false,
      configurable: true
    });

    Volume.prototype.createLink = function (parent, name, isDirectory, perm) {
      if (isDirectory === void 0) {
        isDirectory = false;
      }

      if (!parent) {
        return new this.props.Link(this, null, \\"\\");
      }

      if (!name) {
        throw new Error(\\"createLink: name cannot be empty\\");
      }

      return parent.createChild(name, this.createNode(isDirectory, perm));
    };

    Volume.prototype.deleteLink = function (link) {
      var parent = link.parent;

      if (parent) {
        parent.deleteChild(link);
        return true;
      }

      return false;
    };

    Volume.prototype.newInoNumber = function () {
      var releasedFd = this.releasedInos.pop();
      if (releasedFd) return releasedFd;else {
        this.ino = (this.ino + 1) % 4294967295;
        return this.ino;
      }
    };

    Volume.prototype.newFdNumber = function () {
      var releasedFd = this.releasedFds.pop();
      return typeof releasedFd === \\"number\\" ? releasedFd : Volume.fd--;
    };

    Volume.prototype.createNode = function (isDirectory, perm) {
      if (isDirectory === void 0) {
        isDirectory = false;
      }

      var node = new this.props.Node(this.newInoNumber(), perm);
      if (isDirectory) node.setIsDirectory();
      this.inodes[node.ino] = node;
      return node;
    };

    Volume.prototype.getNode = function (ino) {
      return this.inodes[ino];
    };

    Volume.prototype.deleteNode = function (node) {
      node.del();
      delete this.inodes[node.ino];
      this.releasedInos.push(node.ino);
    }; // Generates 6 character long random string, used by \`mkdtemp\`.


    Volume.prototype.genRndStr = function () {
      var str = (Math.random() + 1).toString(36).substr(2, 6);
      if (str.length === 6) return str;else return this.genRndStr();
    }; // Returns a \`Link\` (hard link) referenced by path \\"split\\" into steps.


    Volume.prototype.getLink = function (steps) {
      return this.root.walk(steps);
    }; // Just link \`getLink\`, but throws a correct user error, if link to found.


    Volume.prototype.getLinkOrThrow = function (filename, funcName) {
      var steps = filenameToSteps(filename);
      var link = this.getLink(steps);
      if (!link) throw createError(ENOENT, funcName, filename);
      return link;
    }; // Just like \`getLink\`, but also dereference/resolves symbolic links.


    Volume.prototype.getResolvedLink = function (filenameOrSteps) {
      var steps = typeof filenameOrSteps === \\"string\\" ? filenameToSteps(filenameOrSteps) : filenameOrSteps;
      var link = this.root;
      var i = 0;

      while (i < steps.length) {
        var step = steps[i];
        link = link.getChild(step);
        if (!link) return null;
        var node = link.getNode();

        if (node.isSymlink()) {
          steps = node.symlink.concat(steps.slice(i + 1));
          link = this.root;
          i = 0;
          continue;
        }

        i++;
      }

      return link;
    }; // Just like \`getLinkOrThrow\`, but also dereference/resolves symbolic links.


    Volume.prototype.getResolvedLinkOrThrow = function (filename, funcName) {
      var link = this.getResolvedLink(filename);
      if (!link) throw createError(ENOENT, funcName, filename);
      return link;
    };

    Volume.prototype.resolveSymlinks = function (link) {
      // let node: Node = link.getNode();
      // while(link && node.isSymlink()) {
      //     link = this.getLink(node.symlink);
      //     if(!link) return null;
      //     node = link.getNode();
      // }
      // return link;
      return this.getResolvedLink(link.steps.slice(1));
    }; // Just like \`getLinkOrThrow\`, but also verifies that the link is a directory.


    Volume.prototype.getLinkAsDirOrThrow = function (filename, funcName) {
      var link = this.getLinkOrThrow(filename, funcName);
      if (!link.getNode().isDirectory()) throw createError(ENOTDIR, funcName, filename);
      return link;
    }; // Get the immediate parent directory of the link.


    Volume.prototype.getLinkParent = function (steps) {
      return this.root.walk(steps, steps.length - 1);
    };

    Volume.prototype.getLinkParentAsDirOrThrow = function (filenameOrSteps, funcName) {
      var steps = filenameOrSteps instanceof Array ? filenameOrSteps : filenameToSteps(filenameOrSteps);
      var link = this.getLinkParent(steps);
      if (!link) throw createError(ENOENT, funcName, sep + steps.join(sep));
      if (!link.getNode().isDirectory()) throw createError(ENOTDIR, funcName, sep + steps.join(sep));
      return link;
    };

    Volume.prototype.getFileByFd = function (fd) {
      return this.fds[String(fd)];
    };

    Volume.prototype.getFileByFdOrThrow = function (fd, funcName) {
      if (!isFd(fd)) throw TypeError(ERRSTR.FD);
      var file = this.getFileByFd(fd);
      if (!file) throw createError(EBADF, funcName);
      return file;
    };

    Volume.prototype.getNodeByIdOrCreate = function (id, flags, perm) {
      if (typeof id === \\"number\\") {
        var file = this.getFileByFd(id);
        if (!file) throw Error(\\"File nto found\\");
        return file.node;
      } else {
        var steps = pathToSteps(id);
        var link = this.getLink(steps);
        if (link) return link.getNode(); // Try creating a node if not found.

        if (flags & O_CREAT) {
          var dirLink = this.getLinkParent(steps);

          if (dirLink) {
            var name_1 = steps[steps.length - 1];
            link = this.createLink(dirLink, name_1, false, perm);
            return link.getNode();
          }
        }

        throw createError(ENOENT, \\"getNodeByIdOrCreate\\", pathToFilename(id));
      }
    };

    Volume.prototype.wrapAsync = function (method, args, callback) {
      var _this = this;

      validateCallback(callback);
      (0, setImmediate_1.default)(function () {
        var result;

        try {
          result = method.apply(_this, args);
        } catch (err) {
          callback(err);
          return;
        }

        callback(null, result);
      });
    };

    Volume.prototype._toJSON = function (link, json, path) {
      var _a;

      if (link === void 0) {
        link = this.root;
      }

      if (json === void 0) {
        json = {};
      }

      var isEmpty = true;
      var children = link.children;

      if (link.getNode().isFile()) {
        children = (_a = {}, _a[link.getName()] = link.parent.getChild(link.getName()), _a);
        link = link.parent;
      }

      for (var name_2 in children) {
        isEmpty = false;
        var child = link.getChild(name_2);

        if (!child) {
          throw new Error(\\"_toJSON: unexpected undefined\\");
        }

        var node = child.getNode();

        if (node.isFile()) {
          var filename = child.getPath();
          if (path) filename = relative(path, filename);
          json[filename] = node.getString();
        } else if (node.isDirectory()) {
          this._toJSON(child, json, path);
        }
      }

      var dirPath = link.getPath();
      if (path) dirPath = relative(path, dirPath);

      if (dirPath && isEmpty) {
        json[dirPath] = null;
      }

      return json;
    };

    Volume.prototype.toJSON = function (paths, json, isRelative) {
      if (json === void 0) {
        json = {};
      }

      if (isRelative === void 0) {
        isRelative = false;
      }

      var links = [];

      if (paths) {
        if (!(paths instanceof Array)) paths = [paths];

        for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
          var path = paths_1[_i];
          var filename = pathToFilename(path);
          var link = this.getResolvedLink(filename);
          if (!link) continue;
          links.push(link);
        }
      } else {
        links.push(this.root);
      }

      if (!links.length) return json;

      for (var _a = 0, links_1 = links; _a < links_1.length; _a++) {
        var link = links_1[_a];

        this._toJSON(link, json, isRelative ? link.getPath() : \\"\\");
      }

      return json;
    };

    Volume.prototype.fromJSON = function (json, cwd) {
      if (cwd === void 0) {
        cwd = process_1.default.cwd();
      }

      for (var filename in json) {
        var data = json[filename];
        filename = resolve(filename, cwd);

        if (typeof data === \\"string\\") {
          var dir = dirname(filename);
          this.mkdirpBase(dir, 511
          /* DIR */
          );
          this.writeFileSync(filename, data);
        } else {
          this.mkdirpBase(filename, 511
          /* DIR */
          );
        }
      }
    };

    Volume.prototype.fromNestedJSON = function (json, cwd) {
      this.fromJSON(flattenJSON(json), cwd);
    };

    Volume.prototype.reset = function () {
      this.ino = 0;
      this.inodes = {};
      this.releasedInos = [];
      this.fds = {};
      this.releasedFds = [];
      this.openFiles = 0;
      this.root = this.createLink();
      this.root.setNode(this.createNode(true));
    }; // Legacy interface


    Volume.prototype.mountSync = function (mountpoint, json) {
      this.fromJSON(json, mountpoint);
    };

    Volume.prototype.openLink = function (link, flagsNum, resolveSymlinks) {
      if (resolveSymlinks === void 0) {
        resolveSymlinks = true;
      }

      if (this.openFiles >= this.maxFiles) {
        // Too many open files.
        throw createError(EMFILE, \\"open\\", link.getPath());
      } // Resolve symlinks.


      var realLink = link;
      if (resolveSymlinks) realLink = this.resolveSymlinks(link);
      if (!realLink) throw createError(ENOENT, \\"open\\", link.getPath());
      var node = realLink.getNode(); // Check whether node is a directory

      if (node.isDirectory()) {
        if ((flagsNum & (O_RDONLY | O_RDWR | O_WRONLY)) !== O_RDONLY) throw createError(EISDIR, \\"open\\", link.getPath());
      } else {
        if (flagsNum & O_DIRECTORY) throw createError(ENOTDIR, \\"open\\", link.getPath());
      } // Check node permissions


      if (!(flagsNum & O_WRONLY)) {
        if (!node.canRead()) {
          throw createError(EACCES, \\"open\\", link.getPath());
        }
      }

      var file = new this.props.File(link, node, flagsNum, this.newFdNumber());
      this.fds[file.fd] = file;
      this.openFiles++;
      if (flagsNum & O_TRUNC) file.truncate();
      return file;
    };

    Volume.prototype.openFile = function (filename, flagsNum, modeNum, resolveSymlinks) {
      if (resolveSymlinks === void 0) {
        resolveSymlinks = true;
      }

      var steps = filenameToSteps(filename);
      var link = resolveSymlinks ? this.getResolvedLink(steps) : this.getLink(steps); // Try creating a new file, if it does not exist.

      if (!link && flagsNum & O_CREAT) {
        // const dirLink: Link = this.getLinkParent(steps);
        var dirLink = this.getResolvedLink(steps.slice(0, steps.length - 1)); // if(!dirLink) throw createError(ENOENT, 'open', filename);

        if (!dirLink) throw createError(ENOENT, \\"open\\", sep + steps.join(sep));

        if (flagsNum & O_CREAT && typeof modeNum === \\"number\\") {
          link = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);
        }
      }

      if (link) return this.openLink(link, flagsNum, resolveSymlinks);
      throw createError(ENOENT, \\"open\\", filename);
    };

    Volume.prototype.openBase = function (filename, flagsNum, modeNum, resolveSymlinks) {
      if (resolveSymlinks === void 0) {
        resolveSymlinks = true;
      }

      var file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);
      if (!file) throw createError(ENOENT, \\"open\\", filename);
      return file.fd;
    };

    Volume.prototype.openSync = function (path, flags, mode) {
      if (mode === void 0) {
        mode = 438
        /* DEFAULT */
        ;
      } // Validate (1) mode; (2) path; (3) flags - in that order.


      var modeNum = modeToNumber(mode);
      var fileName = pathToFilename(path);
      var flagsNum = flagsToNumber(flags);
      return this.openBase(fileName, flagsNum, modeNum);
    };

    Volume.prototype.open = function (path, flags, a, b) {
      var mode = a;
      var callback = b;

      if (typeof a === \\"function\\") {
        mode = 438
        /* DEFAULT */
        ;
        callback = a;
      }

      mode = mode || 438
      /* DEFAULT */
      ;
      var modeNum = modeToNumber(mode);
      var fileName = pathToFilename(path);
      var flagsNum = flagsToNumber(flags);
      this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum], callback);
    };

    Volume.prototype.closeFile = function (file) {
      if (!this.fds[file.fd]) return;
      this.openFiles--;
      delete this.fds[file.fd];
      this.releasedFds.push(file.fd);
    };

    Volume.prototype.closeSync = function (fd) {
      validateFd(fd);
      var file = this.getFileByFdOrThrow(fd, \\"close\\");
      this.closeFile(file);
    };

    Volume.prototype.close = function (fd, callback) {
      validateFd(fd);
      this.wrapAsync(this.closeSync, [fd], callback);
    };

    Volume.prototype.openFileOrGetById = function (id, flagsNum, modeNum) {
      if (typeof id === \\"number\\") {
        var file = this.fds[id];
        if (!file) throw createError(ENOENT);
        return file;
      } else {
        return this.openFile(pathToFilename(id), flagsNum, modeNum);
      }
    };

    Volume.prototype.readBase = function (fd, buffer, offset, length, position) {
      var file = this.getFileByFdOrThrow(fd);
      return file.read(buffer, Number(offset), Number(length), position);
    };

    Volume.prototype.readSync = function (fd, buffer, offset, length, position) {
      validateFd(fd);
      return this.readBase(fd, buffer, offset, length, position);
    };

    Volume.prototype.read = function (fd, buffer, offset, length, position, callback) {
      var _this = this;

      validateCallback(callback); // This \`if\` branch is from Node.js

      if (length === 0) {
        return process_1.default.nextTick(function () {
          if (callback) callback(null, 0, buffer);
        });
      }

      (0, setImmediate_1.default)(function () {
        try {
          var bytes = _this.readBase(fd, buffer, offset, length, position);

          callback(null, bytes, buffer);
        } catch (err) {
          callback(err);
        }
      });
    };

    Volume.prototype.readFileBase = function (id, flagsNum, encoding) {
      var result;
      var isUserFd = typeof id === \\"number\\";
      var userOwnsFd = isUserFd && isFd(id);
      var fd;
      if (userOwnsFd) fd = id;else {
        var filename = pathToFilename(id);
        var steps = filenameToSteps(filename);
        var link = this.getResolvedLink(steps);

        if (link) {
          var node = link.getNode();
          if (node.isDirectory()) throw createError(EISDIR, \\"open\\", link.getPath());
        }

        fd = this.openSync(id, flagsNum);
      }

      try {
        result = bufferToEncoding(this.getFileByFdOrThrow(fd).getBuffer(), encoding);
      } finally {
        if (!userOwnsFd) {
          this.closeSync(fd);
        }
      }

      return result;
    };

    Volume.prototype.readFileSync = function (file, options) {
      var opts = getReadFileOptions(options);
      var flagsNum = flagsToNumber(opts.flag);
      return this.readFileBase(file, flagsNum, opts.encoding);
    };

    Volume.prototype.readFile = function (id, a, b) {
      var _a = optsAndCbGenerator(getReadFileOptions)(a, b),
          opts = _a[0],
          callback = _a[1];

      var flagsNum = flagsToNumber(opts.flag);
      this.wrapAsync(this.readFileBase, [id, flagsNum, opts.encoding], callback);
    };

    Volume.prototype.writeBase = function (fd, buf, offset, length, position) {
      var file = this.getFileByFdOrThrow(fd, \\"write\\");
      return file.write(buf, offset, length, position);
    };

    Volume.prototype.writeSync = function (fd, a, b, c, d) {
      validateFd(fd);
      var encoding;
      var offset;
      var length;
      var position;
      var isBuffer = typeof a !== \\"string\\";

      if (isBuffer) {
        offset = (b || 0) | 0;
        length = c;
        position = d;
      } else {
        position = b;
        encoding = c;
      }

      var buf = dataToBuffer(a, encoding);

      if (isBuffer) {
        if (typeof length === \\"undefined\\") {
          length = buf.length;
        }
      } else {
        offset = 0;
        length = buf.length;
      }

      return this.writeBase(fd, buf, offset, length, position);
    };

    Volume.prototype.write = function (fd, a, b, c, d, e) {
      var _this = this;

      validateFd(fd);
      var offset;
      var length;
      var position;
      var encoding;
      var callback;
      var tipa = typeof a;
      var tipb = typeof b;
      var tipc = typeof c;
      var tipd = typeof d;

      if (tipa !== \\"string\\") {
        if (tipb === \\"function\\") {
          callback = b;
        } else if (tipc === \\"function\\") {
          offset = b | 0;
          callback = c;
        } else if (tipd === \\"function\\") {
          offset = b | 0;
          length = c;
          callback = d;
        } else {
          offset = b | 0;
          length = c;
          position = d;
          callback = e;
        }
      } else {
        if (tipb === \\"function\\") {
          callback = b;
        } else if (tipc === \\"function\\") {
          position = b;
          callback = c;
        } else if (tipd === \\"function\\") {
          position = b;
          encoding = c;
          callback = d;
        }
      }

      var buf = dataToBuffer(a, encoding);

      if (tipa !== \\"string\\") {
        if (typeof length === \\"undefined\\") length = buf.length;
      } else {
        offset = 0;
        length = buf.length;
      }

      var cb = validateCallback(callback);
      (0, setImmediate_1.default)(function () {
        try {
          var bytes = _this.writeBase(fd, buf, offset, length, position);

          if (tipa !== \\"string\\") {
            cb(null, bytes, buf);
          } else {
            cb(null, bytes, a);
          }
        } catch (err) {
          cb(err);
        }
      });
    };

    Volume.prototype.writeFileBase = function (id, buf, flagsNum, modeNum) {
      // console.log('writeFileBase', id, buf, flagsNum, modeNum);
      // const node = this.getNodeByIdOrCreate(id, flagsNum, modeNum);
      // node.setBuffer(buf);
      var isUserFd = typeof id === \\"number\\";
      var fd;
      if (isUserFd) fd = id;else {
        fd = this.openBase(pathToFilename(id), flagsNum, modeNum); // fd = this.openSync(id as PathLike, flagsNum, modeNum);
      }
      var offset = 0;
      var length = buf.length;
      var position = flagsNum & O_APPEND ? undefined : 0;

      try {
        while (length > 0) {
          var written = this.writeSync(fd, buf, offset, length, position);
          offset += written;
          length -= written;
          if (position !== undefined) position += written;
        }
      } finally {
        if (!isUserFd) this.closeSync(fd);
      }
    };

    Volume.prototype.writeFileSync = function (id, data, options) {
      var opts = getWriteFileOptions(options);
      var flagsNum = flagsToNumber(opts.flag);
      var modeNum = modeToNumber(opts.mode);
      var buf = dataToBuffer(data, opts.encoding);
      this.writeFileBase(id, buf, flagsNum, modeNum);
    };

    Volume.prototype.writeFile = function (id, data, a, b) {
      var options = a;
      var callback = b;

      if (typeof a === \\"function\\") {
        options = writeFileDefaults;
        callback = a;
      }

      var cb = validateCallback(callback);
      var opts = getWriteFileOptions(options);
      var flagsNum = flagsToNumber(opts.flag);
      var modeNum = modeToNumber(opts.mode);
      var buf = dataToBuffer(data, opts.encoding);
      this.wrapAsync(this.writeFileBase, [id, buf, flagsNum, modeNum], cb);
    };

    Volume.prototype.linkBase = function (filename1, filename2) {
      var steps1 = filenameToSteps(filename1);
      var link1 = this.getLink(steps1);
      if (!link1) throw createError(ENOENT, \\"link\\", filename1, filename2);
      var steps2 = filenameToSteps(filename2); // Check new link directory exists.

      var dir2 = this.getLinkParent(steps2);
      if (!dir2) throw createError(ENOENT, \\"link\\", filename1, filename2);
      var name = steps2[steps2.length - 1]; // Check if new file already exists.

      if (dir2.getChild(name)) throw createError(EEXIST, \\"link\\", filename1, filename2);
      var node = link1.getNode();
      node.nlink++;
      dir2.createChild(name, node);
    };

    Volume.prototype.copyFileBase = function (src, dest, flags) {
      var buf = this.readFileSync(src);

      if (flags & COPYFILE_EXCL) {
        if (this.existsSync(dest)) {
          throw createError(EEXIST, \\"copyFile\\", src, dest);
        }
      }

      if (flags & COPYFILE_FICLONE_FORCE) {
        throw createError(ENOSYS, \\"copyFile\\", src, dest);
      }

      this.writeFileBase(dest, buf, FLAGS.w, 438
      /* DEFAULT */
      );
    };

    Volume.prototype.copyFileSync = function (src, dest, flags) {
      var srcFilename = pathToFilename(src);
      var destFilename = pathToFilename(dest);
      return this.copyFileBase(srcFilename, destFilename, (flags || 0) | 0);
    };

    Volume.prototype.copyFile = function (src, dest, a, b) {
      var srcFilename = pathToFilename(src);
      var destFilename = pathToFilename(dest);
      var flags;
      var callback;

      if (typeof a === \\"function\\") {
        flags = 0;
        callback = a;
      } else {
        flags = a;
        callback = b;
      }

      validateCallback(callback);
      this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);
    };

    Volume.prototype.linkSync = function (existingPath, newPath) {
      var existingPathFilename = pathToFilename(existingPath);
      var newPathFilename = pathToFilename(newPath);
      this.linkBase(existingPathFilename, newPathFilename);
    };

    Volume.prototype.link = function (existingPath, newPath, callback) {
      var existingPathFilename = pathToFilename(existingPath);
      var newPathFilename = pathToFilename(newPath);
      this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);
    };

    Volume.prototype.unlinkBase = function (filename) {
      var steps = filenameToSteps(filename);
      var link = this.getLink(steps);
      if (!link) throw createError(ENOENT, \\"unlink\\", filename); // TODO: Check if it is file, dir, other...

      if (link.length) throw Error(\\"Dir not empty...\\");
      this.deleteLink(link);
      var node = link.getNode();
      node.nlink--; // When all hard links to i-node are deleted, remove the i-node, too.

      if (node.nlink <= 0) {
        this.deleteNode(node);
      }
    };

    Volume.prototype.unlinkSync = function (path) {
      var filename = pathToFilename(path);
      this.unlinkBase(filename);
    };

    Volume.prototype.unlink = function (path, callback) {
      var filename = pathToFilename(path);
      this.wrapAsync(this.unlinkBase, [filename], callback);
    };

    Volume.prototype.symlinkBase = function (targetFilename, pathFilename) {
      var pathSteps = filenameToSteps(pathFilename); // Check if directory exists, where we about to create a symlink.

      var dirLink = this.getLinkParent(pathSteps);
      if (!dirLink) throw createError(ENOENT, \\"symlink\\", targetFilename, pathFilename);
      var name = pathSteps[pathSteps.length - 1]; // Check if new file already exists.

      if (dirLink.getChild(name)) throw createError(EEXIST, \\"symlink\\", targetFilename, pathFilename); // Create symlink.

      var symlink = dirLink.createChild(name);
      symlink.getNode().makeSymlink(filenameToSteps(targetFilename));
      return symlink;
    }; // \`type\` argument works only on Windows.


    Volume.prototype.symlinkSync = function (target, path, type) {
      var targetFilename = pathToFilename(target);
      var pathFilename = pathToFilename(path);
      this.symlinkBase(targetFilename, pathFilename);
    };

    Volume.prototype.symlink = function (target, path, a, b) {
      var callback = validateCallback(typeof a === \\"function\\" ? a : b);
      var targetFilename = pathToFilename(target);
      var pathFilename = pathToFilename(path);
      this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);
    };

    Volume.prototype.realpathBase = function (filename, encoding) {
      var steps = filenameToSteps(filename);
      var realLink = this.getResolvedLink(steps);
      if (!realLink) throw createError(ENOENT, \\"realpath\\", filename);
      return (0, encoding_1.strToEncoding)(realLink.getPath(), encoding);
    };

    Volume.prototype.realpathSync = function (path, options) {
      return this.realpathBase(pathToFilename(path), getRealpathOptions(options).encoding);
    };

    Volume.prototype.realpath = function (path, a, b) {
      var _a = getRealpathOptsAndCb(a, b),
          opts = _a[0],
          callback = _a[1];

      var pathFilename = pathToFilename(path);
      this.wrapAsync(this.realpathBase, [pathFilename, opts.encoding], callback);
    };

    Volume.prototype.lstatBase = function (filename, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }

      var link = this.getLink(filenameToSteps(filename));
      if (!link) throw createError(ENOENT, \\"lstat\\", filename);
      return Stats_1.default.build(link.getNode(), bigint);
    };

    Volume.prototype.lstatSync = function (path, options) {
      return this.lstatBase(pathToFilename(path), getStatOptions(options).bigint);
    };

    Volume.prototype.lstat = function (path, a, b) {
      var _a = getStatOptsAndCb(a, b),
          opts = _a[0],
          callback = _a[1];

      this.wrapAsync(this.lstatBase, [pathToFilename(path), opts.bigint], callback);
    };

    Volume.prototype.statBase = function (filename, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }

      var link = this.getResolvedLink(filenameToSteps(filename));
      if (!link) throw createError(ENOENT, \\"stat\\", filename);
      return Stats_1.default.build(link.getNode(), bigint);
    };

    Volume.prototype.statSync = function (path, options) {
      return this.statBase(pathToFilename(path), getStatOptions(options).bigint);
    };

    Volume.prototype.stat = function (path, a, b) {
      var _a = getStatOptsAndCb(a, b),
          opts = _a[0],
          callback = _a[1];

      this.wrapAsync(this.statBase, [pathToFilename(path), opts.bigint], callback);
    };

    Volume.prototype.fstatBase = function (fd, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }

      var file = this.getFileByFd(fd);
      if (!file) throw createError(EBADF, \\"fstat\\");
      return Stats_1.default.build(file.node, bigint);
    };

    Volume.prototype.fstatSync = function (fd, options) {
      return this.fstatBase(fd, getStatOptions(options).bigint);
    };

    Volume.prototype.fstat = function (fd, a, b) {
      var _a = getStatOptsAndCb(a, b),
          opts = _a[0],
          callback = _a[1];

      this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);
    };

    Volume.prototype.renameBase = function (oldPathFilename, newPathFilename) {
      var link = this.getLink(filenameToSteps(oldPathFilename));
      if (!link) throw createError(ENOENT, \\"rename\\", oldPathFilename, newPathFilename); // TODO: Check if it is directory, if non-empty, we cannot move it, right?

      var newPathSteps = filenameToSteps(newPathFilename); // Check directory exists for the new location.

      var newPathDirLink = this.getLinkParent(newPathSteps);
      if (!newPathDirLink) throw createError(ENOENT, \\"rename\\", oldPathFilename, newPathFilename); // TODO: Also treat cases with directories and symbolic links.
      // TODO: See: http://man7.org/linux/man-pages/man2/rename.2.html
      // Remove hard link from old folder.

      var oldLinkParent = link.parent;

      if (oldLinkParent) {
        oldLinkParent.deleteChild(link);
      } // Rename should overwrite the new path, if that exists.


      var name = newPathSteps[newPathSteps.length - 1];
      link.steps = __spreadArray(__spreadArray([], newPathDirLink.steps, true), [name], false);
      newPathDirLink.setChild(link.getName(), link);
    };

    Volume.prototype.renameSync = function (oldPath, newPath) {
      var oldPathFilename = pathToFilename(oldPath);
      var newPathFilename = pathToFilename(newPath);
      this.renameBase(oldPathFilename, newPathFilename);
    };

    Volume.prototype.rename = function (oldPath, newPath, callback) {
      var oldPathFilename = pathToFilename(oldPath);
      var newPathFilename = pathToFilename(newPath);
      this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);
    };

    Volume.prototype.existsBase = function (filename) {
      return !!this.statBase(filename);
    };

    Volume.prototype.existsSync = function (path) {
      try {
        return this.existsBase(pathToFilename(path));
      } catch (err) {
        return false;
      }
    };

    Volume.prototype.exists = function (path, callback) {
      var _this = this;

      var filename = pathToFilename(path);
      if (typeof callback !== \\"function\\") throw Error(ERRSTR.CB);
      (0, setImmediate_1.default)(function () {
        try {
          callback(_this.existsBase(filename));
        } catch (err) {
          callback(false);
        }
      });
    };

    Volume.prototype.accessBase = function (filename, mode) {
      this.getLinkOrThrow(filename, \\"access\\"); // TODO: Verify permissions
    };

    Volume.prototype.accessSync = function (path, mode) {
      if (mode === void 0) {
        mode = F_OK;
      }

      var filename = pathToFilename(path);
      mode = mode | 0;
      this.accessBase(filename, mode);
    };

    Volume.prototype.access = function (path, a, b) {
      var mode = F_OK;
      var callback;

      if (typeof a !== \\"function\\") {
        mode = a | 0; // cast to number

        callback = validateCallback(b);
      } else {
        callback = a;
      }

      var filename = pathToFilename(path);
      this.wrapAsync(this.accessBase, [filename, mode], callback);
    };

    Volume.prototype.appendFileSync = function (id, data, options) {
      if (options === void 0) {
        options = appendFileDefaults;
      }

      var opts = getAppendFileOpts(options); // force append behavior when using a supplied file descriptor

      if (!opts.flag || isFd(id)) opts.flag = \\"a\\";
      this.writeFileSync(id, data, opts);
    };

    Volume.prototype.appendFile = function (id, data, a, b) {
      var _a = getAppendFileOptsAndCb(a, b),
          opts = _a[0],
          callback = _a[1]; // force append behavior when using a supplied file descriptor


      if (!opts.flag || isFd(id)) opts.flag = \\"a\\";
      this.writeFile(id, data, opts, callback);
    };

    Volume.prototype.readdirBase = function (filename, options) {
      var steps = filenameToSteps(filename);
      var link = this.getResolvedLink(steps);
      if (!link) throw createError(ENOENT, \\"readdir\\", filename);
      var node = link.getNode();
      if (!node.isDirectory()) throw createError(ENOTDIR, \\"scandir\\", filename);

      if (options.withFileTypes) {
        var list_1 = [];

        for (var name_3 in link.children) {
          var child = link.getChild(name_3);

          if (!child) {
            continue;
          }

          list_1.push(Dirent_1.default.build(child, options.encoding));
        }

        if (!isWin && options.encoding !== \\"buffer\\") list_1.sort(function (a, b) {
          if (a.name < b.name) return -1;
          if (a.name > b.name) return 1;
          return 0;
        });
        return list_1;
      }

      var list = [];

      for (var name_4 in link.children) {
        list.push((0, encoding_1.strToEncoding)(name_4, options.encoding));
      }

      if (!isWin && options.encoding !== \\"buffer\\") list.sort();
      return list;
    };

    Volume.prototype.readdirSync = function (path, options) {
      var opts = getReaddirOptions(options);
      var filename = pathToFilename(path);
      return this.readdirBase(filename, opts);
    };

    Volume.prototype.readdir = function (path, a, b) {
      var _a = getReaddirOptsAndCb(a, b),
          options = _a[0],
          callback = _a[1];

      var filename = pathToFilename(path);
      this.wrapAsync(this.readdirBase, [filename, options], callback);
    };

    Volume.prototype.readlinkBase = function (filename, encoding) {
      var link = this.getLinkOrThrow(filename, \\"readlink\\");
      var node = link.getNode();
      if (!node.isSymlink()) throw createError(EINVAL, \\"readlink\\", filename);
      var str = sep + node.symlink.join(sep);
      return (0, encoding_1.strToEncoding)(str, encoding);
    };

    Volume.prototype.readlinkSync = function (path, options) {
      var opts = getDefaultOpts(options);
      var filename = pathToFilename(path);
      return this.readlinkBase(filename, opts.encoding);
    };

    Volume.prototype.readlink = function (path, a, b) {
      var _a = getDefaultOptsAndCb(a, b),
          opts = _a[0],
          callback = _a[1];

      var filename = pathToFilename(path);
      this.wrapAsync(this.readlinkBase, [filename, opts.encoding], callback);
    };

    Volume.prototype.fsyncBase = function (fd) {
      this.getFileByFdOrThrow(fd, \\"fsync\\");
    };

    Volume.prototype.fsyncSync = function (fd) {
      this.fsyncBase(fd);
    };

    Volume.prototype.fsync = function (fd, callback) {
      this.wrapAsync(this.fsyncBase, [fd], callback);
    };

    Volume.prototype.fdatasyncBase = function (fd) {
      this.getFileByFdOrThrow(fd, \\"fdatasync\\");
    };

    Volume.prototype.fdatasyncSync = function (fd) {
      this.fdatasyncBase(fd);
    };

    Volume.prototype.fdatasync = function (fd, callback) {
      this.wrapAsync(this.fdatasyncBase, [fd], callback);
    };

    Volume.prototype.ftruncateBase = function (fd, len) {
      var file = this.getFileByFdOrThrow(fd, \\"ftruncate\\");
      file.truncate(len);
    };

    Volume.prototype.ftruncateSync = function (fd, len) {
      this.ftruncateBase(fd, len);
    };

    Volume.prototype.ftruncate = function (fd, a, b) {
      var len = typeof a === \\"number\\" ? a : 0;
      var callback = validateCallback(typeof a === \\"number\\" ? b : a);
      this.wrapAsync(this.ftruncateBase, [fd, len], callback);
    };

    Volume.prototype.truncateBase = function (path, len) {
      var fd = this.openSync(path, \\"r+\\");

      try {
        this.ftruncateSync(fd, len);
      } finally {
        this.closeSync(fd);
      }
    };

    Volume.prototype.truncateSync = function (id, len) {
      if (isFd(id)) return this.ftruncateSync(id, len);
      this.truncateBase(id, len);
    };

    Volume.prototype.truncate = function (id, a, b) {
      var len = typeof a === \\"number\\" ? a : 0;
      var callback = validateCallback(typeof a === \\"number\\" ? b : a);
      if (isFd(id)) return this.ftruncate(id, len, callback);
      this.wrapAsync(this.truncateBase, [id, len], callback);
    };

    Volume.prototype.futimesBase = function (fd, atime, mtime) {
      var file = this.getFileByFdOrThrow(fd, \\"futimes\\");
      var node = file.node;
      node.atime = new Date(atime * 1000);
      node.mtime = new Date(mtime * 1000);
    };

    Volume.prototype.futimesSync = function (fd, atime, mtime) {
      this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));
    };

    Volume.prototype.futimes = function (fd, atime, mtime, callback) {
      this.wrapAsync(this.futimesBase, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
    };

    Volume.prototype.utimesBase = function (filename, atime, mtime) {
      var fd = this.openSync(filename, \\"r+\\");

      try {
        this.futimesBase(fd, atime, mtime);
      } finally {
        this.closeSync(fd);
      }
    };

    Volume.prototype.utimesSync = function (path, atime, mtime) {
      this.utimesBase(pathToFilename(path), toUnixTimestamp(atime), toUnixTimestamp(mtime));
    };

    Volume.prototype.utimes = function (path, atime, mtime, callback) {
      this.wrapAsync(this.utimesBase, [pathToFilename(path), toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
    };

    Volume.prototype.mkdirBase = function (filename, modeNum) {
      var steps = filenameToSteps(filename); // This will throw if user tries to create root dir \`fs.mkdirSync('/')\`.

      if (!steps.length) {
        throw createError(EEXIST, \\"mkdir\\", filename);
      }

      var dir = this.getLinkParentAsDirOrThrow(filename, \\"mkdir\\"); // Check path already exists.

      var name = steps[steps.length - 1];
      if (dir.getChild(name)) throw createError(EEXIST, \\"mkdir\\", filename);
      dir.createChild(name, this.createNode(true, modeNum));
    };
    /**
     * Creates directory tree recursively.
     * @param filename
     * @param modeNum
     */


    Volume.prototype.mkdirpBase = function (filename, modeNum) {
      var steps = filenameToSteps(filename);
      var link = this.root;

      for (var i = 0; i < steps.length; i++) {
        var step = steps[i];
        if (!link.getNode().isDirectory()) throw createError(ENOTDIR, \\"mkdir\\", link.getPath());
        var child = link.getChild(step);

        if (child) {
          if (child.getNode().isDirectory()) link = child;else throw createError(ENOTDIR, \\"mkdir\\", child.getPath());
        } else {
          link = link.createChild(step, this.createNode(true, modeNum));
        }
      }
    };

    Volume.prototype.mkdirSync = function (path, options) {
      var opts = getMkdirOptions(options);
      var modeNum = modeToNumber(opts.mode, 511);
      var filename = pathToFilename(path);
      if (opts.recursive) this.mkdirpBase(filename, modeNum);else this.mkdirBase(filename, modeNum);
    };

    Volume.prototype.mkdir = function (path, a, b) {
      var opts = getMkdirOptions(a);
      var callback = validateCallback(typeof a === \\"function\\" ? a : b);
      var modeNum = modeToNumber(opts.mode, 511);
      var filename = pathToFilename(path);
      if (opts.recursive) this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);else this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);
    }; // legacy interface


    Volume.prototype.mkdirpSync = function (path, mode) {
      this.mkdirSync(path, {
        mode: mode,
        recursive: true
      });
    };

    Volume.prototype.mkdirp = function (path, a, b) {
      var mode = typeof a === \\"function\\" ? undefined : a;
      var callback = validateCallback(typeof a === \\"function\\" ? a : b);
      this.mkdir(path, {
        mode: mode,
        recursive: true
      }, callback);
    };

    Volume.prototype.mkdtempBase = function (prefix, encoding, retry) {
      if (retry === void 0) {
        retry = 5;
      }

      var filename = prefix + this.genRndStr();

      try {
        this.mkdirBase(filename, 511
        /* DIR */
        );
        return (0, encoding_1.strToEncoding)(filename, encoding);
      } catch (err) {
        if (err.code === EEXIST) {
          if (retry > 1) return this.mkdtempBase(prefix, encoding, retry - 1);else throw Error(\\"Could not create temp dir.\\");
        } else throw err;
      }
    };

    Volume.prototype.mkdtempSync = function (prefix, options) {
      var encoding = getDefaultOpts(options).encoding;
      if (!prefix || typeof prefix !== \\"string\\") throw new TypeError(\\"filename prefix is required\\");
      nullCheck(prefix);
      return this.mkdtempBase(prefix, encoding);
    };

    Volume.prototype.mkdtemp = function (prefix, a, b) {
      var _a = getDefaultOptsAndCb(a, b),
          encoding = _a[0].encoding,
          callback = _a[1];

      if (!prefix || typeof prefix !== \\"string\\") throw new TypeError(\\"filename prefix is required\\");
      if (!nullCheck(prefix)) return;
      this.wrapAsync(this.mkdtempBase, [prefix, encoding], callback);
    };

    Volume.prototype.rmdirBase = function (filename, options) {
      var opts = getRmdirOptions(options);
      var link = this.getLinkAsDirOrThrow(filename, \\"rmdir\\"); // Check directory is empty.

      if (link.length && !opts.recursive) throw createError(ENOTEMPTY, \\"rmdir\\", filename);
      this.deleteLink(link);
    };

    Volume.prototype.rmdirSync = function (path, options) {
      this.rmdirBase(pathToFilename(path), options);
    };

    Volume.prototype.rmdir = function (path, a, b) {
      var opts = getRmdirOptions(a);
      var callback = validateCallback(typeof a === \\"function\\" ? a : b);
      this.wrapAsync(this.rmdirBase, [pathToFilename(path), opts], callback);
    };

    Volume.prototype.fchmodBase = function (fd, modeNum) {
      var file = this.getFileByFdOrThrow(fd, \\"fchmod\\");
      file.chmod(modeNum);
    };

    Volume.prototype.fchmodSync = function (fd, mode) {
      this.fchmodBase(fd, modeToNumber(mode));
    };

    Volume.prototype.fchmod = function (fd, mode, callback) {
      this.wrapAsync(this.fchmodBase, [fd, modeToNumber(mode)], callback);
    };

    Volume.prototype.chmodBase = function (filename, modeNum) {
      var fd = this.openSync(filename, \\"r+\\");

      try {
        this.fchmodBase(fd, modeNum);
      } finally {
        this.closeSync(fd);
      }
    };

    Volume.prototype.chmodSync = function (path, mode) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path);
      this.chmodBase(filename, modeNum);
    };

    Volume.prototype.chmod = function (path, mode, callback) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path);
      this.wrapAsync(this.chmodBase, [filename, modeNum], callback);
    };

    Volume.prototype.lchmodBase = function (filename, modeNum) {
      var fd = this.openBase(filename, O_RDWR, 0, false);

      try {
        this.fchmodBase(fd, modeNum);
      } finally {
        this.closeSync(fd);
      }
    };

    Volume.prototype.lchmodSync = function (path, mode) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path);
      this.lchmodBase(filename, modeNum);
    };

    Volume.prototype.lchmod = function (path, mode, callback) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path);
      this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);
    };

    Volume.prototype.fchownBase = function (fd, uid, gid) {
      this.getFileByFdOrThrow(fd, \\"fchown\\").chown(uid, gid);
    };

    Volume.prototype.fchownSync = function (fd, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.fchownBase(fd, uid, gid);
    };

    Volume.prototype.fchown = function (fd, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);
    };

    Volume.prototype.chownBase = function (filename, uid, gid) {
      var link = this.getResolvedLinkOrThrow(filename, \\"chown\\");
      var node = link.getNode();
      node.chown(uid, gid); // if(node.isFile() || node.isSymlink()) {
      //
      // } else if(node.isDirectory()) {
      //
      // } else {
      // TODO: What do we do here?
      // }
    };

    Volume.prototype.chownSync = function (path, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.chownBase(pathToFilename(path), uid, gid);
    };

    Volume.prototype.chown = function (path, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.chownBase, [pathToFilename(path), uid, gid], callback);
    };

    Volume.prototype.lchownBase = function (filename, uid, gid) {
      this.getLinkOrThrow(filename, \\"lchown\\").getNode().chown(uid, gid);
    };

    Volume.prototype.lchownSync = function (path, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.lchownBase(pathToFilename(path), uid, gid);
    };

    Volume.prototype.lchown = function (path, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.lchownBase, [pathToFilename(path), uid, gid], callback);
    };

    Volume.prototype.watchFile = function (path, a, b) {
      var filename = pathToFilename(path);
      var options = a;
      var listener = b;

      if (typeof options === \\"function\\") {
        listener = a;
        options = null;
      }

      if (typeof listener !== \\"function\\") {
        throw Error(\\"\\\\\\"watchFile()\\\\\\" requires a listener function\\");
      }

      var interval = 5007;
      var persistent = true;

      if (options && typeof options === \\"object\\") {
        if (typeof options.interval === \\"number\\") interval = options.interval;
        if (typeof options.persistent === \\"boolean\\") persistent = options.persistent;
      }

      var watcher = this.statWatchers[filename];

      if (!watcher) {
        watcher = new this.StatWatcher();
        watcher.start(filename, persistent, interval);
        this.statWatchers[filename] = watcher;
      }

      watcher.addListener(\\"change\\", listener);
      return watcher;
    };

    Volume.prototype.unwatchFile = function (path, listener) {
      var filename = pathToFilename(path);
      var watcher = this.statWatchers[filename];
      if (!watcher) return;

      if (typeof listener === \\"function\\") {
        watcher.removeListener(\\"change\\", listener);
      } else {
        watcher.removeAllListeners(\\"change\\");
      }

      if (watcher.listenerCount(\\"change\\") === 0) {
        watcher.stop();
        delete this.statWatchers[filename];
      }
    };

    Volume.prototype.createReadStream = function (path, options) {
      return new this.ReadStream(path, options);
    };

    Volume.prototype.createWriteStream = function (path, options) {
      return new this.WriteStream(path, options);
    }; // watch(path: PathLike): FSWatcher;
    // watch(path: PathLike, options?: IWatchOptions | string): FSWatcher;


    Volume.prototype.watch = function (path, options, listener) {
      var filename = pathToFilename(path);
      var givenOptions = options;

      if (typeof options === \\"function\\") {
        listener = options;
        givenOptions = null;
      } // tslint:disable-next-line prefer-const


      var _a = getDefaultOpts(givenOptions),
          persistent = _a.persistent,
          recursive = _a.recursive,
          encoding = _a.encoding;

      if (persistent === undefined) persistent = true;
      if (recursive === undefined) recursive = false;
      var watcher = new this.FSWatcher();
      watcher.start(filename, persistent, recursive, encoding);

      if (listener) {
        watcher.addListener(\\"change\\", listener);
      }

      return watcher;
    };
    /**
     * Global file descriptor counter. UNIX file descriptors start from 0 and go sequentially
     * up, so here, in order not to conflict with them, we choose some big number and descrease
     * the file descriptor of every new opened file.
     * @type {number}
     * @todo This should not be static, right?
     */


    Volume.fd = 2147483647;
    return Volume;
  }();

  exports$4.Volume = Volume;

  function emitStop(self) {
    self.emit(\\"stop\\");
  }

  var StatWatcher = function (_super) {
    __extends(StatWatcher, _super);

    function StatWatcher(vol) {
      var _this = _super.call(this) || this;

      _this.onInterval = function () {
        try {
          var stats = _this.vol.statSync(_this.filename);

          if (_this.hasChanged(stats)) {
            _this.emit(\\"change\\", stats, _this.prev);

            _this.prev = stats;
          }
        } finally {
          _this.loop();
        }
      };

      _this.vol = vol;
      return _this;
    }

    StatWatcher.prototype.loop = function () {
      this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
    };

    StatWatcher.prototype.hasChanged = function (stats) {
      // if(!this.prev) return false;
      if (stats.mtimeMs > this.prev.mtimeMs) return true;
      if (stats.nlink !== this.prev.nlink) return true;
      return false;
    };

    StatWatcher.prototype.start = function (path, persistent, interval) {
      if (persistent === void 0) {
        persistent = true;
      }

      if (interval === void 0) {
        interval = 5007;
      }

      this.filename = pathToFilename(path);
      this.setTimeout = persistent ? setTimeout.bind(typeof globalThis !== \\"undefined\\" ? globalThis : _global) : setTimeoutUnref_1.default;
      this.interval = interval;
      this.prev = this.vol.statSync(this.filename);
      this.loop();
    };

    StatWatcher.prototype.stop = function () {
      clearTimeout(this.timeoutRef);
      process_1.default.nextTick(emitStop, this);
    };

    return StatWatcher;
  }(events_1.EventEmitter);

  exports$4.StatWatcher = StatWatcher;
  var pool;

  function allocNewPool(poolSize) {
    pool = (0, buffer_1.bufferAllocUnsafe)(poolSize);
    pool.used = 0;
  }

  util.inherits(FsReadStream, stream_1.Readable);
  exports$4.ReadStream = FsReadStream;

  function FsReadStream(vol, path, options) {
    if (!(this instanceof FsReadStream)) return new FsReadStream(vol, path, options);
    this._vol = vol; // a little bit bigger buffer and water marks by default

    options = Object.assign({}, getOptions(options, {}));
    if (options.highWaterMark === undefined) options.highWaterMark = 64 * 1024;
    stream_1.Readable.call(this, options);
    this.path = pathToFilename(path);
    this.fd = options.fd === undefined ? null : options.fd;
    this.flags = options.flags === undefined ? \\"r\\" : options.flags;
    this.mode = options.mode === undefined ? 438 : options.mode;
    this.start = options.start;
    this.end = options.end;
    this.autoClose = options.autoClose === undefined ? true : options.autoClose;
    this.pos = undefined;
    this.bytesRead = 0;

    if (this.start !== undefined) {
      if (typeof this.start !== \\"number\\") {
        throw new TypeError(\\"\\\\\\"start\\\\\\" option must be a Number\\");
      }

      if (this.end === undefined) {
        this.end = Infinity;
      } else if (typeof this.end !== \\"number\\") {
        throw new TypeError(\\"\\\\\\"end\\\\\\" option must be a Number\\");
      }

      if (this.start > this.end) {
        throw new Error(\\"\\\\\\"start\\\\\\" option must be <= \\\\\\"end\\\\\\" option\\");
      }

      this.pos = this.start;
    }

    if (typeof this.fd !== \\"number\\") this.open();
    this.on(\\"end\\", function () {
      if (this.autoClose) {
        if (this.destroy) this.destroy();
      }
    });
  }

  FsReadStream.prototype.open = function () {
    var self = this; // tslint:disable-line no-this-assignment

    this._vol.open(this.path, this.flags, this.mode, function (er, fd) {
      if (er) {
        if (self.autoClose) {
          if (self.destroy) self.destroy();
        }

        self.emit(\\"error\\", er);
        return;
      }

      self.fd = fd;
      self.emit(\\"open\\", fd); // start the flow of data.

      self.read();
    });
  };

  FsReadStream.prototype._read = function (n) {
    if (typeof this.fd !== \\"number\\") {
      return this.once(\\"open\\", function () {
        this._read(n);
      });
    }

    if (this.destroyed) return;

    if (!pool || pool.length - pool.used < kMinPoolSpace) {
      // discard the old pool.
      allocNewPool(this._readableState.highWaterMark);
    } // Grab another reference to the pool in the case that while we're
    // in the thread pool another read() finishes up the pool, and
    // allocates a new one.


    var thisPool = pool;
    var toRead = Math.min(pool.length - pool.used, n);
    var start = pool.used;
    if (this.pos !== undefined) toRead = Math.min(this.end - this.pos + 1, toRead); // already read everything we were supposed to read!
    // treat as EOF.

    if (toRead <= 0) return this.push(null); // the actual read.

    var self = this; // tslint:disable-line no-this-assignment

    this._vol.read(this.fd, pool, pool.used, toRead, this.pos, onread); // move the pool positions, and internal position for reading.


    if (this.pos !== undefined) this.pos += toRead;
    pool.used += toRead;

    function onread(er, bytesRead) {
      if (er) {
        if (self.autoClose && self.destroy) {
          self.destroy();
        }

        self.emit(\\"error\\", er);
      } else {
        var b = null;

        if (bytesRead > 0) {
          self.bytesRead += bytesRead;
          b = thisPool.slice(start, start + bytesRead);
        }

        self.push(b);
      }
    }
  };

  FsReadStream.prototype._destroy = function (err, cb) {
    this.close(function (err2) {
      cb(err || err2);
    });
  };

  FsReadStream.prototype.close = function (cb) {
    var _this = this;

    if (cb) this.once(\\"close\\", cb);

    if (this.closed || typeof this.fd !== \\"number\\") {
      if (typeof this.fd !== \\"number\\") {
        this.once(\\"open\\", closeOnOpen);
        return;
      }

      return process_1.default.nextTick(function () {
        return _this.emit(\\"close\\");
      });
    }

    this.closed = true;

    this._vol.close(this.fd, function (er) {
      if (er) _this.emit(\\"error\\", er);else _this.emit(\\"close\\");
    });

    this.fd = null;
  }; // needed because as it will be called with arguments
  // that does not match this.close() signature


  function closeOnOpen(fd) {
    this.close();
  }

  util.inherits(FsWriteStream, stream_1.Writable);
  exports$4.WriteStream = FsWriteStream;

  function FsWriteStream(vol, path, options) {
    if (!(this instanceof FsWriteStream)) return new FsWriteStream(vol, path, options);
    this._vol = vol;
    options = Object.assign({}, getOptions(options, {}));
    stream_1.Writable.call(this, options);
    this.path = pathToFilename(path);
    this.fd = options.fd === undefined ? null : options.fd;
    this.flags = options.flags === undefined ? \\"w\\" : options.flags;
    this.mode = options.mode === undefined ? 438 : options.mode;
    this.start = options.start;
    this.autoClose = options.autoClose === undefined ? true : !!options.autoClose;
    this.pos = undefined;
    this.bytesWritten = 0;

    if (this.start !== undefined) {
      if (typeof this.start !== \\"number\\") {
        throw new TypeError(\\"\\\\\\"start\\\\\\" option must be a Number\\");
      }

      if (this.start < 0) {
        throw new Error(\\"\\\\\\"start\\\\\\" must be >= zero\\");
      }

      this.pos = this.start;
    }

    if (options.encoding) this.setDefaultEncoding(options.encoding);
    if (typeof this.fd !== \\"number\\") this.open(); // dispose on finish.

    this.once(\\"finish\\", function () {
      if (this.autoClose) {
        this.close();
      }
    });
  }

  FsWriteStream.prototype.open = function () {
    this._vol.open(this.path, this.flags, this.mode, function (er, fd) {
      if (er) {
        if (this.autoClose && this.destroy) {
          this.destroy();
        }

        this.emit(\\"error\\", er);
        return;
      }

      this.fd = fd;
      this.emit(\\"open\\", fd);
    }.bind(this));
  };

  FsWriteStream.prototype._write = function (data, encoding, cb) {
    if (!(data instanceof buffer_1.Buffer)) return this.emit(\\"error\\", new Error(\\"Invalid data\\"));

    if (typeof this.fd !== \\"number\\") {
      return this.once(\\"open\\", function () {
        this._write(data, encoding, cb);
      });
    }

    var self = this; // tslint:disable-line no-this-assignment

    this._vol.write(this.fd, data, 0, data.length, this.pos, function (er, bytes) {
      if (er) {
        if (self.autoClose && self.destroy) {
          self.destroy();
        }

        return cb(er);
      }

      self.bytesWritten += bytes;
      cb();
    });

    if (this.pos !== undefined) this.pos += data.length;
  };

  FsWriteStream.prototype._writev = function (data, cb) {
    if (typeof this.fd !== \\"number\\") {
      return this.once(\\"open\\", function () {
        this._writev(data, cb);
      });
    }

    var self = this; // tslint:disable-line no-this-assignment

    var len = data.length;
    var chunks = new Array(len);
    var size = 0;

    for (var i = 0; i < len; i++) {
      var chunk = data[i].chunk;
      chunks[i] = chunk;
      size += chunk.length;
    }

    var buf = buffer_1.Buffer.concat(chunks);

    this._vol.write(this.fd, buf, 0, buf.length, this.pos, function (er, bytes) {
      if (er) {
        if (self.destroy) self.destroy();
        return cb(er);
      }

      self.bytesWritten += bytes;
      cb();
    });

    if (this.pos !== undefined) this.pos += size;
  };

  FsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;
  FsWriteStream.prototype.close = FsReadStream.prototype.close; // There is no shutdown() for files.

  FsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end; // ---------------------------------------- FSWatcher

  var FSWatcher = function (_super) {
    __extends(FSWatcher, _super);

    function FSWatcher(vol) {
      var _this = _super.call(this) || this;

      _this._filename = \\"\\";
      _this._filenameEncoded = \\"\\"; // _persistent: boolean = true;

      _this._recursive = false;
      _this._encoding = encoding_1.ENCODING_UTF8;

      _this._onNodeChange = function () {
        _this._emit(\\"change\\");
      };

      _this._onParentChild = function (link) {
        if (link.getName() === _this._getName()) {
          _this._emit(\\"rename\\");
        }
      };

      _this._emit = function (type) {
        _this.emit(\\"change\\", type, _this._filenameEncoded);
      };

      _this._persist = function () {
        _this._timer = setTimeout(_this._persist, 1000000);
      };

      _this._vol = vol;
      return _this; // TODO: Emit \\"error\\" messages when watching.
      // this._handle.onchange = function(status, eventType, filename) {
      //     if (status < 0) {
      //         self._handle.close();
      //         const error = !filename ?
      //             errnoException(status, 'Error watching file for changes:') :
      //             errnoException(status, \`Error watching file \${filename} for changes:\`);
      //         error.filename = filename;
      //         self.emit('error', error);
      //     } else {
      //         self.emit('change', eventType, filename);
      //     }
      // };
    }

    FSWatcher.prototype._getName = function () {
      return this._steps[this._steps.length - 1];
    };

    FSWatcher.prototype.start = function (path, persistent, recursive, encoding) {
      if (persistent === void 0) {
        persistent = true;
      }

      if (recursive === void 0) {
        recursive = false;
      }

      if (encoding === void 0) {
        encoding = encoding_1.ENCODING_UTF8;
      }

      this._filename = pathToFilename(path);
      this._steps = filenameToSteps(this._filename);
      this._filenameEncoded = (0, encoding_1.strToEncoding)(this._filename); // this._persistent = persistent;

      this._recursive = recursive;
      this._encoding = encoding;

      try {
        this._link = this._vol.getLinkOrThrow(this._filename, \\"FSWatcher\\");
      } catch (err) {
        var error = new Error(\\"watch \\" + this._filename + \\" \\" + err.code);
        error.code = err.code;
        error.errno = err.code;
        throw error;
      }

      this._link.getNode().on(\\"change\\", this._onNodeChange);

      this._link.on(\\"child:add\\", this._onNodeChange);

      this._link.on(\\"child:delete\\", this._onNodeChange);

      var parent = this._link.parent;

      if (parent) {
        // parent.on('child:add', this._onParentChild);
        parent.setMaxListeners(parent.getMaxListeners() + 1);
        parent.on(\\"child:delete\\", this._onParentChild);
      }

      if (persistent) this._persist();
    };

    FSWatcher.prototype.close = function () {
      clearTimeout(this._timer);

      this._link.getNode().removeListener(\\"change\\", this._onNodeChange);

      var parent = this._link.parent;

      if (parent) {
        // parent.removeListener('child:add', this._onParentChild);
        parent.removeListener(\\"child:delete\\", this._onParentChild);
      }
    };

    return FSWatcher;
  }(events_1.EventEmitter);

  exports$4.FSWatcher = FSWatcher;
  return exports$4;
}

var exports$3 = {},
    _dewExec$1 = false;
function dew$1() {
  if (_dewExec$1) return exports$3;
  _dewExec$1 = true;
  Object.defineProperty(exports$3, \\"__esModule\\", {
    value: true
  });
  exports$3.fsAsyncMethods = exports$3.fsSyncMethods = exports$3.fsProps = void 0;
  var fsProps = [\\"constants\\", \\"F_OK\\", \\"R_OK\\", \\"W_OK\\", \\"X_OK\\", \\"Stats\\"];
  exports$3.fsProps = fsProps;
  var fsSyncMethods = [\\"renameSync\\", \\"ftruncateSync\\", \\"truncateSync\\", \\"chownSync\\", \\"fchownSync\\", \\"lchownSync\\", \\"chmodSync\\", \\"fchmodSync\\", \\"lchmodSync\\", \\"statSync\\", \\"lstatSync\\", \\"fstatSync\\", \\"linkSync\\", \\"symlinkSync\\", \\"readlinkSync\\", \\"realpathSync\\", \\"unlinkSync\\", \\"rmdirSync\\", \\"mkdirSync\\", \\"mkdirpSync\\", \\"readdirSync\\", \\"closeSync\\", \\"openSync\\", \\"utimesSync\\", \\"futimesSync\\", \\"fsyncSync\\", \\"writeSync\\", \\"readSync\\", \\"readFileSync\\", \\"writeFileSync\\", \\"appendFileSync\\", \\"existsSync\\", \\"accessSync\\", \\"fdatasyncSync\\", \\"mkdtempSync\\", \\"copyFileSync\\", \\"createReadStream\\", \\"createWriteStream\\"];
  exports$3.fsSyncMethods = fsSyncMethods;
  var fsAsyncMethods = [\\"rename\\", \\"ftruncate\\", \\"truncate\\", \\"chown\\", \\"fchown\\", \\"lchown\\", \\"chmod\\", \\"fchmod\\", \\"lchmod\\", \\"stat\\", \\"lstat\\", \\"fstat\\", \\"link\\", \\"symlink\\", \\"readlink\\", \\"realpath\\", \\"unlink\\", \\"rmdir\\", \\"mkdir\\", \\"mkdirp\\", \\"readdir\\", \\"close\\", \\"open\\", \\"utimes\\", \\"futimes\\", \\"fsync\\", \\"write\\", \\"read\\", \\"readFile\\", \\"writeFile\\", \\"appendFile\\", \\"exists\\", \\"access\\", \\"fdatasync\\", \\"mkdtemp\\", \\"copyFile\\", \\"watchFile\\", \\"unwatchFile\\", \\"watch\\"];
  exports$3.fsAsyncMethods = fsAsyncMethods;
  return exports$3;
}

var exports$2 = {},
    _dewExec = false;
function dew() {
  if (_dewExec) return exports$2;
  _dewExec = true;

  var __assign = exports$2 && exports$2.__assign || function () {
    __assign = Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }

      return t;
    };

    return __assign.apply(this, arguments);
  };

  Object.defineProperty(exports$2, \\"__esModule\\", {
    value: true
  });
  exports$2.fs = exports$2.createFsFromVolume = exports$2.vol = exports$2.Volume = void 0;

  var Stats_1 = dew$d();

  var Dirent_1 = dew$9();

  var volume_1 = dew$2();

  var _a = dew$1(),
      fsSyncMethods = _a.fsSyncMethods,
      fsAsyncMethods = _a.fsAsyncMethods;

  var constants_1 = dew$f();

  var F_OK = constants_1.constants.F_OK,
      R_OK = constants_1.constants.R_OK,
      W_OK = constants_1.constants.W_OK,
      X_OK = constants_1.constants.X_OK;
  exports$2.Volume = volume_1.Volume; // Default volume.

  exports$2.vol = new volume_1.Volume();

  function createFsFromVolume(vol) {
    var fs = {
      F_OK: F_OK,
      R_OK: R_OK,
      W_OK: W_OK,
      X_OK: X_OK,
      constants: constants_1.constants,
      Stats: Stats_1.default,
      Dirent: Dirent_1.default
    }; // Bind FS methods.

    for (var _i = 0, fsSyncMethods_1 = fsSyncMethods; _i < fsSyncMethods_1.length; _i++) {
      var method = fsSyncMethods_1[_i];
      if (typeof vol[method] === \\"function\\") fs[method] = vol[method].bind(vol);
    }

    for (var _a = 0, fsAsyncMethods_1 = fsAsyncMethods; _a < fsAsyncMethods_1.length; _a++) {
      var method = fsAsyncMethods_1[_a];
      if (typeof vol[method] === \\"function\\") fs[method] = vol[method].bind(vol);
    }

    fs.StatWatcher = vol.StatWatcher;
    fs.FSWatcher = vol.FSWatcher;
    fs.WriteStream = vol.WriteStream;
    fs.ReadStream = vol.ReadStream;
    fs.promises = vol.promises;
    fs._toUnixTimestamp = volume_1.toUnixTimestamp;
    return fs;
  }

  exports$2.createFsFromVolume = createFsFromVolume;
  exports$2.fs = createFsFromVolume(exports$2.vol);
  exports$2 = __assign(__assign({}, exports$2), exports$2.fs);
  exports$2.semantic = true;
  return exports$2;
}

const exports$1 = dew();
exports$1['__esModule']; exports$1['fs']; exports$1['createFsFromVolume']; exports$1['vol']; exports$1['Volume']; exports$1['semantic'];

const exports = dew$2();
exports['__esModule']; exports['FSWatcher']; exports['StatWatcher']; exports['Volume']; exports['toUnixTimestamp']; exports['bufferToEncoding']; exports['dataToBuffer']; exports['dataToStr']; exports['pathToSteps']; exports['filenameToSteps']; exports['pathToFilename']; exports['flagsToNumber']; exports['FLAGS']; exports['ReadStream']; exports['WriteStream'];

const { vol, createFsFromVolume } = exports$1;

function unimplemented(name) {
  throw new Error(\`Node.js fs \${name} is not supported by JSPM core in the browser\`);
}

vol.fromNestedJSON({
  '/dev': { stdin: '', stdout: '', stderr: '' },
  '/usr/bin': {},
  '/home': {},
  '/tmp': {},
});

vol.releasedFds = [2, 1, 0];
vol.openSync('/dev/stdin', 'w');
vol.openSync('/dev/stdout', 'r');
vol.openSync('/dev/stderr', 'r');
watchStdo('/dev/stdout', 1, console.log);
watchStdo('/dev/stderr', 2, console.error);
function watchStdo(path, fd, listener) {
  let oldSize = 0;
  const decoder = new TextDecoder();
  vol.watch(path, 'utf8', () => {
    const { size } = vol.fstatSync(fd);
    const buf = Buffer.alloc(size - oldSize);
    vol.readSync(fd, buf, 0, buf.length, oldSize);
    oldSize = size;
    listener(decoder.decode(buf, { stream: true }));
  });
}

const fs = createFsFromVolume(vol);

fs.opendir = () => unimplemented('opendir');
fs.opendirSync = () => unimplemented('opendirSync');
fs.promises.opendir = () => unimplemented('promises.opendir');
fs.cp = () => unimplemented('cp');
fs.cpSync = () => unimplemented('cpSync');
fs.promises.cp = () => unimplemented('promises.cp');
fs.readv = () => unimplemented('readv');
fs.readvSync = () => unimplemented('readvSync');
fs.rm = () => unimplemented('rm');
fs.rmSync = () => unimplemented('rmSync');
fs.promises.rm = () => unimplemented('promises.rm');
fs.Dir = () => unimplemented('Dir');
fs.promises.watch = () => unimplemented('promises.watch');

fs.FileReadStream = fs.ReadStream;
fs.FileWriteStream = fs.WriteStream;

function handleFsUrl (url, isSync) {
  if (url.protocol === 'file:')
    return fileURLToPath(url);
  if (url.protocol === 'https:' || url.protocol === 'http:') {
    const path = '\\\\\\\\\\\\\\\\url\\\\\\\\' + url.href.replaceAll(/\\\\//g, '\\\\\\\\\\\\\\\\');
    if (existsSync(path))
      return path;
    if (isSync)
      throw new Error(\`Cannot sync request URL \${url} via FS. JSPM FS support for network URLs requires using async FS methods or priming the MemFS cache first with an async request before a sync request.\`);
    return (async () => {
      const res = await fetch(url);
      if (!res.ok)
        throw new Error(\`Unable to fetch \${url.href}, \${res.status}\`);
      const buf = await res.arrayBuffer();
      writeFileSync(path, Buffer.from(buf));
      return path;
    })();
  }
  throw new Error('URL ' + url + ' not supported in JSPM FS implementation.');
}

function wrapFsSync (fn) {
  return function (path, ...args) {
    if (path instanceof URL)
      return fn(handleFsUrl(path, true), ...args);
    return fn(path, ...args);
  };
}

function wrapFsPromise (fn) {
  return async function (path, ...args) {
    if (path instanceof URL)
      return fn(await handleFsUrl(path), ...args);
    return fn(path, ...args);
  };
}

function wrapFsCallback (fn) {
  return function (path, ...args) {
    const cb = args[args.length - 1];
    if (path instanceof URL && typeof cb === 'function') {
      handleFsUrl(path).then(path => {
        fn(path, ...args);
      }, cb);
    }
    else {
      fn(path, ...args);
    }
  }; 
}

fs.promises.readFile = wrapFsPromise(fs.promises.readFile);
fs.readFile = wrapFsCallback(fs.readFile);
fs.readFileSync = wrapFsSync(fs.readFileSync);

const {
  appendFile,
  appendFileSync,
  access,
  accessSync,
  chown,
  chownSync,
  chmod,
  chmodSync,
  close,
  closeSync,
  copyFile,
  copyFileSync,
  cp,
  cpSync,
  createReadStream,
  createWriteStream,
  exists,
  existsSync,
  fchown,
  fchownSync,
  fchmod,
  fchmodSync,
  fdatasync,
  fdatasyncSync,
  fstat,
  fstatSync,
  fsync,
  fsyncSync,
  ftruncate,
  ftruncateSync,
  futimes,
  futimesSync,
  lchown,
  lchownSync,
  lchmod,
  lchmodSync,
  link,
  linkSync,
  lstat,
  lstatSync,
  mkdir,
  mkdirSync,
  mkdtemp,
  mkdtempSync,
  open,
  openSync,
  opendir,
  opendirSync,
  readdir,
  readdirSync,
  read,
  readSync,
  readv,
  readvSync,
  readFile,
  readFileSync,
  readlink,
  readlinkSync,
  realpath,
  realpathSync,
  rename,
  renameSync,
  rm,
  rmSync,
  rmdir,
  rmdirSync,
  stat,
  statSync,
  symlink,
  symlinkSync,
  truncate,
  truncateSync,
  unwatchFile,
  unlink,
  unlinkSync,
  utimes,
  utimesSync,
  watch,
  watchFile,
  writeFile,
  writeFileSync,
  write,
  writeSync,
  writev,
  writevSync,
  Dir,
  Dirent,
  Stats,
  ReadStream,
  WriteStream,
  FileReadStream,
  FileWriteStream,
  _toUnixTimestamp,
  constants: { F_OK, R_OK, W_OK, X_OK },
  constants,
  promises,
} = fs;

export { Dir, Dirent, F_OK, FileReadStream, FileWriteStream, R_OK, ReadStream, Stats, W_OK, WriteStream, X_OK, _toUnixTimestamp, access, accessSync, appendFile, appendFileSync, chmod, chmodSync, chown, chownSync, close, closeSync, constants, copyFile, copyFileSync, cp, cpSync, createReadStream, createWriteStream, fs as default, exists, existsSync, fchmod, fchmodSync, fchown, fchownSync, fdatasync, fdatasyncSync, fstat, fstatSync, fsync, fsyncSync, ftruncate, ftruncateSync, futimes, futimesSync, lchmod, lchmodSync, lchown, lchownSync, link, linkSync, lstat, lstatSync, mkdir, mkdirSync, mkdtemp, mkdtempSync, open, openSync, opendir, opendirSync, promises, read, readFile, readFileSync, readSync, readdir, readdirSync, readlink, readlinkSync, readv, readvSync, realpath, realpathSync, rename, renameSync, rm, rmSync, rmdir, rmdirSync, stat, statSync, symlink, symlinkSync, truncate, truncateSync, unlink, unlinkSync, unwatchFile, utimes, utimesSync, watch, watchFile, write, writeFile, writeFileSync, writeSync, writev, writevSync };
"
`;

exports[`polyfillPath 3`] = `
"import { b as buffer } from './chunk-44e51b61.js';
import et from './assert.js';
import './util.js';
import { X } from './chunk-b4205b57.js';
import './path.js';
import { p as process } from './chunk-2eac56ff.js';
import './events.js';
import { y } from './chunk-4bd36a8f.js';
import './stream.js';
import h, { fileURLToPath } from './url.js';
import { e as exports$i } from './chunk-23dbec7b.js';
import { e as exports$j } from './chunk-6c718bbe.js';
import { Buffer } from './buffer.js';
import './chunk-ce0fbc82.js';
import './chunk-5decc758.js';
import './chunk-4ccc3a29.js';
import './chunk-924bb2e1.js';
import './chunk-b04e620d.js';

var exports$h = {},
    _dewExec$f = false;
function dew$f() {
  if (_dewExec$f) return exports$h;
  _dewExec$f = true;
  Object.defineProperty(exports$h, \\"__esModule\\", {
    value: true
  });
  exports$h.constants = void 0;
  exports$h.constants = {
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 64,
    O_EXCL: 128,
    O_NOCTTY: 256,
    O_TRUNC: 512,
    O_APPEND: 1024,
    O_DIRECTORY: 65536,
    O_NOATIME: 262144,
    O_NOFOLLOW: 131072,
    O_SYNC: 1052672,
    O_DIRECT: 16384,
    O_NONBLOCK: 2048,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    UV_FS_COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_EXCL: 1,
    COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE_FORCE: 4
  };
  return exports$h;
}

var exports$g = {},
    _dewExec$e = false;
function dew$e() {
  if (_dewExec$e) return exports$g;
  _dewExec$e = true;
  if (typeof BigInt === \\"function\\") exports$g.default = BigInt;else exports$g.default = function BigIntNotSupported() {
    throw new Error(\\"BigInt is not supported in this environment.\\");
  };
  return exports$g;
}

var exports$f = {},
    _dewExec$d = false;
function dew$d() {
  if (_dewExec$d) return exports$f;
  _dewExec$d = true;
  Object.defineProperty(exports$f, \\"__esModule\\", {
    value: true
  });
  exports$f.Stats = void 0;

  var constants_1 = dew$f();

  var getBigInt_1 = dew$e();

  var S_IFMT = constants_1.constants.S_IFMT,
      S_IFDIR = constants_1.constants.S_IFDIR,
      S_IFREG = constants_1.constants.S_IFREG,
      S_IFBLK = constants_1.constants.S_IFBLK,
      S_IFCHR = constants_1.constants.S_IFCHR,
      S_IFLNK = constants_1.constants.S_IFLNK,
      S_IFIFO = constants_1.constants.S_IFIFO,
      S_IFSOCK = constants_1.constants.S_IFSOCK;
  /**
   * Statistics about a file/directory, like \`fs.Stats\`.
   */

  var Stats = function () {
    function Stats() {}

    Stats.build = function (node, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }

      var stats = new Stats();
      var uid = node.uid,
          gid = node.gid,
          atime = node.atime,
          mtime = node.mtime,
          ctime = node.ctime;
      var getStatNumber = !bigint ? function (number) {
        return number;
      } : getBigInt_1.default; // Copy all values on Stats from Node, so that if Node values
      // change, values on Stats would still be the old ones,
      // just like in Node fs.

      stats.uid = getStatNumber(uid);
      stats.gid = getStatNumber(gid);
      stats.rdev = getStatNumber(0);
      stats.blksize = getStatNumber(4096);
      stats.ino = getStatNumber(node.ino);
      stats.size = getStatNumber(node.getSize());
      stats.blocks = getStatNumber(1);
      stats.atime = atime;
      stats.mtime = mtime;
      stats.ctime = ctime;
      stats.birthtime = ctime;
      stats.atimeMs = getStatNumber(atime.getTime());
      stats.mtimeMs = getStatNumber(mtime.getTime());
      var ctimeMs = getStatNumber(ctime.getTime());
      stats.ctimeMs = ctimeMs;
      stats.birthtimeMs = ctimeMs;
      stats.dev = getStatNumber(0);
      stats.mode = getStatNumber(node.mode);
      stats.nlink = getStatNumber(node.nlink);
      return stats;
    };

    Stats.prototype._checkModeProperty = function (property) {
      return (Number(this.mode) & S_IFMT) === property;
    };

    Stats.prototype.isDirectory = function () {
      return this._checkModeProperty(S_IFDIR);
    };

    Stats.prototype.isFile = function () {
      return this._checkModeProperty(S_IFREG);
    };

    Stats.prototype.isBlockDevice = function () {
      return this._checkModeProperty(S_IFBLK);
    };

    Stats.prototype.isCharacterDevice = function () {
      return this._checkModeProperty(S_IFCHR);
    };

    Stats.prototype.isSymbolicLink = function () {
      return this._checkModeProperty(S_IFLNK);
    };

    Stats.prototype.isFIFO = function () {
      return this._checkModeProperty(S_IFIFO);
    };

    Stats.prototype.isSocket = function () {
      return this._checkModeProperty(S_IFSOCK);
    };

    return Stats;
  }();

  exports$f.Stats = Stats;
  exports$f.default = Stats;
  return exports$f;
}

var exports$e = {},
    _dewExec$c = false;
function dew$c() {
  if (_dewExec$c) return exports$e;
  _dewExec$c = true;

  var __spreadArray = exports$e && exports$e.__spreadArray || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };

  Object.defineProperty(exports$e, \\"__esModule\\", {
    value: true
  });
  exports$e.bufferFrom = exports$e.bufferAllocUnsafe = exports$e.Buffer = void 0;
  var buffer_1 = buffer;
  Object.defineProperty(exports$e, \\"Buffer\\", {
    enumerable: true,
    get: function () {
      return buffer_1.Buffer;
    }
  });

  function bufferV0P12Ponyfill(arg0) {
    var args = [];

    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }

    return new (buffer_1.Buffer.bind.apply(buffer_1.Buffer, __spreadArray([void 0, arg0], args, false)))();
  }

  var bufferAllocUnsafe = buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;
  exports$e.bufferAllocUnsafe = bufferAllocUnsafe;
  var bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;
  exports$e.bufferFrom = bufferFrom;
  return exports$e;
}

var exports$d = {},
    _dewExec$b = false;

var _global$3 = typeof globalThis !== \\"undefined\\" ? globalThis : typeof self !== \\"undefined\\" ? self : global;

function dew$b() {
  if (_dewExec$b) return exports$d;
  _dewExec$b = true;

  // The whole point behind this internal module is to allow Node.js to no
  // longer be forced to treat every error message change as a semver-major
  // change. The NodeError classes here all expose a \`code\` property whose
  // value statically and permanently identifies the error. While the error
  // message may change, the code should not.
  var __extends = exports$d && exports$d.__extends || function () {
    var extendStatics = function (d, b) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      };

      return extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== \\"function\\" && b !== null) throw new TypeError(\\"Class extends value \\" + String(b) + \\" is not a constructor or null\\");
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(exports$d, \\"__esModule\\", {
    value: true
  });
  exports$d.E = exports$d.AssertionError = exports$d.message = exports$d.RangeError = exports$d.TypeError = exports$d.Error = void 0;
  var assert = et;
  var util = X;
  var kCode = typeof Symbol === \\"undefined\\" ? \\"_kCode\\" : Symbol(\\"code\\");
  var messages = {}; // new Map();

  function makeNodeError(Base) {
    return function (_super) {
      __extends(NodeError, _super);

      function NodeError(key) {
        var args = [];

        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }

        var _this = _super.call(this, message(key, args)) || this;

        _this.code = key;
        _this[kCode] = key;
        _this.name = _super.prototype.name + \\" [\\" + _this[kCode] + \\"]\\";
        return _this;
      }

      return NodeError;
    }(Base);
  }

  var g = typeof globalThis !== \\"undefined\\" ? globalThis : _global$3;

  var AssertionError = function (_super) {
    __extends(AssertionError, _super);

    function AssertionError(options) {
      var _this = this;

      if (typeof options !== \\"object\\" || options === null) {
        throw new exports$d.TypeError(\\"ERR_INVALID_ARG_TYPE\\", \\"options\\", \\"object\\");
      }

      if (options.message) {
        _this = _super.call(this, options.message) || this;
      } else {
        _this = _super.call(this, util.inspect(options.actual).slice(0, 128) + \\" \\" + (options.operator + \\" \\" + util.inspect(options.expected).slice(0, 128))) || this;
      }

      _this.generatedMessage = !options.message;
      _this.name = \\"AssertionError [ERR_ASSERTION]\\";
      _this.code = \\"ERR_ASSERTION\\";
      _this.actual = options.actual;
      _this.expected = options.expected;
      _this.operator = options.operator;
      exports$d.Error.captureStackTrace(_this, options.stackStartFunction);
      return _this;
    }

    return AssertionError;
  }(g.Error);

  exports$d.AssertionError = AssertionError;

  function message(key, args) {
    assert.strictEqual(typeof key, \\"string\\"); // const msg = messages.get(key);

    var msg = messages[key];
    assert(msg, \\"An invalid error message key was used: \\" + key + \\".\\");
    var fmt;

    if (typeof msg === \\"function\\") {
      fmt = msg;
    } else {
      fmt = util.format;
      if (args === undefined || args.length === 0) return msg;
      args.unshift(msg);
    }

    return String(fmt.apply(null, args));
  }

  exports$d.message = message; // Utility function for registering the error codes. Only used here. Exported
  // *only* to allow for testing.

  function E(sym, val) {
    messages[sym] = typeof val === \\"function\\" ? val : String(val);
  }

  exports$d.E = E;
  exports$d.Error = makeNodeError(g.Error);
  exports$d.TypeError = makeNodeError(g.TypeError);
  exports$d.RangeError = makeNodeError(g.RangeError); // To declare an error message, use the E(sym, val) function above. The sym
  // must be an upper case string. The val can be either a function or a string.
  // The return value of the function must be a string.
  // Examples:
  // E('EXAMPLE_KEY1', 'This is the error value');
  // E('EXAMPLE_KEY2', (a, b) => return \`\${a} \${b}\`);
  //
  // Once an error code has been assigned, the code itself MUST NOT change and
  // any given error code must never be reused to identify a different error.
  //
  // Any error code added here should also be added to the documentation
  //
  // Note: Please try to keep these in alphabetical order

  E(\\"ERR_ARG_NOT_ITERABLE\\", \\"%s must be iterable\\");
  E(\\"ERR_ASSERTION\\", \\"%s\\");
  E(\\"ERR_BUFFER_OUT_OF_BOUNDS\\", bufferOutOfBounds);
  E(\\"ERR_CHILD_CLOSED_BEFORE_REPLY\\", \\"Child closed before reply received\\");
  E(\\"ERR_CONSOLE_WRITABLE_STREAM\\", \\"Console expects a writable stream instance for %s\\");
  E(\\"ERR_CPU_USAGE\\", \\"Unable to obtain cpu usage %s\\");
  E(\\"ERR_DNS_SET_SERVERS_FAILED\\", function (err, servers) {
    return \\"c-ares failed to set servers: \\\\\\"\\" + err + \\"\\\\\\" [\\" + servers + \\"]\\";
  });
  E(\\"ERR_FALSY_VALUE_REJECTION\\", \\"Promise was rejected with falsy value\\");
  E(\\"ERR_ENCODING_NOT_SUPPORTED\\", function (enc) {
    return \\"The \\\\\\"\\" + enc + \\"\\\\\\" encoding is not supported\\";
  });
  E(\\"ERR_ENCODING_INVALID_ENCODED_DATA\\", function (enc) {
    return \\"The encoded data was not valid for encoding \\" + enc;
  });
  E(\\"ERR_HTTP_HEADERS_SENT\\", \\"Cannot render headers after they are sent to the client\\");
  E(\\"ERR_HTTP_INVALID_STATUS_CODE\\", \\"Invalid status code: %s\\");
  E(\\"ERR_HTTP_TRAILER_INVALID\\", \\"Trailers are invalid with this transfer encoding\\");
  E(\\"ERR_INDEX_OUT_OF_RANGE\\", \\"Index out of range\\");
  E(\\"ERR_INVALID_ARG_TYPE\\", invalidArgType);
  E(\\"ERR_INVALID_ARRAY_LENGTH\\", function (name, len, actual) {
    assert.strictEqual(typeof actual, \\"number\\");
    return \\"The array \\\\\\"\\" + name + \\"\\\\\\" (length \\" + actual + \\") must be of length \\" + len + \\".\\";
  });
  E(\\"ERR_INVALID_BUFFER_SIZE\\", \\"Buffer size must be a multiple of %s\\");
  E(\\"ERR_INVALID_CALLBACK\\", \\"Callback must be a function\\");
  E(\\"ERR_INVALID_CHAR\\", \\"Invalid character in %s\\");
  E(\\"ERR_INVALID_CURSOR_POS\\", \\"Cannot set cursor row without setting its column\\");
  E(\\"ERR_INVALID_FD\\", \\"\\\\\\"fd\\\\\\" must be a positive integer: %s\\");
  E(\\"ERR_INVALID_FILE_URL_HOST\\", \\"File URL host must be \\\\\\"localhost\\\\\\" or empty on %s\\");
  E(\\"ERR_INVALID_FILE_URL_PATH\\", \\"File URL path %s\\");
  E(\\"ERR_INVALID_HANDLE_TYPE\\", \\"This handle type cannot be sent\\");
  E(\\"ERR_INVALID_IP_ADDRESS\\", \\"Invalid IP address: %s\\");
  E(\\"ERR_INVALID_OPT_VALUE\\", function (name, value) {
    return \\"The value \\\\\\"\\" + String(value) + \\"\\\\\\" is invalid for option \\\\\\"\\" + name + \\"\\\\\\"\\";
  });
  E(\\"ERR_INVALID_OPT_VALUE_ENCODING\\", function (value) {
    return \\"The value \\\\\\"\\" + String(value) + \\"\\\\\\" is invalid for option \\\\\\"encoding\\\\\\"\\";
  });
  E(\\"ERR_INVALID_REPL_EVAL_CONFIG\\", \\"Cannot specify both \\\\\\"breakEvalOnSigint\\\\\\" and \\\\\\"eval\\\\\\" for REPL\\");
  E(\\"ERR_INVALID_SYNC_FORK_INPUT\\", \\"Asynchronous forks do not support Buffer, Uint8Array or string input: %s\\");
  E(\\"ERR_INVALID_THIS\\", \\"Value of \\\\\\"this\\\\\\" must be of type %s\\");
  E(\\"ERR_INVALID_TUPLE\\", \\"%s must be an iterable %s tuple\\");
  E(\\"ERR_INVALID_URL\\", \\"Invalid URL: %s\\");
  E(\\"ERR_INVALID_URL_SCHEME\\", function (expected) {
    return \\"The URL must be \\" + oneOf(expected, \\"scheme\\");
  });
  E(\\"ERR_IPC_CHANNEL_CLOSED\\", \\"Channel closed\\");
  E(\\"ERR_IPC_DISCONNECTED\\", \\"IPC channel is already disconnected\\");
  E(\\"ERR_IPC_ONE_PIPE\\", \\"Child process can have only one IPC pipe\\");
  E(\\"ERR_IPC_SYNC_FORK\\", \\"IPC cannot be used with synchronous forks\\");
  E(\\"ERR_MISSING_ARGS\\", missingArgs);
  E(\\"ERR_MULTIPLE_CALLBACK\\", \\"Callback called multiple times\\");
  E(\\"ERR_NAPI_CONS_FUNCTION\\", \\"Constructor must be a function\\");
  E(\\"ERR_NAPI_CONS_PROTOTYPE_OBJECT\\", \\"Constructor.prototype must be an object\\");
  E(\\"ERR_NO_CRYPTO\\", \\"Node.js is not compiled with OpenSSL crypto support\\");
  E(\\"ERR_NO_LONGER_SUPPORTED\\", \\"%s is no longer supported\\");
  E(\\"ERR_PARSE_HISTORY_DATA\\", \\"Could not parse history data in %s\\");
  E(\\"ERR_SOCKET_ALREADY_BOUND\\", \\"Socket is already bound\\");
  E(\\"ERR_SOCKET_BAD_PORT\\", \\"Port should be > 0 and < 65536\\");
  E(\\"ERR_SOCKET_BAD_TYPE\\", \\"Bad socket type specified. Valid types are: udp4, udp6\\");
  E(\\"ERR_SOCKET_CANNOT_SEND\\", \\"Unable to send data\\");
  E(\\"ERR_SOCKET_CLOSED\\", \\"Socket is closed\\");
  E(\\"ERR_SOCKET_DGRAM_NOT_RUNNING\\", \\"Not running\\");
  E(\\"ERR_STDERR_CLOSE\\", \\"process.stderr cannot be closed\\");
  E(\\"ERR_STDOUT_CLOSE\\", \\"process.stdout cannot be closed\\");
  E(\\"ERR_STREAM_WRAP\\", \\"Stream has StringDecoder set or is in objectMode\\");
  E(\\"ERR_TLS_CERT_ALTNAME_INVALID\\", \\"Hostname/IP does not match certificate's altnames: %s\\");
  E(\\"ERR_TLS_DH_PARAM_SIZE\\", function (size) {
    return \\"DH parameter size \\" + size + \\" is less than 2048\\";
  });
  E(\\"ERR_TLS_HANDSHAKE_TIMEOUT\\", \\"TLS handshake timeout\\");
  E(\\"ERR_TLS_RENEGOTIATION_FAILED\\", \\"Failed to renegotiate\\");
  E(\\"ERR_TLS_REQUIRED_SERVER_NAME\\", \\"\\\\\\"servername\\\\\\" is required parameter for Server.addContext\\");
  E(\\"ERR_TLS_SESSION_ATTACK\\", \\"TSL session renegotiation attack detected\\");
  E(\\"ERR_TRANSFORM_ALREADY_TRANSFORMING\\", \\"Calling transform done when still transforming\\");
  E(\\"ERR_TRANSFORM_WITH_LENGTH_0\\", \\"Calling transform done when writableState.length != 0\\");
  E(\\"ERR_UNKNOWN_ENCODING\\", \\"Unknown encoding: %s\\");
  E(\\"ERR_UNKNOWN_SIGNAL\\", \\"Unknown signal: %s\\");
  E(\\"ERR_UNKNOWN_STDIN_TYPE\\", \\"Unknown stdin file type\\");
  E(\\"ERR_UNKNOWN_STREAM_TYPE\\", \\"Unknown stream file type\\");
  E(\\"ERR_V8BREAKITERATOR\\", \\"Full ICU data not installed. \\" + \\"See https://github.com/nodejs/node/wiki/Intl\\");

  function invalidArgType(name, expected, actual) {
    assert(name, \\"name is required\\"); // determiner: 'must be' or 'must not be'

    var determiner;

    if (expected.includes(\\"not \\")) {
      determiner = \\"must not be\\";
      expected = expected.split(\\"not \\")[1];
    } else {
      determiner = \\"must be\\";
    }

    var msg;

    if (Array.isArray(name)) {
      var names = name.map(function (val) {
        return \\"\\\\\\"\\" + val + \\"\\\\\\"\\";
      }).join(\\", \\");
      msg = \\"The \\" + names + \\" arguments \\" + determiner + \\" \\" + oneOf(expected, \\"type\\");
    } else if (name.includes(\\" argument\\")) {
      // for the case like 'first argument'
      msg = \\"The \\" + name + \\" \\" + determiner + \\" \\" + oneOf(expected, \\"type\\");
    } else {
      var type = name.includes(\\".\\") ? \\"property\\" : \\"argument\\";
      msg = \\"The \\\\\\"\\" + name + \\"\\\\\\" \\" + type + \\" \\" + determiner + \\" \\" + oneOf(expected, \\"type\\");
    } // if actual value received, output it


    if (arguments.length >= 3) {
      msg += \\". Received type \\" + (actual !== null ? typeof actual : \\"null\\");
    }

    return msg;
  }

  function missingArgs() {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    assert(args.length > 0, \\"At least one arg needs to be specified\\");
    var msg = \\"The \\";
    var len = args.length;
    args = args.map(function (a) {
      return \\"\\\\\\"\\" + a + \\"\\\\\\"\\";
    });

    switch (len) {
      case 1:
        msg += args[0] + \\" argument\\";
        break;

      case 2:
        msg += args[0] + \\" and \\" + args[1] + \\" arguments\\";
        break;

      default:
        msg += args.slice(0, len - 1).join(\\", \\");
        msg += \\", and \\" + args[len - 1] + \\" arguments\\";
        break;
    }

    return msg + \\" must be specified\\";
  }

  function oneOf(expected, thing) {
    assert(expected, \\"expected is required\\");
    assert(typeof thing === \\"string\\", \\"thing is required\\");

    if (Array.isArray(expected)) {
      var len = expected.length;
      assert(len > 0, \\"At least one expected value needs to be specified\\"); // tslint:disable-next-line

      expected = expected.map(function (i) {
        return String(i);
      });

      if (len > 2) {
        return \\"one of \\" + thing + \\" \\" + expected.slice(0, len - 1).join(\\", \\") + \\", or \\" + expected[len - 1];
      } else if (len === 2) {
        return \\"one of \\" + thing + \\" \\" + expected[0] + \\" or \\" + expected[1];
      } else {
        return \\"of \\" + thing + \\" \\" + expected[0];
      }
    } else {
      return \\"of \\" + thing + \\" \\" + String(expected);
    }
  }

  function bufferOutOfBounds(name, isWriting) {
    if (isWriting) {
      return \\"Attempt to write outside buffer bounds\\";
    } else {
      return \\"\\\\\\"\\" + name + \\"\\\\\\" is outside of buffer bounds\\";
    }
  }

  return exports$d;
}

var exports$c = {},
    _dewExec$a = false;
function dew$a() {
  if (_dewExec$a) return exports$c;
  _dewExec$a = true;
  Object.defineProperty(exports$c, \\"__esModule\\", {
    value: true
  });
  exports$c.strToEncoding = exports$c.assertEncoding = exports$c.ENCODING_UTF8 = void 0;

  var buffer_1 = dew$c();

  var errors = dew$b();

  exports$c.ENCODING_UTF8 = \\"utf8\\";

  function assertEncoding(encoding) {
    if (encoding && !buffer_1.Buffer.isEncoding(encoding)) throw new errors.TypeError(\\"ERR_INVALID_OPT_VALUE_ENCODING\\", encoding);
  }

  exports$c.assertEncoding = assertEncoding;

  function strToEncoding(str, encoding) {
    if (!encoding || encoding === exports$c.ENCODING_UTF8) return str; // UTF-8

    if (encoding === \\"buffer\\") return new buffer_1.Buffer(str); // \`buffer\` encoding

    return new buffer_1.Buffer(str).toString(encoding); // Custom encoding
  }

  exports$c.strToEncoding = strToEncoding;
  return exports$c;
}

var exports$b = {},
    _dewExec$9 = false;
function dew$9() {
  if (_dewExec$9) return exports$b;
  _dewExec$9 = true;
  Object.defineProperty(exports$b, \\"__esModule\\", {
    value: true
  });
  exports$b.Dirent = void 0;

  var constants_1 = dew$f();

  var encoding_1 = dew$a();

  var S_IFMT = constants_1.constants.S_IFMT,
      S_IFDIR = constants_1.constants.S_IFDIR,
      S_IFREG = constants_1.constants.S_IFREG,
      S_IFBLK = constants_1.constants.S_IFBLK,
      S_IFCHR = constants_1.constants.S_IFCHR,
      S_IFLNK = constants_1.constants.S_IFLNK,
      S_IFIFO = constants_1.constants.S_IFIFO,
      S_IFSOCK = constants_1.constants.S_IFSOCK;
  /**
   * A directory entry, like \`fs.Dirent\`.
   */

  var Dirent = function () {
    function Dirent() {
      this.name = \\"\\";
      this.mode = 0;
    }

    Dirent.build = function (link, encoding) {
      var dirent = new Dirent();
      var mode = link.getNode().mode;
      dirent.name = (0, encoding_1.strToEncoding)(link.getName(), encoding);
      dirent.mode = mode;
      return dirent;
    };

    Dirent.prototype._checkModeProperty = function (property) {
      return (this.mode & S_IFMT) === property;
    };

    Dirent.prototype.isDirectory = function () {
      return this._checkModeProperty(S_IFDIR);
    };

    Dirent.prototype.isFile = function () {
      return this._checkModeProperty(S_IFREG);
    };

    Dirent.prototype.isBlockDevice = function () {
      return this._checkModeProperty(S_IFBLK);
    };

    Dirent.prototype.isCharacterDevice = function () {
      return this._checkModeProperty(S_IFCHR);
    };

    Dirent.prototype.isSymbolicLink = function () {
      return this._checkModeProperty(S_IFLNK);
    };

    Dirent.prototype.isFIFO = function () {
      return this._checkModeProperty(S_IFIFO);
    };

    Dirent.prototype.isSocket = function () {
      return this._checkModeProperty(S_IFSOCK);
    };

    return Dirent;
  }();

  exports$b.Dirent = Dirent;
  exports$b.default = Dirent;
  return exports$b;
}

var exports$a = {},
    _dewExec$8 = false;

var _global$2 = typeof globalThis !== \\"undefined\\" ? globalThis : typeof self !== \\"undefined\\" ? self : global;

function dew$8() {
  if (_dewExec$8) return exports$a;
  _dewExec$8 = true;
  var process$1 = process;
  Object.defineProperty(exports$a, \\"__esModule\\", {
    value: true
  });

  var _setImmediate;

  if (typeof process$1.nextTick === \\"function\\") _setImmediate = process$1.nextTick.bind(typeof globalThis !== \\"undefined\\" ? globalThis : _global$2);else _setImmediate = setTimeout.bind(typeof globalThis !== \\"undefined\\" ? globalThis : _global$2);
  exports$a.default = _setImmediate;
  return exports$a;
}

var exports$9 = {},
    _dewExec$7 = false;
function dew$7() {
  if (_dewExec$7) return exports$9;
  _dewExec$7 = true;
  var process$1 = process;
  // Here we mock the global \`process\` variable in case we are not in Node's environment.
  Object.defineProperty(exports$9, \\"__esModule\\", {
    value: true
  });
  exports$9.createProcess = void 0;
  /**
   * Looks to return a \`process\` object, if one is available.
   *
   * The global \`process\` is returned if defined;
   * otherwise \`require('process')\` is attempted.
   *
   * If that fails, \`undefined\` is returned.
   *
   * @return {IProcess | undefined}
   */

  var maybeReturnProcess = function () {
    if (typeof process$1 !== \\"undefined\\") {
      return process$1;
    }

    try {
      return process;
    } catch (_a) {
      return undefined;
    }
  };

  function createProcess() {
    var p = maybeReturnProcess() || {};
    if (!p.getuid) p.getuid = function () {
      return 0;
    };
    if (!p.getgid) p.getgid = function () {
      return 0;
    };
    if (!p.cwd) p.cwd = function () {
      return \\"/\\";
    };
    if (!p.nextTick) p.nextTick = dew$8().default;
    if (!p.emitWarning) p.emitWarning = function (message, type) {
      // tslint:disable-next-line:no-console
      console.warn(\\"\\" + type + (type ? \\": \\" : \\"\\") + message);
    };
    if (!p.env) p.env = {};
    return p;
  }

  exports$9.createProcess = createProcess;
  exports$9.default = createProcess();
  return exports$9;
}

var exports$8 = {},
    _dewExec$6 = false;
function dew$6() {
  if (_dewExec$6) return exports$8;
  _dewExec$6 = true;

  var __extends = exports$8 && exports$8.__extends || function () {
    var extendStatics = function (d, b) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      };

      return extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== \\"function\\" && b !== null) throw new TypeError(\\"Class extends value \\" + String(b) + \\" is not a constructor or null\\");
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(exports$8, \\"__esModule\\", {
    value: true
  });
  exports$8.File = exports$8.Link = exports$8.Node = exports$8.SEP = void 0;

  var process_1 = dew$7();

  var buffer_1 = dew$c();

  var constants_1 = dew$f();

  var events_1 = y;

  var Stats_1 = dew$d();

  var S_IFMT = constants_1.constants.S_IFMT,
      S_IFDIR = constants_1.constants.S_IFDIR,
      S_IFREG = constants_1.constants.S_IFREG,
      S_IFLNK = constants_1.constants.S_IFLNK,
      O_APPEND = constants_1.constants.O_APPEND;
  exports$8.SEP = \\"/\\";
  /**
   * Node in a file system (like i-node, v-node).
   */

  var Node = function (_super) {
    __extends(Node, _super);

    function Node(ino, perm) {
      if (perm === void 0) {
        perm = 438;
      }

      var _this = _super.call(this) || this; // User ID and group ID.


      _this.uid = process_1.default.getuid();
      _this.gid = process_1.default.getgid();
      _this.atime = new Date();
      _this.mtime = new Date();
      _this.ctime = new Date();
      _this.perm = 438; // Permissions \`chmod\`, \`fchmod\`

      _this.mode = S_IFREG; // S_IFDIR, S_IFREG, etc.. (file by default?)
      // Number of hard links pointing at this Node.

      _this.nlink = 1;
      _this.perm = perm;
      _this.mode |= perm;
      _this.ino = ino;
      return _this;
    }

    Node.prototype.getString = function (encoding) {
      if (encoding === void 0) {
        encoding = \\"utf8\\";
      }

      return this.getBuffer().toString(encoding);
    };

    Node.prototype.setString = function (str) {
      // this.setBuffer(bufferFrom(str, 'utf8'));
      this.buf = (0, buffer_1.bufferFrom)(str, \\"utf8\\");
      this.touch();
    };

    Node.prototype.getBuffer = function () {
      if (!this.buf) this.setBuffer((0, buffer_1.bufferAllocUnsafe)(0));
      return (0, buffer_1.bufferFrom)(this.buf); // Return a copy.
    };

    Node.prototype.setBuffer = function (buf) {
      this.buf = (0, buffer_1.bufferFrom)(buf); // Creates a copy of data.

      this.touch();
    };

    Node.prototype.getSize = function () {
      return this.buf ? this.buf.length : 0;
    };

    Node.prototype.setModeProperty = function (property) {
      this.mode = this.mode & ~S_IFMT | property;
    };

    Node.prototype.setIsFile = function () {
      this.setModeProperty(S_IFREG);
    };

    Node.prototype.setIsDirectory = function () {
      this.setModeProperty(S_IFDIR);
    };

    Node.prototype.setIsSymlink = function () {
      this.setModeProperty(S_IFLNK);
    };

    Node.prototype.isFile = function () {
      return (this.mode & S_IFMT) === S_IFREG;
    };

    Node.prototype.isDirectory = function () {
      return (this.mode & S_IFMT) === S_IFDIR;
    };

    Node.prototype.isSymlink = function () {
      // return !!this.symlink;
      return (this.mode & S_IFMT) === S_IFLNK;
    };

    Node.prototype.makeSymlink = function (steps) {
      this.symlink = steps;
      this.setIsSymlink();
    };

    Node.prototype.write = function (buf, off, len, pos) {
      if (off === void 0) {
        off = 0;
      }

      if (len === void 0) {
        len = buf.length;
      }

      if (pos === void 0) {
        pos = 0;
      }

      if (!this.buf) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);

      if (pos + len > this.buf.length) {
        var newBuf = (0, buffer_1.bufferAllocUnsafe)(pos + len);
        this.buf.copy(newBuf, 0, 0, this.buf.length);
        this.buf = newBuf;
      }

      buf.copy(this.buf, pos, off, off + len);
      this.touch();
      return len;
    }; // Returns the number of bytes read.


    Node.prototype.read = function (buf, off, len, pos) {
      if (off === void 0) {
        off = 0;
      }

      if (len === void 0) {
        len = buf.byteLength;
      }

      if (pos === void 0) {
        pos = 0;
      }

      if (!this.buf) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
      var actualLen = len;

      if (actualLen > buf.byteLength) {
        actualLen = buf.byteLength;
      }

      if (actualLen + pos > this.buf.length) {
        actualLen = this.buf.length - pos;
      }

      this.buf.copy(buf, off, pos, pos + actualLen);
      return actualLen;
    };

    Node.prototype.truncate = function (len) {
      if (len === void 0) {
        len = 0;
      }

      if (!len) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);else {
        if (!this.buf) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);

        if (len <= this.buf.length) {
          this.buf = this.buf.slice(0, len);
        } else {
          var buf = (0, buffer_1.bufferAllocUnsafe)(0);
          this.buf.copy(buf);
          buf.fill(0, len);
        }
      }
      this.touch();
    };

    Node.prototype.chmod = function (perm) {
      this.perm = perm;
      this.mode = this.mode & ~511 | perm;
      this.touch();
    };

    Node.prototype.chown = function (uid, gid) {
      this.uid = uid;
      this.gid = gid;
      this.touch();
    };

    Node.prototype.touch = function () {
      this.mtime = new Date();
      this.emit(\\"change\\", this);
    };

    Node.prototype.canRead = function (uid, gid) {
      if (uid === void 0) {
        uid = process_1.default.getuid();
      }

      if (gid === void 0) {
        gid = process_1.default.getgid();
      }

      if (this.perm & 4
      /* IROTH */
      ) {
        return true;
      }

      if (gid === this.gid) {
        if (this.perm & 32
        /* IRGRP */
        ) {
          return true;
        }
      }

      if (uid === this.uid) {
        if (this.perm & 256
        /* IRUSR */
        ) {
          return true;
        }
      }

      return false;
    };

    Node.prototype.canWrite = function (uid, gid) {
      if (uid === void 0) {
        uid = process_1.default.getuid();
      }

      if (gid === void 0) {
        gid = process_1.default.getgid();
      }

      if (this.perm & 2
      /* IWOTH */
      ) {
        return true;
      }

      if (gid === this.gid) {
        if (this.perm & 16
        /* IWGRP */
        ) {
          return true;
        }
      }

      if (uid === this.uid) {
        if (this.perm & 128
        /* IWUSR */
        ) {
          return true;
        }
      }

      return false;
    };

    Node.prototype.del = function () {
      this.emit(\\"delete\\", this);
    };

    Node.prototype.toJSON = function () {
      return {
        ino: this.ino,
        uid: this.uid,
        gid: this.gid,
        atime: this.atime.getTime(),
        mtime: this.mtime.getTime(),
        ctime: this.ctime.getTime(),
        perm: this.perm,
        mode: this.mode,
        nlink: this.nlink,
        symlink: this.symlink,
        data: this.getString()
      };
    };

    return Node;
  }(events_1.EventEmitter);

  exports$8.Node = Node;
  /**
   * Represents a hard link that points to an i-node \`node\`.
   */

  var Link = function (_super) {
    __extends(Link, _super);

    function Link(vol, parent, name) {
      var _this = _super.call(this) || this;

      _this.children = {}; // Path to this node as Array: ['usr', 'bin', 'node'].

      _this.steps = []; // \\"i-node\\" number of the node.

      _this.ino = 0; // Number of children.

      _this.length = 0;
      _this.vol = vol;
      _this.parent = parent;
      _this.steps = parent ? parent.steps.concat([name]) : [name];
      return _this;
    }

    Link.prototype.setNode = function (node) {
      this.node = node;
      this.ino = node.ino;
    };

    Link.prototype.getNode = function () {
      return this.node;
    };

    Link.prototype.createChild = function (name, node) {
      if (node === void 0) {
        node = this.vol.createNode();
      }

      var link = new Link(this.vol, this, name);
      link.setNode(node);

      if (node.isDirectory()) ;

      this.setChild(name, link);
      return link;
    };

    Link.prototype.setChild = function (name, link) {
      if (link === void 0) {
        link = new Link(this.vol, this, name);
      }

      this.children[name] = link;
      link.parent = this;
      this.length++;
      this.emit(\\"child:add\\", link, this);
      return link;
    };

    Link.prototype.deleteChild = function (link) {
      delete this.children[link.getName()];
      this.length--;
      this.emit(\\"child:delete\\", link, this);
    };

    Link.prototype.getChild = function (name) {
      if (Object.hasOwnProperty.call(this.children, name)) {
        return this.children[name];
      }
    };

    Link.prototype.getPath = function () {
      return this.steps.join(exports$8.SEP);
    };

    Link.prototype.getName = function () {
      return this.steps[this.steps.length - 1];
    }; // del() {
    //     const parent = this.parent;
    //     if(parent) {
    //         parent.deleteChild(link);
    //     }
    //     this.parent = null;
    //     this.vol = null;
    // }

    /**
     * Walk the tree path and return the \`Link\` at that location, if any.
     * @param steps {string[]} Desired location.
     * @param stop {number} Max steps to go into.
     * @param i {number} Current step in the \`steps\` array.
     *
     * @return {Link|null}
     */


    Link.prototype.walk = function (steps, stop, i) {
      if (stop === void 0) {
        stop = steps.length;
      }

      if (i === void 0) {
        i = 0;
      }

      if (i >= steps.length) return this;
      if (i >= stop) return this;
      var step = steps[i];
      var link = this.getChild(step);
      if (!link) return null;
      return link.walk(steps, stop, i + 1);
    };

    Link.prototype.toJSON = function () {
      return {
        steps: this.steps,
        ino: this.ino,
        children: Object.keys(this.children)
      };
    };

    return Link;
  }(events_1.EventEmitter);

  exports$8.Link = Link;
  /**
   * Represents an open file (file descriptor) that points to a \`Link\` (Hard-link) and a \`Node\`.
   */

  var File = function () {
    /**
     * Open a Link-Node pair. \`node\` is provided separately as that might be a different node
     * rather the one \`link\` points to, because it might be a symlink.
     * @param link
     * @param node
     * @param flags
     * @param fd
     */
    function File(link, node, flags, fd) {
      /**
       * A cursor/offset position in a file, where data will be written on write.
       * User can \\"seek\\" this position.
       */
      this.position = 0;
      this.link = link;
      this.node = node;
      this.flags = flags;
      this.fd = fd;
    }

    File.prototype.getString = function (encoding) {

      return this.node.getString();
    };

    File.prototype.setString = function (str) {
      this.node.setString(str);
    };

    File.prototype.getBuffer = function () {
      return this.node.getBuffer();
    };

    File.prototype.setBuffer = function (buf) {
      this.node.setBuffer(buf);
    };

    File.prototype.getSize = function () {
      return this.node.getSize();
    };

    File.prototype.truncate = function (len) {
      this.node.truncate(len);
    };

    File.prototype.seekTo = function (position) {
      this.position = position;
    };

    File.prototype.stats = function () {
      return Stats_1.default.build(this.node);
    };

    File.prototype.write = function (buf, offset, length, position) {
      if (offset === void 0) {
        offset = 0;
      }

      if (length === void 0) {
        length = buf.length;
      }

      if (typeof position !== \\"number\\") position = this.position;
      if (this.flags & O_APPEND) position = this.getSize();
      var bytes = this.node.write(buf, offset, length, position);
      this.position = position + bytes;
      return bytes;
    };

    File.prototype.read = function (buf, offset, length, position) {
      if (offset === void 0) {
        offset = 0;
      }

      if (length === void 0) {
        length = buf.byteLength;
      }

      if (typeof position !== \\"number\\") position = this.position;
      var bytes = this.node.read(buf, offset, length, position);
      this.position = position + bytes;
      return bytes;
    };

    File.prototype.chmod = function (perm) {
      this.node.chmod(perm);
    };

    File.prototype.chown = function (uid, gid) {
      this.node.chown(uid, gid);
    };

    return File;
  }();

  exports$8.File = File;
  return exports$8;
}

var exports$7 = {},
    _dewExec$5 = false;

var _global$1 = typeof globalThis !== \\"undefined\\" ? globalThis : typeof self !== \\"undefined\\" ? self : global;

function dew$5() {
  if (_dewExec$5) return exports$7;
  _dewExec$5 = true;
  Object.defineProperty(exports$7, \\"__esModule\\", {
    value: true
  });
  /**
   * \`setTimeoutUnref\` is just like \`setTimeout\`,
   * only in Node's environment it will \\"unref\\" its macro task.
   */

  function setTimeoutUnref(callback, time, args) {
    var ref = setTimeout.apply(typeof globalThis !== \\"undefined\\" ? globalThis : _global$1, arguments);
    if (ref && typeof ref === \\"object\\" && typeof ref.unref === \\"function\\") ref.unref();
    return ref;
  }

  exports$7.default = setTimeoutUnref;
  return exports$7;
}

var exports$6 = {},
    _dewExec$4 = false;
function dew$4() {
  if (_dewExec$4) return exports$6;
  _dewExec$4 = true;

  var __spreadArray = exports$6 && exports$6.__spreadArray || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };

  Object.defineProperty(exports$6, \\"__esModule\\", {
    value: true
  });
  exports$6.FileHandle = void 0;

  function promisify(vol, fn, getResult) {
    if (getResult === void 0) {
      getResult = function (input) {
        return input;
      };
    }

    return function () {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      return new Promise(function (resolve, reject) {
        vol[fn].bind(vol).apply(void 0, __spreadArray(__spreadArray([], args, false), [function (error, result) {
          if (error) return reject(error);
          return resolve(getResult(result));
        }], false));
      });
    };
  }

  var FileHandle = function () {
    function FileHandle(vol, fd) {
      this.vol = vol;
      this.fd = fd;
    }

    FileHandle.prototype.appendFile = function (data, options) {
      return promisify(this.vol, \\"appendFile\\")(this.fd, data, options);
    };

    FileHandle.prototype.chmod = function (mode) {
      return promisify(this.vol, \\"fchmod\\")(this.fd, mode);
    };

    FileHandle.prototype.chown = function (uid, gid) {
      return promisify(this.vol, \\"fchown\\")(this.fd, uid, gid);
    };

    FileHandle.prototype.close = function () {
      return promisify(this.vol, \\"close\\")(this.fd);
    };

    FileHandle.prototype.datasync = function () {
      return promisify(this.vol, \\"fdatasync\\")(this.fd);
    };

    FileHandle.prototype.read = function (buffer, offset, length, position) {
      return promisify(this.vol, \\"read\\", function (bytesRead) {
        return {
          bytesRead: bytesRead,
          buffer: buffer
        };
      })(this.fd, buffer, offset, length, position);
    };

    FileHandle.prototype.readFile = function (options) {
      return promisify(this.vol, \\"readFile\\")(this.fd, options);
    };

    FileHandle.prototype.stat = function (options) {
      return promisify(this.vol, \\"fstat\\")(this.fd, options);
    };

    FileHandle.prototype.sync = function () {
      return promisify(this.vol, \\"fsync\\")(this.fd);
    };

    FileHandle.prototype.truncate = function (len) {
      return promisify(this.vol, \\"ftruncate\\")(this.fd, len);
    };

    FileHandle.prototype.utimes = function (atime, mtime) {
      return promisify(this.vol, \\"futimes\\")(this.fd, atime, mtime);
    };

    FileHandle.prototype.write = function (buffer, offset, length, position) {
      return promisify(this.vol, \\"write\\", function (bytesWritten) {
        return {
          bytesWritten: bytesWritten,
          buffer: buffer
        };
      })(this.fd, buffer, offset, length, position);
    };

    FileHandle.prototype.writeFile = function (data, options) {
      return promisify(this.vol, \\"writeFile\\")(this.fd, data, options);
    };

    return FileHandle;
  }();

  exports$6.FileHandle = FileHandle;

  function createPromisesApi(vol) {
    if (typeof Promise === \\"undefined\\") return null;
    return {
      FileHandle: FileHandle,
      access: function (path, mode) {
        return promisify(vol, \\"access\\")(path, mode);
      },
      appendFile: function (path, data, options) {
        return promisify(vol, \\"appendFile\\")(path instanceof FileHandle ? path.fd : path, data, options);
      },
      chmod: function (path, mode) {
        return promisify(vol, \\"chmod\\")(path, mode);
      },
      chown: function (path, uid, gid) {
        return promisify(vol, \\"chown\\")(path, uid, gid);
      },
      copyFile: function (src, dest, flags) {
        return promisify(vol, \\"copyFile\\")(src, dest, flags);
      },
      lchmod: function (path, mode) {
        return promisify(vol, \\"lchmod\\")(path, mode);
      },
      lchown: function (path, uid, gid) {
        return promisify(vol, \\"lchown\\")(path, uid, gid);
      },
      link: function (existingPath, newPath) {
        return promisify(vol, \\"link\\")(existingPath, newPath);
      },
      lstat: function (path, options) {
        return promisify(vol, \\"lstat\\")(path, options);
      },
      mkdir: function (path, options) {
        return promisify(vol, \\"mkdir\\")(path, options);
      },
      mkdtemp: function (prefix, options) {
        return promisify(vol, \\"mkdtemp\\")(prefix, options);
      },
      open: function (path, flags, mode) {
        return promisify(vol, \\"open\\", function (fd) {
          return new FileHandle(vol, fd);
        })(path, flags, mode);
      },
      readdir: function (path, options) {
        return promisify(vol, \\"readdir\\")(path, options);
      },
      readFile: function (id, options) {
        return promisify(vol, \\"readFile\\")(id instanceof FileHandle ? id.fd : id, options);
      },
      readlink: function (path, options) {
        return promisify(vol, \\"readlink\\")(path, options);
      },
      realpath: function (path, options) {
        return promisify(vol, \\"realpath\\")(path, options);
      },
      rename: function (oldPath, newPath) {
        return promisify(vol, \\"rename\\")(oldPath, newPath);
      },
      rmdir: function (path) {
        return promisify(vol, \\"rmdir\\")(path);
      },
      stat: function (path, options) {
        return promisify(vol, \\"stat\\")(path, options);
      },
      symlink: function (target, path, type) {
        return promisify(vol, \\"symlink\\")(target, path, type);
      },
      truncate: function (path, len) {
        return promisify(vol, \\"truncate\\")(path, len);
      },
      unlink: function (path) {
        return promisify(vol, \\"unlink\\")(path);
      },
      utimes: function (path, atime, mtime) {
        return promisify(vol, \\"utimes\\")(path, atime, mtime);
      },
      writeFile: function (id, data, options) {
        return promisify(vol, \\"writeFile\\")(id instanceof FileHandle ? id.fd : id, data, options);
      }
    };
  }

  exports$6.default = createPromisesApi;
  return exports$6;
}

var exports$5 = {},
    _dewExec$3 = false;
function dew$3() {
  if (_dewExec$3) return exports$5;
  _dewExec$3 = true;
  var process$1 = process;
  Object.defineProperty(exports$5, \\"__esModule\\", {
    value: true
  });
  exports$5.unixify = unixify;
  exports$5.correctPath = correctPath;
  var isWin = process$1.platform === \\"win32\\";

  function removeTrailingSeparator(str) {
    var i = str.length - 1;

    if (i < 2) {
      return str;
    }

    while (isSeparator(str, i)) {
      i--;
    }

    return str.substr(0, i + 1);
  }

  function isSeparator(str, i) {
    var _char = str[i];
    return i > 0 && (_char === \\"/\\" || isWin && _char === \\"\\\\\\\\\\");
  }

  function normalizePath(str, stripTrailing) {
    if (typeof str !== \\"string\\") {
      throw new TypeError(\\"expected a string\\");
    }

    str = str.replace(/[\\\\\\\\\\\\/]+/g, \\"/\\");

    if (stripTrailing !== false) {
      str = removeTrailingSeparator(str);
    }

    return str;
  }

  function unixify(filepath) {
    var stripTrailing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    if (isWin) {
      filepath = normalizePath(filepath, stripTrailing);
      return filepath.replace(/^([a-zA-Z]+:|\\\\.\\\\/)/, \\"\\");
    }

    return filepath;
  }

  function correctPath(filepath) {
    return unixify(filepath.replace(/^\\\\\\\\\\\\\\\\\\\\?\\\\\\\\.:\\\\\\\\/, \\"\\\\\\\\\\"));
  }

  return exports$5;
}

var exports$4 = {},
    _dewExec$2 = false;

var _global = typeof globalThis !== \\"undefined\\" ? globalThis : typeof self !== \\"undefined\\" ? self : global;

function dew$2() {
  if (_dewExec$2) return exports$4;
  _dewExec$2 = true;

  var __extends = exports$4 && exports$4.__extends || function () {
    var extendStatics = function (d, b) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      };

      return extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== \\"function\\" && b !== null) throw new TypeError(\\"Class extends value \\" + String(b) + \\" is not a constructor or null\\");
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __spreadArray = exports$4 && exports$4.__spreadArray || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };

  Object.defineProperty(exports$4, \\"__esModule\\", {
    value: true
  });
  exports$4.FSWatcher = exports$4.StatWatcher = exports$4.Volume = exports$4.toUnixTimestamp = exports$4.bufferToEncoding = exports$4.dataToBuffer = exports$4.dataToStr = exports$4.pathToSteps = exports$4.filenameToSteps = exports$4.pathToFilename = exports$4.flagsToNumber = exports$4.FLAGS = void 0;
  var pathModule = exports$i;

  var node_1 = dew$6();

  var Stats_1 = dew$d();

  var Dirent_1 = dew$9();

  var buffer_1 = dew$c();

  var setImmediate_1 = dew$8();

  var process_1 = dew$7();

  var setTimeoutUnref_1 = dew$5();

  var stream_1 = exports$j;

  var constants_1 = dew$f();

  var events_1 = y;

  var encoding_1 = dew$a();

  var errors = dew$b();

  var util = X;

  var promises_1 = dew$4();

  var resolveCrossPlatform = pathModule.resolve;
  var O_RDONLY = constants_1.constants.O_RDONLY,
      O_WRONLY = constants_1.constants.O_WRONLY,
      O_RDWR = constants_1.constants.O_RDWR,
      O_CREAT = constants_1.constants.O_CREAT,
      O_EXCL = constants_1.constants.O_EXCL,
      O_TRUNC = constants_1.constants.O_TRUNC,
      O_APPEND = constants_1.constants.O_APPEND,
      O_SYNC = constants_1.constants.O_SYNC,
      O_DIRECTORY = constants_1.constants.O_DIRECTORY,
      F_OK = constants_1.constants.F_OK,
      COPYFILE_EXCL = constants_1.constants.COPYFILE_EXCL,
      COPYFILE_FICLONE_FORCE = constants_1.constants.COPYFILE_FICLONE_FORCE;

  var _a = pathModule.posix ? pathModule.posix : pathModule,
      sep = _a.sep,
      relative = _a.relative,
      join = _a.join,
      dirname = _a.dirname;

  var isWin = process_1.default.platform === \\"win32\\";
  var kMinPoolSpace = 128; // const kMaxLength = require('buffer').kMaxLength;
  // ---------------------------------------- Error messages
  // TODO: Use \`internal/errors.js\` in the future.

  var ERRSTR = {
    PATH_STR: \\"path must be a string or Buffer\\",
    // FD:             'file descriptor must be a unsigned 32-bit integer',
    FD: \\"fd must be a file descriptor\\",
    MODE_INT: \\"mode must be an int\\",
    CB: \\"callback must be a function\\",
    UID: \\"uid must be an unsigned int\\",
    GID: \\"gid must be an unsigned int\\",
    LEN: \\"len must be an integer\\",
    ATIME: \\"atime must be an integer\\",
    MTIME: \\"mtime must be an integer\\",
    PREFIX: \\"filename prefix is required\\",
    BUFFER: \\"buffer must be an instance of Buffer or StaticBuffer\\",
    OFFSET: \\"offset must be an integer\\",
    LENGTH: \\"length must be an integer\\",
    POSITION: \\"position must be an integer\\"
  };

  var ERRSTR_OPTS = function (tipeof) {
    return \\"Expected options to be either an object or a string, but got \\" + tipeof + \\" instead\\";
  }; // const ERRSTR_FLAG = flag => \`Unknown file open flag: \${flag}\`;


  var ENOENT = \\"ENOENT\\";
  var EBADF = \\"EBADF\\";
  var EINVAL = \\"EINVAL\\";
  var EPERM = \\"EPERM\\";
  var EPROTO = \\"EPROTO\\";
  var EEXIST = \\"EEXIST\\";
  var ENOTDIR = \\"ENOTDIR\\";
  var EMFILE = \\"EMFILE\\";
  var EACCES = \\"EACCES\\";
  var EISDIR = \\"EISDIR\\";
  var ENOTEMPTY = \\"ENOTEMPTY\\";
  var ENOSYS = \\"ENOSYS\\";

  function formatError(errorCode, func, path, path2) {
    if (func === void 0) {
      func = \\"\\";
    }

    if (path === void 0) {
      path = \\"\\";
    }

    if (path2 === void 0) {
      path2 = \\"\\";
    }

    var pathFormatted = \\"\\";
    if (path) pathFormatted = \\" '\\" + path + \\"'\\";
    if (path2) pathFormatted += \\" -> '\\" + path2 + \\"'\\";

    switch (errorCode) {
      case ENOENT:
        return \\"ENOENT: no such file or directory, \\" + func + pathFormatted;

      case EBADF:
        return \\"EBADF: bad file descriptor, \\" + func + pathFormatted;

      case EINVAL:
        return \\"EINVAL: invalid argument, \\" + func + pathFormatted;

      case EPERM:
        return \\"EPERM: operation not permitted, \\" + func + pathFormatted;

      case EPROTO:
        return \\"EPROTO: protocol error, \\" + func + pathFormatted;

      case EEXIST:
        return \\"EEXIST: file already exists, \\" + func + pathFormatted;

      case ENOTDIR:
        return \\"ENOTDIR: not a directory, \\" + func + pathFormatted;

      case EISDIR:
        return \\"EISDIR: illegal operation on a directory, \\" + func + pathFormatted;

      case EACCES:
        return \\"EACCES: permission denied, \\" + func + pathFormatted;

      case ENOTEMPTY:
        return \\"ENOTEMPTY: directory not empty, \\" + func + pathFormatted;

      case EMFILE:
        return \\"EMFILE: too many open files, \\" + func + pathFormatted;

      case ENOSYS:
        return \\"ENOSYS: function not implemented, \\" + func + pathFormatted;

      default:
        return errorCode + \\": error occurred, \\" + func + pathFormatted;
    }
  }

  function createError(errorCode, func, path, path2, Constructor) {
    if (func === void 0) {
      func = \\"\\";
    }

    if (path === void 0) {
      path = \\"\\";
    }

    if (path2 === void 0) {
      path2 = \\"\\";
    }

    if (Constructor === void 0) {
      Constructor = Error;
    }

    var error = new Constructor(formatError(errorCode, func, path, path2));
    error.code = errorCode;
    return error;
  } // ---------------------------------------- Flags
  // List of file \`flags\` as defined by Node.


  var FLAGS;

  (function (FLAGS) {
    // Open file for reading. An exception occurs if the file does not exist.
    FLAGS[FLAGS[\\"r\\"] = O_RDONLY] = \\"r\\"; // Open file for reading and writing. An exception occurs if the file does not exist.

    FLAGS[FLAGS[\\"r+\\"] = O_RDWR] = \\"r+\\"; // Open file for reading in synchronous mode. Instructs the operating system to bypass the local file system cache.

    FLAGS[FLAGS[\\"rs\\"] = O_RDONLY | O_SYNC] = \\"rs\\";
    FLAGS[FLAGS[\\"sr\\"] = FLAGS.rs] = \\"sr\\"; // Open file for reading and writing, telling the OS to open it synchronously. See notes for 'rs' about using this with caution.

    FLAGS[FLAGS[\\"rs+\\"] = O_RDWR | O_SYNC] = \\"rs+\\";
    FLAGS[FLAGS[\\"sr+\\"] = FLAGS[\\"rs+\\"]] = \\"sr+\\"; // Open file for writing. The file is created (if it does not exist) or truncated (if it exists).

    FLAGS[FLAGS[\\"w\\"] = O_WRONLY | O_CREAT | O_TRUNC] = \\"w\\"; // Like 'w' but fails if path exists.

    FLAGS[FLAGS[\\"wx\\"] = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL] = \\"wx\\";
    FLAGS[FLAGS[\\"xw\\"] = FLAGS.wx] = \\"xw\\"; // Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).

    FLAGS[FLAGS[\\"w+\\"] = O_RDWR | O_CREAT | O_TRUNC] = \\"w+\\"; // Like 'w+' but fails if path exists.

    FLAGS[FLAGS[\\"wx+\\"] = O_RDWR | O_CREAT | O_TRUNC | O_EXCL] = \\"wx+\\";
    FLAGS[FLAGS[\\"xw+\\"] = FLAGS[\\"wx+\\"]] = \\"xw+\\"; // Open file for appending. The file is created if it does not exist.

    FLAGS[FLAGS[\\"a\\"] = O_WRONLY | O_APPEND | O_CREAT] = \\"a\\"; // Like 'a' but fails if path exists.

    FLAGS[FLAGS[\\"ax\\"] = O_WRONLY | O_APPEND | O_CREAT | O_EXCL] = \\"ax\\";
    FLAGS[FLAGS[\\"xa\\"] = FLAGS.ax] = \\"xa\\"; // Open file for reading and appending. The file is created if it does not exist.

    FLAGS[FLAGS[\\"a+\\"] = O_RDWR | O_APPEND | O_CREAT] = \\"a+\\"; // Like 'a+' but fails if path exists.

    FLAGS[FLAGS[\\"ax+\\"] = O_RDWR | O_APPEND | O_CREAT | O_EXCL] = \\"ax+\\";
    FLAGS[FLAGS[\\"xa+\\"] = FLAGS[\\"ax+\\"]] = \\"xa+\\";
  })(FLAGS = exports$4.FLAGS || (exports$4.FLAGS = {}));

  function flagsToNumber(flags) {
    if (typeof flags === \\"number\\") return flags;

    if (typeof flags === \\"string\\") {
      var flagsNum = FLAGS[flags];
      if (typeof flagsNum !== \\"undefined\\") return flagsNum;
    } // throw new TypeError(formatError(ERRSTR_FLAG(flags)));


    throw new errors.TypeError(\\"ERR_INVALID_OPT_VALUE\\", \\"flags\\", flags);
  }

  exports$4.flagsToNumber = flagsToNumber; // ---------------------------------------- Options

  function getOptions(defaults, options) {
    var opts;
    if (!options) return defaults;else {
      var tipeof = typeof options;

      switch (tipeof) {
        case \\"string\\":
          opts = Object.assign({}, defaults, {
            encoding: options
          });
          break;

        case \\"object\\":
          opts = Object.assign({}, defaults, options);
          break;

        default:
          throw TypeError(ERRSTR_OPTS(tipeof));
      }
    }
    if (opts.encoding !== \\"buffer\\") (0, encoding_1.assertEncoding)(opts.encoding);
    return opts;
  }

  function optsGenerator(defaults) {
    return function (options) {
      return getOptions(defaults, options);
    };
  }

  function validateCallback(callback) {
    if (typeof callback !== \\"function\\") throw TypeError(ERRSTR.CB);
    return callback;
  }

  function optsAndCbGenerator(getOpts) {
    return function (options, callback) {
      return typeof options === \\"function\\" ? [getOpts(), options] : [getOpts(options), validateCallback(callback)];
    };
  }

  var optsDefaults = {
    encoding: \\"utf8\\"
  };
  var getDefaultOpts = optsGenerator(optsDefaults);
  var getDefaultOptsAndCb = optsAndCbGenerator(getDefaultOpts);
  var readFileOptsDefaults = {
    flag: \\"r\\"
  };
  var getReadFileOptions = optsGenerator(readFileOptsDefaults);
  var writeFileDefaults = {
    encoding: \\"utf8\\",
    mode: 438
    /* DEFAULT */
    ,
    flag: FLAGS[FLAGS.w]
  };
  var getWriteFileOptions = optsGenerator(writeFileDefaults);
  var appendFileDefaults = {
    encoding: \\"utf8\\",
    mode: 438
    /* DEFAULT */
    ,
    flag: FLAGS[FLAGS.a]
  };
  var getAppendFileOpts = optsGenerator(appendFileDefaults);
  var getAppendFileOptsAndCb = optsAndCbGenerator(getAppendFileOpts);
  var realpathDefaults = optsDefaults;
  var getRealpathOptions = optsGenerator(realpathDefaults);
  var getRealpathOptsAndCb = optsAndCbGenerator(getRealpathOptions);
  var mkdirDefaults = {
    mode: 511
    /* DIR */
    ,
    recursive: false
  };

  var getMkdirOptions = function (options) {
    if (typeof options === \\"number\\") return Object.assign({}, mkdirDefaults, {
      mode: options
    });
    return Object.assign({}, mkdirDefaults, options);
  };

  var rmdirDefaults = {
    recursive: false
  };

  var getRmdirOptions = function (options) {
    return Object.assign({}, rmdirDefaults, options);
  };

  var readdirDefaults = {
    encoding: \\"utf8\\",
    withFileTypes: false
  };
  var getReaddirOptions = optsGenerator(readdirDefaults);
  var getReaddirOptsAndCb = optsAndCbGenerator(getReaddirOptions);
  var statDefaults = {
    bigint: false
  };

  var getStatOptions = function (options) {
    if (options === void 0) {
      options = {};
    }

    return Object.assign({}, statDefaults, options);
  };

  var getStatOptsAndCb = function (options, callback) {
    return typeof options === \\"function\\" ? [getStatOptions(), options] : [getStatOptions(options), validateCallback(callback)];
  }; // ---------------------------------------- Utility functions


  function getPathFromURLPosix(url) {
    if (url.hostname !== \\"\\") {
      throw new errors.TypeError(\\"ERR_INVALID_FILE_URL_HOST\\", process_1.default.platform);
    }

    var pathname = url.pathname;

    for (var n = 0; n < pathname.length; n++) {
      if (pathname[n] === \\"%\\") {
        var third = pathname.codePointAt(n + 2) | 32;

        if (pathname[n + 1] === \\"2\\" && third === 102) {
          throw new errors.TypeError(\\"ERR_INVALID_FILE_URL_PATH\\", \\"must not include encoded / characters\\");
        }
      }
    }

    return decodeURIComponent(pathname);
  }

  function pathToFilename(path) {
    if (typeof path !== \\"string\\" && !buffer_1.Buffer.isBuffer(path)) {
      try {
        if (!(path instanceof h.URL)) throw new TypeError(ERRSTR.PATH_STR);
      } catch (err) {
        throw new TypeError(ERRSTR.PATH_STR);
      }

      path = getPathFromURLPosix(path);
    }

    var pathString = String(path);
    nullCheck(pathString); // return slash(pathString);

    return pathString;
  }

  exports$4.pathToFilename = pathToFilename;

  var resolve = function (filename, base) {
    if (base === void 0) {
      base = process_1.default.cwd();
    }

    return resolveCrossPlatform(base, filename);
  };

  if (isWin) {
    var _resolve_1 = resolve;

    var unixify_1 = dew$3().unixify;

    resolve = function (filename, base) {
      return unixify_1(_resolve_1(filename, base));
    };
  }

  function filenameToSteps(filename, base) {
    var fullPath = resolve(filename, base);
    var fullPathSansSlash = fullPath.substr(1);
    if (!fullPathSansSlash) return [];
    return fullPathSansSlash.split(sep);
  }

  exports$4.filenameToSteps = filenameToSteps;

  function pathToSteps(path) {
    return filenameToSteps(pathToFilename(path));
  }

  exports$4.pathToSteps = pathToSteps;

  function dataToStr(data, encoding) {
    if (encoding === void 0) {
      encoding = encoding_1.ENCODING_UTF8;
    }

    if (buffer_1.Buffer.isBuffer(data)) return data.toString(encoding);else if (data instanceof Uint8Array) return (0, buffer_1.bufferFrom)(data).toString(encoding);else return String(data);
  }

  exports$4.dataToStr = dataToStr;

  function dataToBuffer(data, encoding) {
    if (encoding === void 0) {
      encoding = encoding_1.ENCODING_UTF8;
    }

    if (buffer_1.Buffer.isBuffer(data)) return data;else if (data instanceof Uint8Array) return (0, buffer_1.bufferFrom)(data);else return (0, buffer_1.bufferFrom)(String(data), encoding);
  }

  exports$4.dataToBuffer = dataToBuffer;

  function bufferToEncoding(buffer, encoding) {
    if (!encoding || encoding === \\"buffer\\") return buffer;else return buffer.toString(encoding);
  }

  exports$4.bufferToEncoding = bufferToEncoding;

  function nullCheck(path, callback) {
    if ((\\"\\" + path).indexOf(\\"\\\\0\\") !== -1) {
      var er = new Error(\\"Path must be a string without null bytes\\");
      er.code = ENOENT;
      if (typeof callback !== \\"function\\") throw er;
      process_1.default.nextTick(callback, er);
      return false;
    }

    return true;
  }

  function _modeToNumber(mode, def) {
    if (typeof mode === \\"number\\") return mode;
    if (typeof mode === \\"string\\") return parseInt(mode, 8);
    if (def) return modeToNumber(def);
    return undefined;
  }

  function modeToNumber(mode, def) {
    var result = _modeToNumber(mode, def);

    if (typeof result !== \\"number\\" || isNaN(result)) throw new TypeError(ERRSTR.MODE_INT);
    return result;
  }

  function isFd(path) {
    return path >>> 0 === path;
  }

  function validateFd(fd) {
    if (!isFd(fd)) throw TypeError(ERRSTR.FD);
  } // converts Date or number to a fractional UNIX timestamp


  function toUnixTimestamp(time) {
    // tslint:disable-next-line triple-equals
    if (typeof time === \\"string\\" && +time == time) {
      return +time;
    }

    if (time instanceof Date) {
      return time.getTime() / 1000;
    }

    if (isFinite(time)) {
      if (time < 0) {
        return Date.now() / 1000;
      }

      return time;
    }

    throw new Error(\\"Cannot parse time: \\" + time);
  }

  exports$4.toUnixTimestamp = toUnixTimestamp;

  function validateUid(uid) {
    if (typeof uid !== \\"number\\") throw TypeError(ERRSTR.UID);
  }

  function validateGid(gid) {
    if (typeof gid !== \\"number\\") throw TypeError(ERRSTR.GID);
  }

  function flattenJSON(nestedJSON) {
    var flatJSON = {};

    function flatten(pathPrefix, node) {
      for (var path in node) {
        var contentOrNode = node[path];
        var joinedPath = join(pathPrefix, path);

        if (typeof contentOrNode === \\"string\\") {
          flatJSON[joinedPath] = contentOrNode;
        } else if (typeof contentOrNode === \\"object\\" && contentOrNode !== null && Object.keys(contentOrNode).length > 0) {
          // empty directories need an explicit entry and therefore get handled in \`else\`, non-empty ones are implicitly considered
          flatten(joinedPath, contentOrNode);
        } else {
          // without this branch null, empty-object or non-object entries would not be handled in the same way
          // by both fromJSON() and fromNestedJSON()
          flatJSON[joinedPath] = null;
        }
      }
    }

    flatten(\\"\\", nestedJSON);
    return flatJSON;
  }
  /**
   * \`Volume\` represents a file system.
   */


  var Volume = function () {
    function Volume(props) {
      if (props === void 0) {
        props = {};
      } // I-node number counter.


      this.ino = 0; // A mapping for i-node numbers to i-nodes (\`Node\`);

      this.inodes = {}; // List of released i-node numbers, for reuse.

      this.releasedInos = []; // A mapping for file descriptors to \`File\`s.

      this.fds = {}; // A list of reusable (opened and closed) file descriptors, that should be
      // used first before creating a new file descriptor.

      this.releasedFds = []; // Max number of open files.

      this.maxFiles = 10000; // Current number of open files.

      this.openFiles = 0;
      this.promisesApi = (0, promises_1.default)(this);
      this.statWatchers = {};
      this.props = Object.assign({
        Node: node_1.Node,
        Link: node_1.Link,
        File: node_1.File
      }, props);
      var root = this.createLink();
      root.setNode(this.createNode(true));
      var self = this; // tslint:disable-line no-this-assignment

      this.StatWatcher = function (_super) {
        __extends(StatWatcher, _super);

        function StatWatcher() {
          return _super.call(this, self) || this;
        }

        return StatWatcher;
      }(StatWatcher);

      var _ReadStream = FsReadStream;

      this.ReadStream = function (_super) {
        __extends(class_1, _super);

        function class_1() {
          var args = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }

          return _super.apply(this, __spreadArray([self], args, false)) || this;
        }

        return class_1;
      }(_ReadStream);

      var _WriteStream = FsWriteStream;

      this.WriteStream = function (_super) {
        __extends(class_2, _super);

        function class_2() {
          var args = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }

          return _super.apply(this, __spreadArray([self], args, false)) || this;
        }

        return class_2;
      }(_WriteStream);

      this.FSWatcher = function (_super) {
        __extends(FSWatcher, _super);

        function FSWatcher() {
          return _super.call(this, self) || this;
        }

        return FSWatcher;
      }(FSWatcher); // root.setChild('.', root);
      // root.getNode().nlink++;
      // root.setChild('..', root);
      // root.getNode().nlink++;


      this.root = root;
    }

    Volume.fromJSON = function (json, cwd) {
      var vol = new Volume();
      vol.fromJSON(json, cwd);
      return vol;
    };

    Volume.fromNestedJSON = function (json, cwd) {
      var vol = new Volume();
      vol.fromNestedJSON(json, cwd);
      return vol;
    };

    Object.defineProperty(Volume.prototype, \\"promises\\", {
      get: function () {
        if (this.promisesApi === null) throw new Error(\\"Promise is not supported in this environment.\\");
        return this.promisesApi;
      },
      enumerable: false,
      configurable: true
    });

    Volume.prototype.createLink = function (parent, name, isDirectory, perm) {
      if (isDirectory === void 0) {
        isDirectory = false;
      }

      if (!parent) {
        return new this.props.Link(this, null, \\"\\");
      }

      if (!name) {
        throw new Error(\\"createLink: name cannot be empty\\");
      }

      return parent.createChild(name, this.createNode(isDirectory, perm));
    };

    Volume.prototype.deleteLink = function (link) {
      var parent = link.parent;

      if (parent) {
        parent.deleteChild(link);
        return true;
      }

      return false;
    };

    Volume.prototype.newInoNumber = function () {
      var releasedFd = this.releasedInos.pop();
      if (releasedFd) return releasedFd;else {
        this.ino = (this.ino + 1) % 4294967295;
        return this.ino;
      }
    };

    Volume.prototype.newFdNumber = function () {
      var releasedFd = this.releasedFds.pop();
      return typeof releasedFd === \\"number\\" ? releasedFd : Volume.fd--;
    };

    Volume.prototype.createNode = function (isDirectory, perm) {
      if (isDirectory === void 0) {
        isDirectory = false;
      }

      var node = new this.props.Node(this.newInoNumber(), perm);
      if (isDirectory) node.setIsDirectory();
      this.inodes[node.ino] = node;
      return node;
    };

    Volume.prototype.getNode = function (ino) {
      return this.inodes[ino];
    };

    Volume.prototype.deleteNode = function (node) {
      node.del();
      delete this.inodes[node.ino];
      this.releasedInos.push(node.ino);
    }; // Generates 6 character long random string, used by \`mkdtemp\`.


    Volume.prototype.genRndStr = function () {
      var str = (Math.random() + 1).toString(36).substr(2, 6);
      if (str.length === 6) return str;else return this.genRndStr();
    }; // Returns a \`Link\` (hard link) referenced by path \\"split\\" into steps.


    Volume.prototype.getLink = function (steps) {
      return this.root.walk(steps);
    }; // Just link \`getLink\`, but throws a correct user error, if link to found.


    Volume.prototype.getLinkOrThrow = function (filename, funcName) {
      var steps = filenameToSteps(filename);
      var link = this.getLink(steps);
      if (!link) throw createError(ENOENT, funcName, filename);
      return link;
    }; // Just like \`getLink\`, but also dereference/resolves symbolic links.


    Volume.prototype.getResolvedLink = function (filenameOrSteps) {
      var steps = typeof filenameOrSteps === \\"string\\" ? filenameToSteps(filenameOrSteps) : filenameOrSteps;
      var link = this.root;
      var i = 0;

      while (i < steps.length) {
        var step = steps[i];
        link = link.getChild(step);
        if (!link) return null;
        var node = link.getNode();

        if (node.isSymlink()) {
          steps = node.symlink.concat(steps.slice(i + 1));
          link = this.root;
          i = 0;
          continue;
        }

        i++;
      }

      return link;
    }; // Just like \`getLinkOrThrow\`, but also dereference/resolves symbolic links.


    Volume.prototype.getResolvedLinkOrThrow = function (filename, funcName) {
      var link = this.getResolvedLink(filename);
      if (!link) throw createError(ENOENT, funcName, filename);
      return link;
    };

    Volume.prototype.resolveSymlinks = function (link) {
      // let node: Node = link.getNode();
      // while(link && node.isSymlink()) {
      //     link = this.getLink(node.symlink);
      //     if(!link) return null;
      //     node = link.getNode();
      // }
      // return link;
      return this.getResolvedLink(link.steps.slice(1));
    }; // Just like \`getLinkOrThrow\`, but also verifies that the link is a directory.


    Volume.prototype.getLinkAsDirOrThrow = function (filename, funcName) {
      var link = this.getLinkOrThrow(filename, funcName);
      if (!link.getNode().isDirectory()) throw createError(ENOTDIR, funcName, filename);
      return link;
    }; // Get the immediate parent directory of the link.


    Volume.prototype.getLinkParent = function (steps) {
      return this.root.walk(steps, steps.length - 1);
    };

    Volume.prototype.getLinkParentAsDirOrThrow = function (filenameOrSteps, funcName) {
      var steps = filenameOrSteps instanceof Array ? filenameOrSteps : filenameToSteps(filenameOrSteps);
      var link = this.getLinkParent(steps);
      if (!link) throw createError(ENOENT, funcName, sep + steps.join(sep));
      if (!link.getNode().isDirectory()) throw createError(ENOTDIR, funcName, sep + steps.join(sep));
      return link;
    };

    Volume.prototype.getFileByFd = function (fd) {
      return this.fds[String(fd)];
    };

    Volume.prototype.getFileByFdOrThrow = function (fd, funcName) {
      if (!isFd(fd)) throw TypeError(ERRSTR.FD);
      var file = this.getFileByFd(fd);
      if (!file) throw createError(EBADF, funcName);
      return file;
    };

    Volume.prototype.getNodeByIdOrCreate = function (id, flags, perm) {
      if (typeof id === \\"number\\") {
        var file = this.getFileByFd(id);
        if (!file) throw Error(\\"File nto found\\");
        return file.node;
      } else {
        var steps = pathToSteps(id);
        var link = this.getLink(steps);
        if (link) return link.getNode(); // Try creating a node if not found.

        if (flags & O_CREAT) {
          var dirLink = this.getLinkParent(steps);

          if (dirLink) {
            var name_1 = steps[steps.length - 1];
            link = this.createLink(dirLink, name_1, false, perm);
            return link.getNode();
          }
        }

        throw createError(ENOENT, \\"getNodeByIdOrCreate\\", pathToFilename(id));
      }
    };

    Volume.prototype.wrapAsync = function (method, args, callback) {
      var _this = this;

      validateCallback(callback);
      (0, setImmediate_1.default)(function () {
        var result;

        try {
          result = method.apply(_this, args);
        } catch (err) {
          callback(err);
          return;
        }

        callback(null, result);
      });
    };

    Volume.prototype._toJSON = function (link, json, path) {
      var _a;

      if (link === void 0) {
        link = this.root;
      }

      if (json === void 0) {
        json = {};
      }

      var isEmpty = true;
      var children = link.children;

      if (link.getNode().isFile()) {
        children = (_a = {}, _a[link.getName()] = link.parent.getChild(link.getName()), _a);
        link = link.parent;
      }

      for (var name_2 in children) {
        isEmpty = false;
        var child = link.getChild(name_2);

        if (!child) {
          throw new Error(\\"_toJSON: unexpected undefined\\");
        }

        var node = child.getNode();

        if (node.isFile()) {
          var filename = child.getPath();
          if (path) filename = relative(path, filename);
          json[filename] = node.getString();
        } else if (node.isDirectory()) {
          this._toJSON(child, json, path);
        }
      }

      var dirPath = link.getPath();
      if (path) dirPath = relative(path, dirPath);

      if (dirPath && isEmpty) {
        json[dirPath] = null;
      }

      return json;
    };

    Volume.prototype.toJSON = function (paths, json, isRelative) {
      if (json === void 0) {
        json = {};
      }

      if (isRelative === void 0) {
        isRelative = false;
      }

      var links = [];

      if (paths) {
        if (!(paths instanceof Array)) paths = [paths];

        for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
          var path = paths_1[_i];
          var filename = pathToFilename(path);
          var link = this.getResolvedLink(filename);
          if (!link) continue;
          links.push(link);
        }
      } else {
        links.push(this.root);
      }

      if (!links.length) return json;

      for (var _a = 0, links_1 = links; _a < links_1.length; _a++) {
        var link = links_1[_a];

        this._toJSON(link, json, isRelative ? link.getPath() : \\"\\");
      }

      return json;
    };

    Volume.prototype.fromJSON = function (json, cwd) {
      if (cwd === void 0) {
        cwd = process_1.default.cwd();
      }

      for (var filename in json) {
        var data = json[filename];
        filename = resolve(filename, cwd);

        if (typeof data === \\"string\\") {
          var dir = dirname(filename);
          this.mkdirpBase(dir, 511
          /* DIR */
          );
          this.writeFileSync(filename, data);
        } else {
          this.mkdirpBase(filename, 511
          /* DIR */
          );
        }
      }
    };

    Volume.prototype.fromNestedJSON = function (json, cwd) {
      this.fromJSON(flattenJSON(json), cwd);
    };

    Volume.prototype.reset = function () {
      this.ino = 0;
      this.inodes = {};
      this.releasedInos = [];
      this.fds = {};
      this.releasedFds = [];
      this.openFiles = 0;
      this.root = this.createLink();
      this.root.setNode(this.createNode(true));
    }; // Legacy interface


    Volume.prototype.mountSync = function (mountpoint, json) {
      this.fromJSON(json, mountpoint);
    };

    Volume.prototype.openLink = function (link, flagsNum, resolveSymlinks) {
      if (resolveSymlinks === void 0) {
        resolveSymlinks = true;
      }

      if (this.openFiles >= this.maxFiles) {
        // Too many open files.
        throw createError(EMFILE, \\"open\\", link.getPath());
      } // Resolve symlinks.


      var realLink = link;
      if (resolveSymlinks) realLink = this.resolveSymlinks(link);
      if (!realLink) throw createError(ENOENT, \\"open\\", link.getPath());
      var node = realLink.getNode(); // Check whether node is a directory

      if (node.isDirectory()) {
        if ((flagsNum & (O_RDONLY | O_RDWR | O_WRONLY)) !== O_RDONLY) throw createError(EISDIR, \\"open\\", link.getPath());
      } else {
        if (flagsNum & O_DIRECTORY) throw createError(ENOTDIR, \\"open\\", link.getPath());
      } // Check node permissions


      if (!(flagsNum & O_WRONLY)) {
        if (!node.canRead()) {
          throw createError(EACCES, \\"open\\", link.getPath());
        }
      }

      var file = new this.props.File(link, node, flagsNum, this.newFdNumber());
      this.fds[file.fd] = file;
      this.openFiles++;
      if (flagsNum & O_TRUNC) file.truncate();
      return file;
    };

    Volume.prototype.openFile = function (filename, flagsNum, modeNum, resolveSymlinks) {
      if (resolveSymlinks === void 0) {
        resolveSymlinks = true;
      }

      var steps = filenameToSteps(filename);
      var link = resolveSymlinks ? this.getResolvedLink(steps) : this.getLink(steps); // Try creating a new file, if it does not exist.

      if (!link && flagsNum & O_CREAT) {
        // const dirLink: Link = this.getLinkParent(steps);
        var dirLink = this.getResolvedLink(steps.slice(0, steps.length - 1)); // if(!dirLink) throw createError(ENOENT, 'open', filename);

        if (!dirLink) throw createError(ENOENT, \\"open\\", sep + steps.join(sep));

        if (flagsNum & O_CREAT && typeof modeNum === \\"number\\") {
          link = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);
        }
      }

      if (link) return this.openLink(link, flagsNum, resolveSymlinks);
      throw createError(ENOENT, \\"open\\", filename);
    };

    Volume.prototype.openBase = function (filename, flagsNum, modeNum, resolveSymlinks) {
      if (resolveSymlinks === void 0) {
        resolveSymlinks = true;
      }

      var file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);
      if (!file) throw createError(ENOENT, \\"open\\", filename);
      return file.fd;
    };

    Volume.prototype.openSync = function (path, flags, mode) {
      if (mode === void 0) {
        mode = 438
        /* DEFAULT */
        ;
      } // Validate (1) mode; (2) path; (3) flags - in that order.


      var modeNum = modeToNumber(mode);
      var fileName = pathToFilename(path);
      var flagsNum = flagsToNumber(flags);
      return this.openBase(fileName, flagsNum, modeNum);
    };

    Volume.prototype.open = function (path, flags, a, b) {
      var mode = a;
      var callback = b;

      if (typeof a === \\"function\\") {
        mode = 438
        /* DEFAULT */
        ;
        callback = a;
      }

      mode = mode || 438
      /* DEFAULT */
      ;
      var modeNum = modeToNumber(mode);
      var fileName = pathToFilename(path);
      var flagsNum = flagsToNumber(flags);
      this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum], callback);
    };

    Volume.prototype.closeFile = function (file) {
      if (!this.fds[file.fd]) return;
      this.openFiles--;
      delete this.fds[file.fd];
      this.releasedFds.push(file.fd);
    };

    Volume.prototype.closeSync = function (fd) {
      validateFd(fd);
      var file = this.getFileByFdOrThrow(fd, \\"close\\");
      this.closeFile(file);
    };

    Volume.prototype.close = function (fd, callback) {
      validateFd(fd);
      this.wrapAsync(this.closeSync, [fd], callback);
    };

    Volume.prototype.openFileOrGetById = function (id, flagsNum, modeNum) {
      if (typeof id === \\"number\\") {
        var file = this.fds[id];
        if (!file) throw createError(ENOENT);
        return file;
      } else {
        return this.openFile(pathToFilename(id), flagsNum, modeNum);
      }
    };

    Volume.prototype.readBase = function (fd, buffer, offset, length, position) {
      var file = this.getFileByFdOrThrow(fd);
      return file.read(buffer, Number(offset), Number(length), position);
    };

    Volume.prototype.readSync = function (fd, buffer, offset, length, position) {
      validateFd(fd);
      return this.readBase(fd, buffer, offset, length, position);
    };

    Volume.prototype.read = function (fd, buffer, offset, length, position, callback) {
      var _this = this;

      validateCallback(callback); // This \`if\` branch is from Node.js

      if (length === 0) {
        return process_1.default.nextTick(function () {
          if (callback) callback(null, 0, buffer);
        });
      }

      (0, setImmediate_1.default)(function () {
        try {
          var bytes = _this.readBase(fd, buffer, offset, length, position);

          callback(null, bytes, buffer);
        } catch (err) {
          callback(err);
        }
      });
    };

    Volume.prototype.readFileBase = function (id, flagsNum, encoding) {
      var result;
      var isUserFd = typeof id === \\"number\\";
      var userOwnsFd = isUserFd && isFd(id);
      var fd;
      if (userOwnsFd) fd = id;else {
        var filename = pathToFilename(id);
        var steps = filenameToSteps(filename);
        var link = this.getResolvedLink(steps);

        if (link) {
          var node = link.getNode();
          if (node.isDirectory()) throw createError(EISDIR, \\"open\\", link.getPath());
        }

        fd = this.openSync(id, flagsNum);
      }

      try {
        result = bufferToEncoding(this.getFileByFdOrThrow(fd).getBuffer(), encoding);
      } finally {
        if (!userOwnsFd) {
          this.closeSync(fd);
        }
      }

      return result;
    };

    Volume.prototype.readFileSync = function (file, options) {
      var opts = getReadFileOptions(options);
      var flagsNum = flagsToNumber(opts.flag);
      return this.readFileBase(file, flagsNum, opts.encoding);
    };

    Volume.prototype.readFile = function (id, a, b) {
      var _a = optsAndCbGenerator(getReadFileOptions)(a, b),
          opts = _a[0],
          callback = _a[1];

      var flagsNum = flagsToNumber(opts.flag);
      this.wrapAsync(this.readFileBase, [id, flagsNum, opts.encoding], callback);
    };

    Volume.prototype.writeBase = function (fd, buf, offset, length, position) {
      var file = this.getFileByFdOrThrow(fd, \\"write\\");
      return file.write(buf, offset, length, position);
    };

    Volume.prototype.writeSync = function (fd, a, b, c, d) {
      validateFd(fd);
      var encoding;
      var offset;
      var length;
      var position;
      var isBuffer = typeof a !== \\"string\\";

      if (isBuffer) {
        offset = (b || 0) | 0;
        length = c;
        position = d;
      } else {
        position = b;
        encoding = c;
      }

      var buf = dataToBuffer(a, encoding);

      if (isBuffer) {
        if (typeof length === \\"undefined\\") {
          length = buf.length;
        }
      } else {
        offset = 0;
        length = buf.length;
      }

      return this.writeBase(fd, buf, offset, length, position);
    };

    Volume.prototype.write = function (fd, a, b, c, d, e) {
      var _this = this;

      validateFd(fd);
      var offset;
      var length;
      var position;
      var encoding;
      var callback;
      var tipa = typeof a;
      var tipb = typeof b;
      var tipc = typeof c;
      var tipd = typeof d;

      if (tipa !== \\"string\\") {
        if (tipb === \\"function\\") {
          callback = b;
        } else if (tipc === \\"function\\") {
          offset = b | 0;
          callback = c;
        } else if (tipd === \\"function\\") {
          offset = b | 0;
          length = c;
          callback = d;
        } else {
          offset = b | 0;
          length = c;
          position = d;
          callback = e;
        }
      } else {
        if (tipb === \\"function\\") {
          callback = b;
        } else if (tipc === \\"function\\") {
          position = b;
          callback = c;
        } else if (tipd === \\"function\\") {
          position = b;
          encoding = c;
          callback = d;
        }
      }

      var buf = dataToBuffer(a, encoding);

      if (tipa !== \\"string\\") {
        if (typeof length === \\"undefined\\") length = buf.length;
      } else {
        offset = 0;
        length = buf.length;
      }

      var cb = validateCallback(callback);
      (0, setImmediate_1.default)(function () {
        try {
          var bytes = _this.writeBase(fd, buf, offset, length, position);

          if (tipa !== \\"string\\") {
            cb(null, bytes, buf);
          } else {
            cb(null, bytes, a);
          }
        } catch (err) {
          cb(err);
        }
      });
    };

    Volume.prototype.writeFileBase = function (id, buf, flagsNum, modeNum) {
      // console.log('writeFileBase', id, buf, flagsNum, modeNum);
      // const node = this.getNodeByIdOrCreate(id, flagsNum, modeNum);
      // node.setBuffer(buf);
      var isUserFd = typeof id === \\"number\\";
      var fd;
      if (isUserFd) fd = id;else {
        fd = this.openBase(pathToFilename(id), flagsNum, modeNum); // fd = this.openSync(id as PathLike, flagsNum, modeNum);
      }
      var offset = 0;
      var length = buf.length;
      var position = flagsNum & O_APPEND ? undefined : 0;

      try {
        while (length > 0) {
          var written = this.writeSync(fd, buf, offset, length, position);
          offset += written;
          length -= written;
          if (position !== undefined) position += written;
        }
      } finally {
        if (!isUserFd) this.closeSync(fd);
      }
    };

    Volume.prototype.writeFileSync = function (id, data, options) {
      var opts = getWriteFileOptions(options);
      var flagsNum = flagsToNumber(opts.flag);
      var modeNum = modeToNumber(opts.mode);
      var buf = dataToBuffer(data, opts.encoding);
      this.writeFileBase(id, buf, flagsNum, modeNum);
    };

    Volume.prototype.writeFile = function (id, data, a, b) {
      var options = a;
      var callback = b;

      if (typeof a === \\"function\\") {
        options = writeFileDefaults;
        callback = a;
      }

      var cb = validateCallback(callback);
      var opts = getWriteFileOptions(options);
      var flagsNum = flagsToNumber(opts.flag);
      var modeNum = modeToNumber(opts.mode);
      var buf = dataToBuffer(data, opts.encoding);
      this.wrapAsync(this.writeFileBase, [id, buf, flagsNum, modeNum], cb);
    };

    Volume.prototype.linkBase = function (filename1, filename2) {
      var steps1 = filenameToSteps(filename1);
      var link1 = this.getLink(steps1);
      if (!link1) throw createError(ENOENT, \\"link\\", filename1, filename2);
      var steps2 = filenameToSteps(filename2); // Check new link directory exists.

      var dir2 = this.getLinkParent(steps2);
      if (!dir2) throw createError(ENOENT, \\"link\\", filename1, filename2);
      var name = steps2[steps2.length - 1]; // Check if new file already exists.

      if (dir2.getChild(name)) throw createError(EEXIST, \\"link\\", filename1, filename2);
      var node = link1.getNode();
      node.nlink++;
      dir2.createChild(name, node);
    };

    Volume.prototype.copyFileBase = function (src, dest, flags) {
      var buf = this.readFileSync(src);

      if (flags & COPYFILE_EXCL) {
        if (this.existsSync(dest)) {
          throw createError(EEXIST, \\"copyFile\\", src, dest);
        }
      }

      if (flags & COPYFILE_FICLONE_FORCE) {
        throw createError(ENOSYS, \\"copyFile\\", src, dest);
      }

      this.writeFileBase(dest, buf, FLAGS.w, 438
      /* DEFAULT */
      );
    };

    Volume.prototype.copyFileSync = function (src, dest, flags) {
      var srcFilename = pathToFilename(src);
      var destFilename = pathToFilename(dest);
      return this.copyFileBase(srcFilename, destFilename, (flags || 0) | 0);
    };

    Volume.prototype.copyFile = function (src, dest, a, b) {
      var srcFilename = pathToFilename(src);
      var destFilename = pathToFilename(dest);
      var flags;
      var callback;

      if (typeof a === \\"function\\") {
        flags = 0;
        callback = a;
      } else {
        flags = a;
        callback = b;
      }

      validateCallback(callback);
      this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);
    };

    Volume.prototype.linkSync = function (existingPath, newPath) {
      var existingPathFilename = pathToFilename(existingPath);
      var newPathFilename = pathToFilename(newPath);
      this.linkBase(existingPathFilename, newPathFilename);
    };

    Volume.prototype.link = function (existingPath, newPath, callback) {
      var existingPathFilename = pathToFilename(existingPath);
      var newPathFilename = pathToFilename(newPath);
      this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);
    };

    Volume.prototype.unlinkBase = function (filename) {
      var steps = filenameToSteps(filename);
      var link = this.getLink(steps);
      if (!link) throw createError(ENOENT, \\"unlink\\", filename); // TODO: Check if it is file, dir, other...

      if (link.length) throw Error(\\"Dir not empty...\\");
      this.deleteLink(link);
      var node = link.getNode();
      node.nlink--; // When all hard links to i-node are deleted, remove the i-node, too.

      if (node.nlink <= 0) {
        this.deleteNode(node);
      }
    };

    Volume.prototype.unlinkSync = function (path) {
      var filename = pathToFilename(path);
      this.unlinkBase(filename);
    };

    Volume.prototype.unlink = function (path, callback) {
      var filename = pathToFilename(path);
      this.wrapAsync(this.unlinkBase, [filename], callback);
    };

    Volume.prototype.symlinkBase = function (targetFilename, pathFilename) {
      var pathSteps = filenameToSteps(pathFilename); // Check if directory exists, where we about to create a symlink.

      var dirLink = this.getLinkParent(pathSteps);
      if (!dirLink) throw createError(ENOENT, \\"symlink\\", targetFilename, pathFilename);
      var name = pathSteps[pathSteps.length - 1]; // Check if new file already exists.

      if (dirLink.getChild(name)) throw createError(EEXIST, \\"symlink\\", targetFilename, pathFilename); // Create symlink.

      var symlink = dirLink.createChild(name);
      symlink.getNode().makeSymlink(filenameToSteps(targetFilename));
      return symlink;
    }; // \`type\` argument works only on Windows.


    Volume.prototype.symlinkSync = function (target, path, type) {
      var targetFilename = pathToFilename(target);
      var pathFilename = pathToFilename(path);
      this.symlinkBase(targetFilename, pathFilename);
    };

    Volume.prototype.symlink = function (target, path, a, b) {
      var callback = validateCallback(typeof a === \\"function\\" ? a : b);
      var targetFilename = pathToFilename(target);
      var pathFilename = pathToFilename(path);
      this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);
    };

    Volume.prototype.realpathBase = function (filename, encoding) {
      var steps = filenameToSteps(filename);
      var realLink = this.getResolvedLink(steps);
      if (!realLink) throw createError(ENOENT, \\"realpath\\", filename);
      return (0, encoding_1.strToEncoding)(realLink.getPath(), encoding);
    };

    Volume.prototype.realpathSync = function (path, options) {
      return this.realpathBase(pathToFilename(path), getRealpathOptions(options).encoding);
    };

    Volume.prototype.realpath = function (path, a, b) {
      var _a = getRealpathOptsAndCb(a, b),
          opts = _a[0],
          callback = _a[1];

      var pathFilename = pathToFilename(path);
      this.wrapAsync(this.realpathBase, [pathFilename, opts.encoding], callback);
    };

    Volume.prototype.lstatBase = function (filename, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }

      var link = this.getLink(filenameToSteps(filename));
      if (!link) throw createError(ENOENT, \\"lstat\\", filename);
      return Stats_1.default.build(link.getNode(), bigint);
    };

    Volume.prototype.lstatSync = function (path, options) {
      return this.lstatBase(pathToFilename(path), getStatOptions(options).bigint);
    };

    Volume.prototype.lstat = function (path, a, b) {
      var _a = getStatOptsAndCb(a, b),
          opts = _a[0],
          callback = _a[1];

      this.wrapAsync(this.lstatBase, [pathToFilename(path), opts.bigint], callback);
    };

    Volume.prototype.statBase = function (filename, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }

      var link = this.getResolvedLink(filenameToSteps(filename));
      if (!link) throw createError(ENOENT, \\"stat\\", filename);
      return Stats_1.default.build(link.getNode(), bigint);
    };

    Volume.prototype.statSync = function (path, options) {
      return this.statBase(pathToFilename(path), getStatOptions(options).bigint);
    };

    Volume.prototype.stat = function (path, a, b) {
      var _a = getStatOptsAndCb(a, b),
          opts = _a[0],
          callback = _a[1];

      this.wrapAsync(this.statBase, [pathToFilename(path), opts.bigint], callback);
    };

    Volume.prototype.fstatBase = function (fd, bigint) {
      if (bigint === void 0) {
        bigint = false;
      }

      var file = this.getFileByFd(fd);
      if (!file) throw createError(EBADF, \\"fstat\\");
      return Stats_1.default.build(file.node, bigint);
    };

    Volume.prototype.fstatSync = function (fd, options) {
      return this.fstatBase(fd, getStatOptions(options).bigint);
    };

    Volume.prototype.fstat = function (fd, a, b) {
      var _a = getStatOptsAndCb(a, b),
          opts = _a[0],
          callback = _a[1];

      this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);
    };

    Volume.prototype.renameBase = function (oldPathFilename, newPathFilename) {
      var link = this.getLink(filenameToSteps(oldPathFilename));
      if (!link) throw createError(ENOENT, \\"rename\\", oldPathFilename, newPathFilename); // TODO: Check if it is directory, if non-empty, we cannot move it, right?

      var newPathSteps = filenameToSteps(newPathFilename); // Check directory exists for the new location.

      var newPathDirLink = this.getLinkParent(newPathSteps);
      if (!newPathDirLink) throw createError(ENOENT, \\"rename\\", oldPathFilename, newPathFilename); // TODO: Also treat cases with directories and symbolic links.
      // TODO: See: http://man7.org/linux/man-pages/man2/rename.2.html
      // Remove hard link from old folder.

      var oldLinkParent = link.parent;

      if (oldLinkParent) {
        oldLinkParent.deleteChild(link);
      } // Rename should overwrite the new path, if that exists.


      var name = newPathSteps[newPathSteps.length - 1];
      link.steps = __spreadArray(__spreadArray([], newPathDirLink.steps, true), [name], false);
      newPathDirLink.setChild(link.getName(), link);
    };

    Volume.prototype.renameSync = function (oldPath, newPath) {
      var oldPathFilename = pathToFilename(oldPath);
      var newPathFilename = pathToFilename(newPath);
      this.renameBase(oldPathFilename, newPathFilename);
    };

    Volume.prototype.rename = function (oldPath, newPath, callback) {
      var oldPathFilename = pathToFilename(oldPath);
      var newPathFilename = pathToFilename(newPath);
      this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);
    };

    Volume.prototype.existsBase = function (filename) {
      return !!this.statBase(filename);
    };

    Volume.prototype.existsSync = function (path) {
      try {
        return this.existsBase(pathToFilename(path));
      } catch (err) {
        return false;
      }
    };

    Volume.prototype.exists = function (path, callback) {
      var _this = this;

      var filename = pathToFilename(path);
      if (typeof callback !== \\"function\\") throw Error(ERRSTR.CB);
      (0, setImmediate_1.default)(function () {
        try {
          callback(_this.existsBase(filename));
        } catch (err) {
          callback(false);
        }
      });
    };

    Volume.prototype.accessBase = function (filename, mode) {
      this.getLinkOrThrow(filename, \\"access\\"); // TODO: Verify permissions
    };

    Volume.prototype.accessSync = function (path, mode) {
      if (mode === void 0) {
        mode = F_OK;
      }

      var filename = pathToFilename(path);
      mode = mode | 0;
      this.accessBase(filename, mode);
    };

    Volume.prototype.access = function (path, a, b) {
      var mode = F_OK;
      var callback;

      if (typeof a !== \\"function\\") {
        mode = a | 0; // cast to number

        callback = validateCallback(b);
      } else {
        callback = a;
      }

      var filename = pathToFilename(path);
      this.wrapAsync(this.accessBase, [filename, mode], callback);
    };

    Volume.prototype.appendFileSync = function (id, data, options) {
      if (options === void 0) {
        options = appendFileDefaults;
      }

      var opts = getAppendFileOpts(options); // force append behavior when using a supplied file descriptor

      if (!opts.flag || isFd(id)) opts.flag = \\"a\\";
      this.writeFileSync(id, data, opts);
    };

    Volume.prototype.appendFile = function (id, data, a, b) {
      var _a = getAppendFileOptsAndCb(a, b),
          opts = _a[0],
          callback = _a[1]; // force append behavior when using a supplied file descriptor


      if (!opts.flag || isFd(id)) opts.flag = \\"a\\";
      this.writeFile(id, data, opts, callback);
    };

    Volume.prototype.readdirBase = function (filename, options) {
      var steps = filenameToSteps(filename);
      var link = this.getResolvedLink(steps);
      if (!link) throw createError(ENOENT, \\"readdir\\", filename);
      var node = link.getNode();
      if (!node.isDirectory()) throw createError(ENOTDIR, \\"scandir\\", filename);

      if (options.withFileTypes) {
        var list_1 = [];

        for (var name_3 in link.children) {
          var child = link.getChild(name_3);

          if (!child) {
            continue;
          }

          list_1.push(Dirent_1.default.build(child, options.encoding));
        }

        if (!isWin && options.encoding !== \\"buffer\\") list_1.sort(function (a, b) {
          if (a.name < b.name) return -1;
          if (a.name > b.name) return 1;
          return 0;
        });
        return list_1;
      }

      var list = [];

      for (var name_4 in link.children) {
        list.push((0, encoding_1.strToEncoding)(name_4, options.encoding));
      }

      if (!isWin && options.encoding !== \\"buffer\\") list.sort();
      return list;
    };

    Volume.prototype.readdirSync = function (path, options) {
      var opts = getReaddirOptions(options);
      var filename = pathToFilename(path);
      return this.readdirBase(filename, opts);
    };

    Volume.prototype.readdir = function (path, a, b) {
      var _a = getReaddirOptsAndCb(a, b),
          options = _a[0],
          callback = _a[1];

      var filename = pathToFilename(path);
      this.wrapAsync(this.readdirBase, [filename, options], callback);
    };

    Volume.prototype.readlinkBase = function (filename, encoding) {
      var link = this.getLinkOrThrow(filename, \\"readlink\\");
      var node = link.getNode();
      if (!node.isSymlink()) throw createError(EINVAL, \\"readlink\\", filename);
      var str = sep + node.symlink.join(sep);
      return (0, encoding_1.strToEncoding)(str, encoding);
    };

    Volume.prototype.readlinkSync = function (path, options) {
      var opts = getDefaultOpts(options);
      var filename = pathToFilename(path);
      return this.readlinkBase(filename, opts.encoding);
    };

    Volume.prototype.readlink = function (path, a, b) {
      var _a = getDefaultOptsAndCb(a, b),
          opts = _a[0],
          callback = _a[1];

      var filename = pathToFilename(path);
      this.wrapAsync(this.readlinkBase, [filename, opts.encoding], callback);
    };

    Volume.prototype.fsyncBase = function (fd) {
      this.getFileByFdOrThrow(fd, \\"fsync\\");
    };

    Volume.prototype.fsyncSync = function (fd) {
      this.fsyncBase(fd);
    };

    Volume.prototype.fsync = function (fd, callback) {
      this.wrapAsync(this.fsyncBase, [fd], callback);
    };

    Volume.prototype.fdatasyncBase = function (fd) {
      this.getFileByFdOrThrow(fd, \\"fdatasync\\");
    };

    Volume.prototype.fdatasyncSync = function (fd) {
      this.fdatasyncBase(fd);
    };

    Volume.prototype.fdatasync = function (fd, callback) {
      this.wrapAsync(this.fdatasyncBase, [fd], callback);
    };

    Volume.prototype.ftruncateBase = function (fd, len) {
      var file = this.getFileByFdOrThrow(fd, \\"ftruncate\\");
      file.truncate(len);
    };

    Volume.prototype.ftruncateSync = function (fd, len) {
      this.ftruncateBase(fd, len);
    };

    Volume.prototype.ftruncate = function (fd, a, b) {
      var len = typeof a === \\"number\\" ? a : 0;
      var callback = validateCallback(typeof a === \\"number\\" ? b : a);
      this.wrapAsync(this.ftruncateBase, [fd, len], callback);
    };

    Volume.prototype.truncateBase = function (path, len) {
      var fd = this.openSync(path, \\"r+\\");

      try {
        this.ftruncateSync(fd, len);
      } finally {
        this.closeSync(fd);
      }
    };

    Volume.prototype.truncateSync = function (id, len) {
      if (isFd(id)) return this.ftruncateSync(id, len);
      this.truncateBase(id, len);
    };

    Volume.prototype.truncate = function (id, a, b) {
      var len = typeof a === \\"number\\" ? a : 0;
      var callback = validateCallback(typeof a === \\"number\\" ? b : a);
      if (isFd(id)) return this.ftruncate(id, len, callback);
      this.wrapAsync(this.truncateBase, [id, len], callback);
    };

    Volume.prototype.futimesBase = function (fd, atime, mtime) {
      var file = this.getFileByFdOrThrow(fd, \\"futimes\\");
      var node = file.node;
      node.atime = new Date(atime * 1000);
      node.mtime = new Date(mtime * 1000);
    };

    Volume.prototype.futimesSync = function (fd, atime, mtime) {
      this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));
    };

    Volume.prototype.futimes = function (fd, atime, mtime, callback) {
      this.wrapAsync(this.futimesBase, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
    };

    Volume.prototype.utimesBase = function (filename, atime, mtime) {
      var fd = this.openSync(filename, \\"r+\\");

      try {
        this.futimesBase(fd, atime, mtime);
      } finally {
        this.closeSync(fd);
      }
    };

    Volume.prototype.utimesSync = function (path, atime, mtime) {
      this.utimesBase(pathToFilename(path), toUnixTimestamp(atime), toUnixTimestamp(mtime));
    };

    Volume.prototype.utimes = function (path, atime, mtime, callback) {
      this.wrapAsync(this.utimesBase, [pathToFilename(path), toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
    };

    Volume.prototype.mkdirBase = function (filename, modeNum) {
      var steps = filenameToSteps(filename); // This will throw if user tries to create root dir \`fs.mkdirSync('/')\`.

      if (!steps.length) {
        throw createError(EEXIST, \\"mkdir\\", filename);
      }

      var dir = this.getLinkParentAsDirOrThrow(filename, \\"mkdir\\"); // Check path already exists.

      var name = steps[steps.length - 1];
      if (dir.getChild(name)) throw createError(EEXIST, \\"mkdir\\", filename);
      dir.createChild(name, this.createNode(true, modeNum));
    };
    /**
     * Creates directory tree recursively.
     * @param filename
     * @param modeNum
     */


    Volume.prototype.mkdirpBase = function (filename, modeNum) {
      var steps = filenameToSteps(filename);
      var link = this.root;

      for (var i = 0; i < steps.length; i++) {
        var step = steps[i];
        if (!link.getNode().isDirectory()) throw createError(ENOTDIR, \\"mkdir\\", link.getPath());
        var child = link.getChild(step);

        if (child) {
          if (child.getNode().isDirectory()) link = child;else throw createError(ENOTDIR, \\"mkdir\\", child.getPath());
        } else {
          link = link.createChild(step, this.createNode(true, modeNum));
        }
      }
    };

    Volume.prototype.mkdirSync = function (path, options) {
      var opts = getMkdirOptions(options);
      var modeNum = modeToNumber(opts.mode, 511);
      var filename = pathToFilename(path);
      if (opts.recursive) this.mkdirpBase(filename, modeNum);else this.mkdirBase(filename, modeNum);
    };

    Volume.prototype.mkdir = function (path, a, b) {
      var opts = getMkdirOptions(a);
      var callback = validateCallback(typeof a === \\"function\\" ? a : b);
      var modeNum = modeToNumber(opts.mode, 511);
      var filename = pathToFilename(path);
      if (opts.recursive) this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);else this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);
    }; // legacy interface


    Volume.prototype.mkdirpSync = function (path, mode) {
      this.mkdirSync(path, {
        mode: mode,
        recursive: true
      });
    };

    Volume.prototype.mkdirp = function (path, a, b) {
      var mode = typeof a === \\"function\\" ? undefined : a;
      var callback = validateCallback(typeof a === \\"function\\" ? a : b);
      this.mkdir(path, {
        mode: mode,
        recursive: true
      }, callback);
    };

    Volume.prototype.mkdtempBase = function (prefix, encoding, retry) {
      if (retry === void 0) {
        retry = 5;
      }

      var filename = prefix + this.genRndStr();

      try {
        this.mkdirBase(filename, 511
        /* DIR */
        );
        return (0, encoding_1.strToEncoding)(filename, encoding);
      } catch (err) {
        if (err.code === EEXIST) {
          if (retry > 1) return this.mkdtempBase(prefix, encoding, retry - 1);else throw Error(\\"Could not create temp dir.\\");
        } else throw err;
      }
    };

    Volume.prototype.mkdtempSync = function (prefix, options) {
      var encoding = getDefaultOpts(options).encoding;
      if (!prefix || typeof prefix !== \\"string\\") throw new TypeError(\\"filename prefix is required\\");
      nullCheck(prefix);
      return this.mkdtempBase(prefix, encoding);
    };

    Volume.prototype.mkdtemp = function (prefix, a, b) {
      var _a = getDefaultOptsAndCb(a, b),
          encoding = _a[0].encoding,
          callback = _a[1];

      if (!prefix || typeof prefix !== \\"string\\") throw new TypeError(\\"filename prefix is required\\");
      if (!nullCheck(prefix)) return;
      this.wrapAsync(this.mkdtempBase, [prefix, encoding], callback);
    };

    Volume.prototype.rmdirBase = function (filename, options) {
      var opts = getRmdirOptions(options);
      var link = this.getLinkAsDirOrThrow(filename, \\"rmdir\\"); // Check directory is empty.

      if (link.length && !opts.recursive) throw createError(ENOTEMPTY, \\"rmdir\\", filename);
      this.deleteLink(link);
    };

    Volume.prototype.rmdirSync = function (path, options) {
      this.rmdirBase(pathToFilename(path), options);
    };

    Volume.prototype.rmdir = function (path, a, b) {
      var opts = getRmdirOptions(a);
      var callback = validateCallback(typeof a === \\"function\\" ? a : b);
      this.wrapAsync(this.rmdirBase, [pathToFilename(path), opts], callback);
    };

    Volume.prototype.fchmodBase = function (fd, modeNum) {
      var file = this.getFileByFdOrThrow(fd, \\"fchmod\\");
      file.chmod(modeNum);
    };

    Volume.prototype.fchmodSync = function (fd, mode) {
      this.fchmodBase(fd, modeToNumber(mode));
    };

    Volume.prototype.fchmod = function (fd, mode, callback) {
      this.wrapAsync(this.fchmodBase, [fd, modeToNumber(mode)], callback);
    };

    Volume.prototype.chmodBase = function (filename, modeNum) {
      var fd = this.openSync(filename, \\"r+\\");

      try {
        this.fchmodBase(fd, modeNum);
      } finally {
        this.closeSync(fd);
      }
    };

    Volume.prototype.chmodSync = function (path, mode) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path);
      this.chmodBase(filename, modeNum);
    };

    Volume.prototype.chmod = function (path, mode, callback) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path);
      this.wrapAsync(this.chmodBase, [filename, modeNum], callback);
    };

    Volume.prototype.lchmodBase = function (filename, modeNum) {
      var fd = this.openBase(filename, O_RDWR, 0, false);

      try {
        this.fchmodBase(fd, modeNum);
      } finally {
        this.closeSync(fd);
      }
    };

    Volume.prototype.lchmodSync = function (path, mode) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path);
      this.lchmodBase(filename, modeNum);
    };

    Volume.prototype.lchmod = function (path, mode, callback) {
      var modeNum = modeToNumber(mode);
      var filename = pathToFilename(path);
      this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);
    };

    Volume.prototype.fchownBase = function (fd, uid, gid) {
      this.getFileByFdOrThrow(fd, \\"fchown\\").chown(uid, gid);
    };

    Volume.prototype.fchownSync = function (fd, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.fchownBase(fd, uid, gid);
    };

    Volume.prototype.fchown = function (fd, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);
    };

    Volume.prototype.chownBase = function (filename, uid, gid) {
      var link = this.getResolvedLinkOrThrow(filename, \\"chown\\");
      var node = link.getNode();
      node.chown(uid, gid); // if(node.isFile() || node.isSymlink()) {
      //
      // } else if(node.isDirectory()) {
      //
      // } else {
      // TODO: What do we do here?
      // }
    };

    Volume.prototype.chownSync = function (path, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.chownBase(pathToFilename(path), uid, gid);
    };

    Volume.prototype.chown = function (path, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.chownBase, [pathToFilename(path), uid, gid], callback);
    };

    Volume.prototype.lchownBase = function (filename, uid, gid) {
      this.getLinkOrThrow(filename, \\"lchown\\").getNode().chown(uid, gid);
    };

    Volume.prototype.lchownSync = function (path, uid, gid) {
      validateUid(uid);
      validateGid(gid);
      this.lchownBase(pathToFilename(path), uid, gid);
    };

    Volume.prototype.lchown = function (path, uid, gid, callback) {
      validateUid(uid);
      validateGid(gid);
      this.wrapAsync(this.lchownBase, [pathToFilename(path), uid, gid], callback);
    };

    Volume.prototype.watchFile = function (path, a, b) {
      var filename = pathToFilename(path);
      var options = a;
      var listener = b;

      if (typeof options === \\"function\\") {
        listener = a;
        options = null;
      }

      if (typeof listener !== \\"function\\") {
        throw Error(\\"\\\\\\"watchFile()\\\\\\" requires a listener function\\");
      }

      var interval = 5007;
      var persistent = true;

      if (options && typeof options === \\"object\\") {
        if (typeof options.interval === \\"number\\") interval = options.interval;
        if (typeof options.persistent === \\"boolean\\") persistent = options.persistent;
      }

      var watcher = this.statWatchers[filename];

      if (!watcher) {
        watcher = new this.StatWatcher();
        watcher.start(filename, persistent, interval);
        this.statWatchers[filename] = watcher;
      }

      watcher.addListener(\\"change\\", listener);
      return watcher;
    };

    Volume.prototype.unwatchFile = function (path, listener) {
      var filename = pathToFilename(path);
      var watcher = this.statWatchers[filename];
      if (!watcher) return;

      if (typeof listener === \\"function\\") {
        watcher.removeListener(\\"change\\", listener);
      } else {
        watcher.removeAllListeners(\\"change\\");
      }

      if (watcher.listenerCount(\\"change\\") === 0) {
        watcher.stop();
        delete this.statWatchers[filename];
      }
    };

    Volume.prototype.createReadStream = function (path, options) {
      return new this.ReadStream(path, options);
    };

    Volume.prototype.createWriteStream = function (path, options) {
      return new this.WriteStream(path, options);
    }; // watch(path: PathLike): FSWatcher;
    // watch(path: PathLike, options?: IWatchOptions | string): FSWatcher;


    Volume.prototype.watch = function (path, options, listener) {
      var filename = pathToFilename(path);
      var givenOptions = options;

      if (typeof options === \\"function\\") {
        listener = options;
        givenOptions = null;
      } // tslint:disable-next-line prefer-const


      var _a = getDefaultOpts(givenOptions),
          persistent = _a.persistent,
          recursive = _a.recursive,
          encoding = _a.encoding;

      if (persistent === undefined) persistent = true;
      if (recursive === undefined) recursive = false;
      var watcher = new this.FSWatcher();
      watcher.start(filename, persistent, recursive, encoding);

      if (listener) {
        watcher.addListener(\\"change\\", listener);
      }

      return watcher;
    };
    /**
     * Global file descriptor counter. UNIX file descriptors start from 0 and go sequentially
     * up, so here, in order not to conflict with them, we choose some big number and descrease
     * the file descriptor of every new opened file.
     * @type {number}
     * @todo This should not be static, right?
     */


    Volume.fd = 2147483647;
    return Volume;
  }();

  exports$4.Volume = Volume;

  function emitStop(self) {
    self.emit(\\"stop\\");
  }

  var StatWatcher = function (_super) {
    __extends(StatWatcher, _super);

    function StatWatcher(vol) {
      var _this = _super.call(this) || this;

      _this.onInterval = function () {
        try {
          var stats = _this.vol.statSync(_this.filename);

          if (_this.hasChanged(stats)) {
            _this.emit(\\"change\\", stats, _this.prev);

            _this.prev = stats;
          }
        } finally {
          _this.loop();
        }
      };

      _this.vol = vol;
      return _this;
    }

    StatWatcher.prototype.loop = function () {
      this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
    };

    StatWatcher.prototype.hasChanged = function (stats) {
      // if(!this.prev) return false;
      if (stats.mtimeMs > this.prev.mtimeMs) return true;
      if (stats.nlink !== this.prev.nlink) return true;
      return false;
    };

    StatWatcher.prototype.start = function (path, persistent, interval) {
      if (persistent === void 0) {
        persistent = true;
      }

      if (interval === void 0) {
        interval = 5007;
      }

      this.filename = pathToFilename(path);
      this.setTimeout = persistent ? setTimeout.bind(typeof globalThis !== \\"undefined\\" ? globalThis : _global) : setTimeoutUnref_1.default;
      this.interval = interval;
      this.prev = this.vol.statSync(this.filename);
      this.loop();
    };

    StatWatcher.prototype.stop = function () {
      clearTimeout(this.timeoutRef);
      process_1.default.nextTick(emitStop, this);
    };

    return StatWatcher;
  }(events_1.EventEmitter);

  exports$4.StatWatcher = StatWatcher;
  var pool;

  function allocNewPool(poolSize) {
    pool = (0, buffer_1.bufferAllocUnsafe)(poolSize);
    pool.used = 0;
  }

  util.inherits(FsReadStream, stream_1.Readable);
  exports$4.ReadStream = FsReadStream;

  function FsReadStream(vol, path, options) {
    if (!(this instanceof FsReadStream)) return new FsReadStream(vol, path, options);
    this._vol = vol; // a little bit bigger buffer and water marks by default

    options = Object.assign({}, getOptions(options, {}));
    if (options.highWaterMark === undefined) options.highWaterMark = 64 * 1024;
    stream_1.Readable.call(this, options);
    this.path = pathToFilename(path);
    this.fd = options.fd === undefined ? null : options.fd;
    this.flags = options.flags === undefined ? \\"r\\" : options.flags;
    this.mode = options.mode === undefined ? 438 : options.mode;
    this.start = options.start;
    this.end = options.end;
    this.autoClose = options.autoClose === undefined ? true : options.autoClose;
    this.pos = undefined;
    this.bytesRead = 0;

    if (this.start !== undefined) {
      if (typeof this.start !== \\"number\\") {
        throw new TypeError(\\"\\\\\\"start\\\\\\" option must be a Number\\");
      }

      if (this.end === undefined) {
        this.end = Infinity;
      } else if (typeof this.end !== \\"number\\") {
        throw new TypeError(\\"\\\\\\"end\\\\\\" option must be a Number\\");
      }

      if (this.start > this.end) {
        throw new Error(\\"\\\\\\"start\\\\\\" option must be <= \\\\\\"end\\\\\\" option\\");
      }

      this.pos = this.start;
    }

    if (typeof this.fd !== \\"number\\") this.open();
    this.on(\\"end\\", function () {
      if (this.autoClose) {
        if (this.destroy) this.destroy();
      }
    });
  }

  FsReadStream.prototype.open = function () {
    var self = this; // tslint:disable-line no-this-assignment

    this._vol.open(this.path, this.flags, this.mode, function (er, fd) {
      if (er) {
        if (self.autoClose) {
          if (self.destroy) self.destroy();
        }

        self.emit(\\"error\\", er);
        return;
      }

      self.fd = fd;
      self.emit(\\"open\\", fd); // start the flow of data.

      self.read();
    });
  };

  FsReadStream.prototype._read = function (n) {
    if (typeof this.fd !== \\"number\\") {
      return this.once(\\"open\\", function () {
        this._read(n);
      });
    }

    if (this.destroyed) return;

    if (!pool || pool.length - pool.used < kMinPoolSpace) {
      // discard the old pool.
      allocNewPool(this._readableState.highWaterMark);
    } // Grab another reference to the pool in the case that while we're
    // in the thread pool another read() finishes up the pool, and
    // allocates a new one.


    var thisPool = pool;
    var toRead = Math.min(pool.length - pool.used, n);
    var start = pool.used;
    if (this.pos !== undefined) toRead = Math.min(this.end - this.pos + 1, toRead); // already read everything we were supposed to read!
    // treat as EOF.

    if (toRead <= 0) return this.push(null); // the actual read.

    var self = this; // tslint:disable-line no-this-assignment

    this._vol.read(this.fd, pool, pool.used, toRead, this.pos, onread); // move the pool positions, and internal position for reading.


    if (this.pos !== undefined) this.pos += toRead;
    pool.used += toRead;

    function onread(er, bytesRead) {
      if (er) {
        if (self.autoClose && self.destroy) {
          self.destroy();
        }

        self.emit(\\"error\\", er);
      } else {
        var b = null;

        if (bytesRead > 0) {
          self.bytesRead += bytesRead;
          b = thisPool.slice(start, start + bytesRead);
        }

        self.push(b);
      }
    }
  };

  FsReadStream.prototype._destroy = function (err, cb) {
    this.close(function (err2) {
      cb(err || err2);
    });
  };

  FsReadStream.prototype.close = function (cb) {
    var _this = this;

    if (cb) this.once(\\"close\\", cb);

    if (this.closed || typeof this.fd !== \\"number\\") {
      if (typeof this.fd !== \\"number\\") {
        this.once(\\"open\\", closeOnOpen);
        return;
      }

      return process_1.default.nextTick(function () {
        return _this.emit(\\"close\\");
      });
    }

    this.closed = true;

    this._vol.close(this.fd, function (er) {
      if (er) _this.emit(\\"error\\", er);else _this.emit(\\"close\\");
    });

    this.fd = null;
  }; // needed because as it will be called with arguments
  // that does not match this.close() signature


  function closeOnOpen(fd) {
    this.close();
  }

  util.inherits(FsWriteStream, stream_1.Writable);
  exports$4.WriteStream = FsWriteStream;

  function FsWriteStream(vol, path, options) {
    if (!(this instanceof FsWriteStream)) return new FsWriteStream(vol, path, options);
    this._vol = vol;
    options = Object.assign({}, getOptions(options, {}));
    stream_1.Writable.call(this, options);
    this.path = pathToFilename(path);
    this.fd = options.fd === undefined ? null : options.fd;
    this.flags = options.flags === undefined ? \\"w\\" : options.flags;
    this.mode = options.mode === undefined ? 438 : options.mode;
    this.start = options.start;
    this.autoClose = options.autoClose === undefined ? true : !!options.autoClose;
    this.pos = undefined;
    this.bytesWritten = 0;

    if (this.start !== undefined) {
      if (typeof this.start !== \\"number\\") {
        throw new TypeError(\\"\\\\\\"start\\\\\\" option must be a Number\\");
      }

      if (this.start < 0) {
        throw new Error(\\"\\\\\\"start\\\\\\" must be >= zero\\");
      }

      this.pos = this.start;
    }

    if (options.encoding) this.setDefaultEncoding(options.encoding);
    if (typeof this.fd !== \\"number\\") this.open(); // dispose on finish.

    this.once(\\"finish\\", function () {
      if (this.autoClose) {
        this.close();
      }
    });
  }

  FsWriteStream.prototype.open = function () {
    this._vol.open(this.path, this.flags, this.mode, function (er, fd) {
      if (er) {
        if (this.autoClose && this.destroy) {
          this.destroy();
        }

        this.emit(\\"error\\", er);
        return;
      }

      this.fd = fd;
      this.emit(\\"open\\", fd);
    }.bind(this));
  };

  FsWriteStream.prototype._write = function (data, encoding, cb) {
    if (!(data instanceof buffer_1.Buffer)) return this.emit(\\"error\\", new Error(\\"Invalid data\\"));

    if (typeof this.fd !== \\"number\\") {
      return this.once(\\"open\\", function () {
        this._write(data, encoding, cb);
      });
    }

    var self = this; // tslint:disable-line no-this-assignment

    this._vol.write(this.fd, data, 0, data.length, this.pos, function (er, bytes) {
      if (er) {
        if (self.autoClose && self.destroy) {
          self.destroy();
        }

        return cb(er);
      }

      self.bytesWritten += bytes;
      cb();
    });

    if (this.pos !== undefined) this.pos += data.length;
  };

  FsWriteStream.prototype._writev = function (data, cb) {
    if (typeof this.fd !== \\"number\\") {
      return this.once(\\"open\\", function () {
        this._writev(data, cb);
      });
    }

    var self = this; // tslint:disable-line no-this-assignment

    var len = data.length;
    var chunks = new Array(len);
    var size = 0;

    for (var i = 0; i < len; i++) {
      var chunk = data[i].chunk;
      chunks[i] = chunk;
      size += chunk.length;
    }

    var buf = buffer_1.Buffer.concat(chunks);

    this._vol.write(this.fd, buf, 0, buf.length, this.pos, function (er, bytes) {
      if (er) {
        if (self.destroy) self.destroy();
        return cb(er);
      }

      self.bytesWritten += bytes;
      cb();
    });

    if (this.pos !== undefined) this.pos += size;
  };

  FsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;
  FsWriteStream.prototype.close = FsReadStream.prototype.close; // There is no shutdown() for files.

  FsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end; // ---------------------------------------- FSWatcher

  var FSWatcher = function (_super) {
    __extends(FSWatcher, _super);

    function FSWatcher(vol) {
      var _this = _super.call(this) || this;

      _this._filename = \\"\\";
      _this._filenameEncoded = \\"\\"; // _persistent: boolean = true;

      _this._recursive = false;
      _this._encoding = encoding_1.ENCODING_UTF8;

      _this._onNodeChange = function () {
        _this._emit(\\"change\\");
      };

      _this._onParentChild = function (link) {
        if (link.getName() === _this._getName()) {
          _this._emit(\\"rename\\");
        }
      };

      _this._emit = function (type) {
        _this.emit(\\"change\\", type, _this._filenameEncoded);
      };

      _this._persist = function () {
        _this._timer = setTimeout(_this._persist, 1000000);
      };

      _this._vol = vol;
      return _this; // TODO: Emit \\"error\\" messages when watching.
      // this._handle.onchange = function(status, eventType, filename) {
      //     if (status < 0) {
      //         self._handle.close();
      //         const error = !filename ?
      //             errnoException(status, 'Error watching file for changes:') :
      //             errnoException(status, \`Error watching file \${filename} for changes:\`);
      //         error.filename = filename;
      //         self.emit('error', error);
      //     } else {
      //         self.emit('change', eventType, filename);
      //     }
      // };
    }

    FSWatcher.prototype._getName = function () {
      return this._steps[this._steps.length - 1];
    };

    FSWatcher.prototype.start = function (path, persistent, recursive, encoding) {
      if (persistent === void 0) {
        persistent = true;
      }

      if (recursive === void 0) {
        recursive = false;
      }

      if (encoding === void 0) {
        encoding = encoding_1.ENCODING_UTF8;
      }

      this._filename = pathToFilename(path);
      this._steps = filenameToSteps(this._filename);
      this._filenameEncoded = (0, encoding_1.strToEncoding)(this._filename); // this._persistent = persistent;

      this._recursive = recursive;
      this._encoding = encoding;

      try {
        this._link = this._vol.getLinkOrThrow(this._filename, \\"FSWatcher\\");
      } catch (err) {
        var error = new Error(\\"watch \\" + this._filename + \\" \\" + err.code);
        error.code = err.code;
        error.errno = err.code;
        throw error;
      }

      this._link.getNode().on(\\"change\\", this._onNodeChange);

      this._link.on(\\"child:add\\", this._onNodeChange);

      this._link.on(\\"child:delete\\", this._onNodeChange);

      var parent = this._link.parent;

      if (parent) {
        // parent.on('child:add', this._onParentChild);
        parent.setMaxListeners(parent.getMaxListeners() + 1);
        parent.on(\\"child:delete\\", this._onParentChild);
      }

      if (persistent) this._persist();
    };

    FSWatcher.prototype.close = function () {
      clearTimeout(this._timer);

      this._link.getNode().removeListener(\\"change\\", this._onNodeChange);

      var parent = this._link.parent;

      if (parent) {
        // parent.removeListener('child:add', this._onParentChild);
        parent.removeListener(\\"child:delete\\", this._onParentChild);
      }
    };

    return FSWatcher;
  }(events_1.EventEmitter);

  exports$4.FSWatcher = FSWatcher;
  return exports$4;
}

var exports$3 = {},
    _dewExec$1 = false;
function dew$1() {
  if (_dewExec$1) return exports$3;
  _dewExec$1 = true;
  Object.defineProperty(exports$3, \\"__esModule\\", {
    value: true
  });
  exports$3.fsAsyncMethods = exports$3.fsSyncMethods = exports$3.fsProps = void 0;
  var fsProps = [\\"constants\\", \\"F_OK\\", \\"R_OK\\", \\"W_OK\\", \\"X_OK\\", \\"Stats\\"];
  exports$3.fsProps = fsProps;
  var fsSyncMethods = [\\"renameSync\\", \\"ftruncateSync\\", \\"truncateSync\\", \\"chownSync\\", \\"fchownSync\\", \\"lchownSync\\", \\"chmodSync\\", \\"fchmodSync\\", \\"lchmodSync\\", \\"statSync\\", \\"lstatSync\\", \\"fstatSync\\", \\"linkSync\\", \\"symlinkSync\\", \\"readlinkSync\\", \\"realpathSync\\", \\"unlinkSync\\", \\"rmdirSync\\", \\"mkdirSync\\", \\"mkdirpSync\\", \\"readdirSync\\", \\"closeSync\\", \\"openSync\\", \\"utimesSync\\", \\"futimesSync\\", \\"fsyncSync\\", \\"writeSync\\", \\"readSync\\", \\"readFileSync\\", \\"writeFileSync\\", \\"appendFileSync\\", \\"existsSync\\", \\"accessSync\\", \\"fdatasyncSync\\", \\"mkdtempSync\\", \\"copyFileSync\\", \\"createReadStream\\", \\"createWriteStream\\"];
  exports$3.fsSyncMethods = fsSyncMethods;
  var fsAsyncMethods = [\\"rename\\", \\"ftruncate\\", \\"truncate\\", \\"chown\\", \\"fchown\\", \\"lchown\\", \\"chmod\\", \\"fchmod\\", \\"lchmod\\", \\"stat\\", \\"lstat\\", \\"fstat\\", \\"link\\", \\"symlink\\", \\"readlink\\", \\"realpath\\", \\"unlink\\", \\"rmdir\\", \\"mkdir\\", \\"mkdirp\\", \\"readdir\\", \\"close\\", \\"open\\", \\"utimes\\", \\"futimes\\", \\"fsync\\", \\"write\\", \\"read\\", \\"readFile\\", \\"writeFile\\", \\"appendFile\\", \\"exists\\", \\"access\\", \\"fdatasync\\", \\"mkdtemp\\", \\"copyFile\\", \\"watchFile\\", \\"unwatchFile\\", \\"watch\\"];
  exports$3.fsAsyncMethods = fsAsyncMethods;
  return exports$3;
}

var exports$2 = {},
    _dewExec = false;
function dew() {
  if (_dewExec) return exports$2;
  _dewExec = true;

  var __assign = exports$2 && exports$2.__assign || function () {
    __assign = Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }

      return t;
    };

    return __assign.apply(this, arguments);
  };

  Object.defineProperty(exports$2, \\"__esModule\\", {
    value: true
  });
  exports$2.fs = exports$2.createFsFromVolume = exports$2.vol = exports$2.Volume = void 0;

  var Stats_1 = dew$d();

  var Dirent_1 = dew$9();

  var volume_1 = dew$2();

  var _a = dew$1(),
      fsSyncMethods = _a.fsSyncMethods,
      fsAsyncMethods = _a.fsAsyncMethods;

  var constants_1 = dew$f();

  var F_OK = constants_1.constants.F_OK,
      R_OK = constants_1.constants.R_OK,
      W_OK = constants_1.constants.W_OK,
      X_OK = constants_1.constants.X_OK;
  exports$2.Volume = volume_1.Volume; // Default volume.

  exports$2.vol = new volume_1.Volume();

  function createFsFromVolume(vol) {
    var fs = {
      F_OK: F_OK,
      R_OK: R_OK,
      W_OK: W_OK,
      X_OK: X_OK,
      constants: constants_1.constants,
      Stats: Stats_1.default,
      Dirent: Dirent_1.default
    }; // Bind FS methods.

    for (var _i = 0, fsSyncMethods_1 = fsSyncMethods; _i < fsSyncMethods_1.length; _i++) {
      var method = fsSyncMethods_1[_i];
      if (typeof vol[method] === \\"function\\") fs[method] = vol[method].bind(vol);
    }

    for (var _a = 0, fsAsyncMethods_1 = fsAsyncMethods; _a < fsAsyncMethods_1.length; _a++) {
      var method = fsAsyncMethods_1[_a];
      if (typeof vol[method] === \\"function\\") fs[method] = vol[method].bind(vol);
    }

    fs.StatWatcher = vol.StatWatcher;
    fs.FSWatcher = vol.FSWatcher;
    fs.WriteStream = vol.WriteStream;
    fs.ReadStream = vol.ReadStream;
    fs.promises = vol.promises;
    fs._toUnixTimestamp = volume_1.toUnixTimestamp;
    return fs;
  }

  exports$2.createFsFromVolume = createFsFromVolume;
  exports$2.fs = createFsFromVolume(exports$2.vol);
  exports$2 = __assign(__assign({}, exports$2), exports$2.fs);
  exports$2.semantic = true;
  return exports$2;
}

const exports$1 = dew();
exports$1['__esModule']; exports$1['fs']; exports$1['createFsFromVolume']; exports$1['vol']; exports$1['Volume']; exports$1['semantic'];

const exports = dew$2();
exports['__esModule']; exports['FSWatcher']; exports['StatWatcher']; exports['Volume']; exports['toUnixTimestamp']; exports['bufferToEncoding']; exports['dataToBuffer']; exports['dataToStr']; exports['pathToSteps']; exports['filenameToSteps']; exports['pathToFilename']; exports['flagsToNumber']; exports['FLAGS']; exports['ReadStream']; exports['WriteStream'];

const { vol, createFsFromVolume } = exports$1;

function unimplemented(name) {
  throw new Error(\`Node.js fs \${name} is not supported by JSPM core in the browser\`);
}

vol.fromNestedJSON({
  '/dev': { stdin: '', stdout: '', stderr: '' },
  '/usr/bin': {},
  '/home': {},
  '/tmp': {},
});

vol.releasedFds = [2, 1, 0];
vol.openSync('/dev/stdin', 'w');
vol.openSync('/dev/stdout', 'r');
vol.openSync('/dev/stderr', 'r');
watchStdo('/dev/stdout', 1, console.log);
watchStdo('/dev/stderr', 2, console.error);
function watchStdo(path, fd, listener) {
  let oldSize = 0;
  const decoder = new TextDecoder();
  vol.watch(path, 'utf8', () => {
    const { size } = vol.fstatSync(fd);
    const buf = Buffer.alloc(size - oldSize);
    vol.readSync(fd, buf, 0, buf.length, oldSize);
    oldSize = size;
    listener(decoder.decode(buf, { stream: true }));
  });
}

const fs = createFsFromVolume(vol);

fs.opendir = () => unimplemented('opendir');
fs.opendirSync = () => unimplemented('opendirSync');
fs.promises.opendir = () => unimplemented('promises.opendir');
fs.cp = () => unimplemented('cp');
fs.cpSync = () => unimplemented('cpSync');
fs.promises.cp = () => unimplemented('promises.cp');
fs.readv = () => unimplemented('readv');
fs.readvSync = () => unimplemented('readvSync');
fs.rm = () => unimplemented('rm');
fs.rmSync = () => unimplemented('rmSync');
fs.promises.rm = () => unimplemented('promises.rm');
fs.Dir = () => unimplemented('Dir');
fs.promises.watch = () => unimplemented('promises.watch');

fs.FileReadStream = fs.ReadStream;
fs.FileWriteStream = fs.WriteStream;

function handleFsUrl (url, isSync) {
  if (url.protocol === 'file:')
    return fileURLToPath(url);
  if (url.protocol === 'https:' || url.protocol === 'http:') {
    const path = '\\\\\\\\\\\\\\\\url\\\\\\\\' + url.href.replaceAll(/\\\\//g, '\\\\\\\\\\\\\\\\');
    if (existsSync(path))
      return path;
    if (isSync)
      throw new Error(\`Cannot sync request URL \${url} via FS. JSPM FS support for network URLs requires using async FS methods or priming the MemFS cache first with an async request before a sync request.\`);
    return (async () => {
      const res = await fetch(url);
      if (!res.ok)
        throw new Error(\`Unable to fetch \${url.href}, \${res.status}\`);
      const buf = await res.arrayBuffer();
      writeFileSync(path, Buffer.from(buf));
      return path;
    })();
  }
  throw new Error('URL ' + url + ' not supported in JSPM FS implementation.');
}

function wrapFsSync (fn) {
  return function (path, ...args) {
    if (path instanceof URL)
      return fn(handleFsUrl(path, true), ...args);
    return fn(path, ...args);
  };
}

function wrapFsPromise (fn) {
  return async function (path, ...args) {
    if (path instanceof URL)
      return fn(await handleFsUrl(path), ...args);
    return fn(path, ...args);
  };
}

function wrapFsCallback (fn) {
  return function (path, ...args) {
    const cb = args[args.length - 1];
    if (path instanceof URL && typeof cb === 'function') {
      handleFsUrl(path).then(path => {
        fn(path, ...args);
      }, cb);
    }
    else {
      fn(path, ...args);
    }
  }; 
}

fs.promises.readFile = wrapFsPromise(fs.promises.readFile);
fs.readFile = wrapFsCallback(fs.readFile);
fs.readFileSync = wrapFsSync(fs.readFileSync);

const {
  appendFile,
  appendFileSync,
  access,
  accessSync,
  chown,
  chownSync,
  chmod,
  chmodSync,
  close,
  closeSync,
  copyFile,
  copyFileSync,
  cp,
  cpSync,
  createReadStream,
  createWriteStream,
  exists,
  existsSync,
  fchown,
  fchownSync,
  fchmod,
  fchmodSync,
  fdatasync,
  fdatasyncSync,
  fstat,
  fstatSync,
  fsync,
  fsyncSync,
  ftruncate,
  ftruncateSync,
  futimes,
  futimesSync,
  lchown,
  lchownSync,
  lchmod,
  lchmodSync,
  link,
  linkSync,
  lstat,
  lstatSync,
  mkdir,
  mkdirSync,
  mkdtemp,
  mkdtempSync,
  open,
  openSync,
  opendir,
  opendirSync,
  readdir,
  readdirSync,
  read,
  readSync,
  readv,
  readvSync,
  readFile,
  readFileSync,
  readlink,
  readlinkSync,
  realpath,
  realpathSync,
  rename,
  renameSync,
  rm,
  rmSync,
  rmdir,
  rmdirSync,
  stat,
  statSync,
  symlink,
  symlinkSync,
  truncate,
  truncateSync,
  unwatchFile,
  unlink,
  unlinkSync,
  utimes,
  utimesSync,
  watch,
  watchFile,
  writeFile,
  writeFileSync,
  write,
  writeSync,
  writev,
  writevSync,
  Dir,
  Dirent,
  Stats,
  ReadStream,
  WriteStream,
  FileReadStream,
  FileWriteStream,
  _toUnixTimestamp,
  constants: { F_OK, R_OK, W_OK, X_OK },
  constants,
  promises,
} = fs;

export { Dir, Dirent, F_OK, FileReadStream, FileWriteStream, R_OK, ReadStream, Stats, W_OK, WriteStream, X_OK, _toUnixTimestamp, access, accessSync, appendFile, appendFileSync, chmod, chmodSync, chown, chownSync, close, closeSync, constants, copyFile, copyFileSync, cp, cpSync, createReadStream, createWriteStream, fs as default, exists, existsSync, fchmod, fchmodSync, fchown, fchownSync, fdatasync, fdatasyncSync, fstat, fstatSync, fsync, fsyncSync, ftruncate, ftruncateSync, futimes, futimesSync, lchmod, lchmodSync, lchown, lchownSync, link, linkSync, lstat, lstatSync, mkdir, mkdirSync, mkdtemp, mkdtempSync, open, openSync, opendir, opendirSync, promises, read, readFile, readFileSync, readSync, readdir, readdirSync, readlink, readlinkSync, readv, readvSync, realpath, realpathSync, rename, renameSync, rm, rmSync, rmdir, rmdirSync, stat, statSync, symlink, symlinkSync, truncate, truncateSync, unlink, unlinkSync, unwatchFile, utimes, utimesSync, watch, watchFile, write, writeFile, writeFileSync, writeSync, writev, writevSync };
"
`;
